#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: OpacityMicroMap

#include "Basic.hpp"

#include "OpacityMicroMap_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "DeveloperSettings_classes.hpp"


namespace SDK
{

// Class OpacityMicroMap.OpacityMicroMapData
// 0x0068 (0x0098 - 0x0030)
class UOpacityMicroMapData final : public UObject
{
public:
	TArray<uint8>                                 ArrayData;                                         // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<uint8>                                 DescArrayData;                                     // 0x0040(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FOpacityMicroMapUsageCount>     DescArrayHistogram;                                // 0x0050(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<uint8>                                 IndexBuffer;                                       // 0x0060(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          Is16BitIndexBuffer;                                // 0x0070(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FOpacityMicroMapUsageCount>     IndexHistogram;                                    // 0x0078(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint32                                        MaxSubdivisionLevel;                               // 0x0088(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOpacityMicromapFlags                         Flags_0;                                           // 0x008C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsTwoState;                                        // 0x008D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8E[0x2];                                       // 0x008E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	uint64                                        VersionHash;                                       // 0x0090(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OpacityMicroMapData">();
	}
	static class UOpacityMicroMapData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOpacityMicroMapData>();
	}
};
static_assert(alignof(UOpacityMicroMapData) == 0x000008, "Wrong alignment on UOpacityMicroMapData");
static_assert(sizeof(UOpacityMicroMapData) == 0x000098, "Wrong size on UOpacityMicroMapData");
static_assert(offsetof(UOpacityMicroMapData, ArrayData) == 0x000030, "Member 'UOpacityMicroMapData::ArrayData' has a wrong offset!");
static_assert(offsetof(UOpacityMicroMapData, DescArrayData) == 0x000040, "Member 'UOpacityMicroMapData::DescArrayData' has a wrong offset!");
static_assert(offsetof(UOpacityMicroMapData, DescArrayHistogram) == 0x000050, "Member 'UOpacityMicroMapData::DescArrayHistogram' has a wrong offset!");
static_assert(offsetof(UOpacityMicroMapData, IndexBuffer) == 0x000060, "Member 'UOpacityMicroMapData::IndexBuffer' has a wrong offset!");
static_assert(offsetof(UOpacityMicroMapData, Is16BitIndexBuffer) == 0x000070, "Member 'UOpacityMicroMapData::Is16BitIndexBuffer' has a wrong offset!");
static_assert(offsetof(UOpacityMicroMapData, IndexHistogram) == 0x000078, "Member 'UOpacityMicroMapData::IndexHistogram' has a wrong offset!");
static_assert(offsetof(UOpacityMicroMapData, MaxSubdivisionLevel) == 0x000088, "Member 'UOpacityMicroMapData::MaxSubdivisionLevel' has a wrong offset!");
static_assert(offsetof(UOpacityMicroMapData, Flags_0) == 0x00008C, "Member 'UOpacityMicroMapData::Flags_0' has a wrong offset!");
static_assert(offsetof(UOpacityMicroMapData, IsTwoState) == 0x00008D, "Member 'UOpacityMicroMapData::IsTwoState' has a wrong offset!");
static_assert(offsetof(UOpacityMicroMapData, VersionHash) == 0x000090, "Member 'UOpacityMicroMapData::VersionHash' has a wrong offset!");

// Class OpacityMicroMap.OpacityMicroMapCollection
// 0x0050 (0x0080 - 0x0030)
class UOpacityMicroMapCollection final : public UObject
{
public:
	TMap<uint64, class UOpacityMicroMapData*>     Collection;                                        // 0x0030(0x0050)(NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OpacityMicroMapCollection">();
	}
	static class UOpacityMicroMapCollection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOpacityMicroMapCollection>();
	}
};
static_assert(alignof(UOpacityMicroMapCollection) == 0x000008, "Wrong alignment on UOpacityMicroMapCollection");
static_assert(sizeof(UOpacityMicroMapCollection) == 0x000080, "Wrong size on UOpacityMicroMapCollection");
static_assert(offsetof(UOpacityMicroMapCollection, Collection) == 0x000030, "Member 'UOpacityMicroMapCollection::Collection' has a wrong offset!");

// Class OpacityMicroMap.OpacityMicroMapAsset
// 0x0008 (0x0038 - 0x0030)
class UOpacityMicroMapAsset final : public UAssetUserData
{
public:
	class UOpacityMicroMapCollection*             Collection;                                        // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OpacityMicroMapAsset">();
	}
	static class UOpacityMicroMapAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOpacityMicroMapAsset>();
	}
};
static_assert(alignof(UOpacityMicroMapAsset) == 0x000008, "Wrong alignment on UOpacityMicroMapAsset");
static_assert(sizeof(UOpacityMicroMapAsset) == 0x000038, "Wrong size on UOpacityMicroMapAsset");
static_assert(offsetof(UOpacityMicroMapAsset, Collection) == 0x000030, "Member 'UOpacityMicroMapAsset::Collection' has a wrong offset!");

// Class OpacityMicroMap.OMMBlueprintLibrary
// 0x0000 (0x0030 - 0x0030)
class UOMMBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void RecreateStaticRaytracedMeshes(const class UObject* WorldContextObject, bool ForceDisableOpacityMicromapsInput);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OMMBlueprintLibrary">();
	}
	static class UOMMBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOMMBlueprintLibrary>();
	}
};
static_assert(alignof(UOMMBlueprintLibrary) == 0x000008, "Wrong alignment on UOMMBlueprintLibrary");
static_assert(sizeof(UOMMBlueprintLibrary) == 0x000030, "Wrong size on UOMMBlueprintLibrary");

// Class OpacityMicroMap.OpacityMicromapPluginSettings
// 0x0020 (0x0068 - 0x0048)
class UOpacityMicromapPluginSettings final : public UDeveloperSettings
{
public:
	bool                                          bEnableOpacityMicromaps;                           // 0x0048(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseOMMSDKBaker;                                   // 0x0049(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBuildOMMsOnUIChanges;                             // 0x004A(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBuildOMMsOnLevelSaved;                            // 0x004B(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FOpacityMaskTextureDesc>        OpacityMaskTextureParams;                          // 0x0050(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	int32                                         OmmCookMaxLod;                                     // 0x0060(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOpacityMicromapFormat                        OmmCookFormat;                                     // 0x0064(0x0002)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_66[0x2];                                       // 0x0066(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OpacityMicromapPluginSettings">();
	}
	static class UOpacityMicromapPluginSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOpacityMicromapPluginSettings>();
	}
};
static_assert(alignof(UOpacityMicromapPluginSettings) == 0x000008, "Wrong alignment on UOpacityMicromapPluginSettings");
static_assert(sizeof(UOpacityMicromapPluginSettings) == 0x000068, "Wrong size on UOpacityMicromapPluginSettings");
static_assert(offsetof(UOpacityMicromapPluginSettings, bEnableOpacityMicromaps) == 0x000048, "Member 'UOpacityMicromapPluginSettings::bEnableOpacityMicromaps' has a wrong offset!");
static_assert(offsetof(UOpacityMicromapPluginSettings, bUseOMMSDKBaker) == 0x000049, "Member 'UOpacityMicromapPluginSettings::bUseOMMSDKBaker' has a wrong offset!");
static_assert(offsetof(UOpacityMicromapPluginSettings, bBuildOMMsOnUIChanges) == 0x00004A, "Member 'UOpacityMicromapPluginSettings::bBuildOMMsOnUIChanges' has a wrong offset!");
static_assert(offsetof(UOpacityMicromapPluginSettings, bBuildOMMsOnLevelSaved) == 0x00004B, "Member 'UOpacityMicromapPluginSettings::bBuildOMMsOnLevelSaved' has a wrong offset!");
static_assert(offsetof(UOpacityMicromapPluginSettings, OpacityMaskTextureParams) == 0x000050, "Member 'UOpacityMicromapPluginSettings::OpacityMaskTextureParams' has a wrong offset!");
static_assert(offsetof(UOpacityMicromapPluginSettings, OmmCookMaxLod) == 0x000060, "Member 'UOpacityMicromapPluginSettings::OmmCookMaxLod' has a wrong offset!");
static_assert(offsetof(UOpacityMicromapPluginSettings, OmmCookFormat) == 0x000064, "Member 'UOpacityMicromapPluginSettings::OmmCookFormat' has a wrong offset!");

}


#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: KuroFauxPhysics

#include "Basic.hpp"

#include "Engine_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "KuroFauxPhysics_structs.hpp"


namespace SDK
{

// Class KuroFauxPhysics.KuroFauxPhysicsComponentBase
// 0x00A0 (0x02C0 - 0x0220)
#pragma pack(push, 0x1)
class alignas(0x10) UKuroFauxPhysicsComponentBase : public USceneComponent
{
public:
	bool                                          bStartDisabled;                                    // 0x0218(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreActorTimeDilation;                          // 0x0219(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStopVelocityWhenDisabled;                         // 0x021A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21B[0x1];                                      // 0x021B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PreventSleepFrameAfterWake;                        // 0x021C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxStepTime;                                       // 0x0220(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_224[0x94];                                     // 0x0224(0x0094)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddComponentTickBlocker(const struct FKuroInstigator& DisableInstigator);
	void AddDisabler(const struct FKuroInstigator& DisableInstigator);
	void ApplyForce(const struct FVector& Origin, const struct FVector& Force);
	void ApplyImpulse(const struct FVector& Origin, const struct FVector& Impulse);
	void ApplyMovement(const struct FVector& Origin, const struct FVector& Movement);
	void RemoveAllDisablers();
	void RemoveComponentTickBlocker(const struct FKuroInstigator& DisableInstigator);
	void RemoveDisabler(const struct FKuroInstigator& DisableInstigator);
	void ResetForces();
	void ResetInternalState();
	void ResetPhysics();
	void Sleep();
	void Wake();

	bool CanSleep() const;
	bool HasFauxPhysicsControl() const;
	bool IsEnabled() const;
	bool IsSleeping() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroFauxPhysicsComponentBase">();
	}
	static class UKuroFauxPhysicsComponentBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroFauxPhysicsComponentBase>();
	}
};
#pragma pack(pop)
static_assert(alignof(UKuroFauxPhysicsComponentBase) == 0x000010, "Wrong alignment on UKuroFauxPhysicsComponentBase");
static_assert(sizeof(UKuroFauxPhysicsComponentBase) == 0x0002C0, "Wrong size on UKuroFauxPhysicsComponentBase");
static_assert(offsetof(UKuroFauxPhysicsComponentBase, bStartDisabled) == 0x000218, "Member 'UKuroFauxPhysicsComponentBase::bStartDisabled' has a wrong offset!");
static_assert(offsetof(UKuroFauxPhysicsComponentBase, bIgnoreActorTimeDilation) == 0x000219, "Member 'UKuroFauxPhysicsComponentBase::bIgnoreActorTimeDilation' has a wrong offset!");
static_assert(offsetof(UKuroFauxPhysicsComponentBase, bStopVelocityWhenDisabled) == 0x00021A, "Member 'UKuroFauxPhysicsComponentBase::bStopVelocityWhenDisabled' has a wrong offset!");
static_assert(offsetof(UKuroFauxPhysicsComponentBase, PreventSleepFrameAfterWake) == 0x00021C, "Member 'UKuroFauxPhysicsComponentBase::PreventSleepFrameAfterWake' has a wrong offset!");
static_assert(offsetof(UKuroFauxPhysicsComponentBase, MaxStepTime) == 0x000220, "Member 'UKuroFauxPhysicsComponentBase::MaxStepTime' has a wrong offset!");

// Class KuroFauxPhysics.KuroFauxPhysicsRotateComponentBase
// 0x0010 (0x02D0 - 0x02C0)
class UKuroFauxPhysicsRotateComponentBase : public UKuroFauxPhysicsComponentBase
{
public:
	float                                         Friction;                                          // 0x02B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TorqueBounds;                                      // 0x02BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ForceScalar;                                       // 0x02C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpringStrength;                                    // 0x02C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C8[0x8];                                      // 0x02C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroFauxPhysicsRotateComponentBase">();
	}
	static class UKuroFauxPhysicsRotateComponentBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroFauxPhysicsRotateComponentBase>();
	}
};
static_assert(alignof(UKuroFauxPhysicsRotateComponentBase) == 0x000010, "Wrong alignment on UKuroFauxPhysicsRotateComponentBase");
static_assert(sizeof(UKuroFauxPhysicsRotateComponentBase) == 0x0002D0, "Wrong size on UKuroFauxPhysicsRotateComponentBase");
static_assert(offsetof(UKuroFauxPhysicsRotateComponentBase, Friction) == 0x0002B8, "Member 'UKuroFauxPhysicsRotateComponentBase::Friction' has a wrong offset!");
static_assert(offsetof(UKuroFauxPhysicsRotateComponentBase, TorqueBounds) == 0x0002BC, "Member 'UKuroFauxPhysicsRotateComponentBase::TorqueBounds' has a wrong offset!");
static_assert(offsetof(UKuroFauxPhysicsRotateComponentBase, ForceScalar) == 0x0002C0, "Member 'UKuroFauxPhysicsRotateComponentBase::ForceScalar' has a wrong offset!");
static_assert(offsetof(UKuroFauxPhysicsRotateComponentBase, SpringStrength) == 0x0002C4, "Member 'UKuroFauxPhysicsRotateComponentBase::SpringStrength' has a wrong offset!");

// Class KuroFauxPhysics.KuroFauxPhysicsAxisRotateComponent
// 0x0080 (0x0350 - 0x02D0)
class UKuroFauxPhysicsAxisRotateComponent final : public UKuroFauxPhysicsRotateComponentBase
{
public:
	uint8                                         Pad_2D0[0x8];                                      // 0x02D0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LocalRotationAxis;                                 // 0x02D8(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bConstrain;                                        // 0x02E4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E5[0x3];                                      // 0x02E5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ConstrainAngleMin;                                 // 0x02E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConstrainAngleMax;                                 // 0x02EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConstrainBounce;                                   // 0x02F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ImpactMinStrength;                                 // 0x02F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinTimeBetweenImpacts;                             // 0x02F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2FC[0x4];                                      // 0x02FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(float Strength)> OnMinConstraintHit;                               // 0x0300(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(float Strength)> OnMaxConstraintHit;                               // 0x0310(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_320[0x30];                                     // 0x0320(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyAngularForce(const float AngularForceRadians);
	void ApplyAngularImpulse(const float AngularImpulseRadians);
	void ApplyAngularMovement(const float AngleRadians);

	float GetCurrentAlphaBetweenConstraints() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroFauxPhysicsAxisRotateComponent">();
	}
	static class UKuroFauxPhysicsAxisRotateComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroFauxPhysicsAxisRotateComponent>();
	}
};
static_assert(alignof(UKuroFauxPhysicsAxisRotateComponent) == 0x000010, "Wrong alignment on UKuroFauxPhysicsAxisRotateComponent");
static_assert(sizeof(UKuroFauxPhysicsAxisRotateComponent) == 0x000350, "Wrong size on UKuroFauxPhysicsAxisRotateComponent");
static_assert(offsetof(UKuroFauxPhysicsAxisRotateComponent, LocalRotationAxis) == 0x0002D8, "Member 'UKuroFauxPhysicsAxisRotateComponent::LocalRotationAxis' has a wrong offset!");
static_assert(offsetof(UKuroFauxPhysicsAxisRotateComponent, bConstrain) == 0x0002E4, "Member 'UKuroFauxPhysicsAxisRotateComponent::bConstrain' has a wrong offset!");
static_assert(offsetof(UKuroFauxPhysicsAxisRotateComponent, ConstrainAngleMin) == 0x0002E8, "Member 'UKuroFauxPhysicsAxisRotateComponent::ConstrainAngleMin' has a wrong offset!");
static_assert(offsetof(UKuroFauxPhysicsAxisRotateComponent, ConstrainAngleMax) == 0x0002EC, "Member 'UKuroFauxPhysicsAxisRotateComponent::ConstrainAngleMax' has a wrong offset!");
static_assert(offsetof(UKuroFauxPhysicsAxisRotateComponent, ConstrainBounce) == 0x0002F0, "Member 'UKuroFauxPhysicsAxisRotateComponent::ConstrainBounce' has a wrong offset!");
static_assert(offsetof(UKuroFauxPhysicsAxisRotateComponent, ImpactMinStrength) == 0x0002F4, "Member 'UKuroFauxPhysicsAxisRotateComponent::ImpactMinStrength' has a wrong offset!");
static_assert(offsetof(UKuroFauxPhysicsAxisRotateComponent, MinTimeBetweenImpacts) == 0x0002F8, "Member 'UKuroFauxPhysicsAxisRotateComponent::MinTimeBetweenImpacts' has a wrong offset!");
static_assert(offsetof(UKuroFauxPhysicsAxisRotateComponent, OnMinConstraintHit) == 0x000300, "Member 'UKuroFauxPhysicsAxisRotateComponent::OnMinConstraintHit' has a wrong offset!");
static_assert(offsetof(UKuroFauxPhysicsAxisRotateComponent, OnMaxConstraintHit) == 0x000310, "Member 'UKuroFauxPhysicsAxisRotateComponent::OnMaxConstraintHit' has a wrong offset!");

// Class KuroFauxPhysics.KuroPrimitiveComponentVisualizer
// 0x0020 (0x0550 - 0x0530)
class UKuroPrimitiveComponentVisualizer : public UPrimitiveComponent
{
public:
	uint8                                         Pad_528[0x28];                                     // 0x0528(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DrawArc(const struct FVector& Base, const float Angle, const float Radius, const struct FVector& Direction, const struct FLinearColor& Color, const float Thickness, const struct FVector& Normal, int32 Sections, const float InnerRadius, const bool bDrawSides, const uint8 DepthPriority);
	void DrawArrow(const struct FVector& Start, const struct FVector& End, const struct FLinearColor& Color, const float ArrowSize, const float Thickness, bool bScreenSpace, const uint8 DepthPriority);
	void DrawCircle(const struct FVector& Origin, const float Radius, const struct FLinearColor& Color, const float Thickness, const struct FVector& Normal, const int32 LineSegments, const uint8 DepthPriority);
	void DrawDashedLine(const struct FVector& Start, const struct FVector& End, const struct FLinearColor& Color, const float DashSize, const float Thickness, const bool bScreenSpace, const int32 MaxDashes, const uint8 DepthPriority, const float DepthBias);
	void DrawLine(const struct FVector& Start, const struct FVector& End, const struct FLinearColor& Color, const float Thickness, const bool bScreenSpace, const uint8 DepthPriority);
	void DrawWireSphere(const struct FVector& Base, const float Radius, const struct FLinearColor& Color, const float Thickness, const int32 NumSides, const uint8 DepthPriority);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroPrimitiveComponentVisualizer">();
	}
	static class UKuroPrimitiveComponentVisualizer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroPrimitiveComponentVisualizer>();
	}
};
static_assert(alignof(UKuroPrimitiveComponentVisualizer) == 0x000010, "Wrong alignment on UKuroPrimitiveComponentVisualizer");
static_assert(sizeof(UKuroPrimitiveComponentVisualizer) == 0x000550, "Wrong size on UKuroPrimitiveComponentVisualizer");

// Class KuroFauxPhysics.KuroFauxPhysicsAxisRotateComponentVisualizer
// 0x0010 (0x0560 - 0x0550)
class UKuroFauxPhysicsAxisRotateComponentVisualizer final : public UKuroPrimitiveComponentVisualizer
{
public:
	uint8                                         Pad_550[0x10];                                     // 0x0550(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroFauxPhysicsAxisRotateComponentVisualizer">();
	}
	static class UKuroFauxPhysicsAxisRotateComponentVisualizer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroFauxPhysicsAxisRotateComponentVisualizer>();
	}
};
static_assert(alignof(UKuroFauxPhysicsAxisRotateComponentVisualizer) == 0x000010, "Wrong alignment on UKuroFauxPhysicsAxisRotateComponentVisualizer");
static_assert(sizeof(UKuroFauxPhysicsAxisRotateComponentVisualizer) == 0x000560, "Wrong size on UKuroFauxPhysicsAxisRotateComponentVisualizer");

// Class KuroFauxPhysics.KuroFauxPhysicsComponentDebug
// 0x0010 (0x00D0 - 0x00C0)
class UKuroFauxPhysicsComponentDebug final : public UActorComponent
{
public:
	uint8                                         Pad_C0[0x10];                                      // 0x00C0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroFauxPhysicsComponentDebug">();
	}
	static class UKuroFauxPhysicsComponentDebug* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroFauxPhysicsComponentDebug>();
	}
};
static_assert(alignof(UKuroFauxPhysicsComponentDebug) == 0x000008, "Wrong alignment on UKuroFauxPhysicsComponentDebug");
static_assert(sizeof(UKuroFauxPhysicsComponentDebug) == 0x0000D0, "Wrong size on UKuroFauxPhysicsComponentDebug");

// Class KuroFauxPhysics.KuroFauxPhysicsConeRotateComponent
// 0x0090 (0x0360 - 0x02D0)
class UKuroFauxPhysicsConeRotateComponent final : public UKuroFauxPhysicsRotateComponentBase
{
public:
	uint8                                         Pad_2D0[0x50];                                     // 0x02D0(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ConeAngle;                                         // 0x0320(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LocalConeDirection;                                // 0x0324(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConstrainBounce;                                   // 0x0330(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bConstrainTwist;                                   // 0x0334(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_335[0x3];                                      // 0x0335(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ImpactMinStrength;                                 // 0x0338(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinTimeBetweenImpacts;                             // 0x033C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(float Strength)> OnConstraintHit;                                  // 0x0340(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_350[0x10];                                     // 0x0350(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroFauxPhysicsConeRotateComponent">();
	}
	static class UKuroFauxPhysicsConeRotateComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroFauxPhysicsConeRotateComponent>();
	}
};
static_assert(alignof(UKuroFauxPhysicsConeRotateComponent) == 0x000010, "Wrong alignment on UKuroFauxPhysicsConeRotateComponent");
static_assert(sizeof(UKuroFauxPhysicsConeRotateComponent) == 0x000360, "Wrong size on UKuroFauxPhysicsConeRotateComponent");
static_assert(offsetof(UKuroFauxPhysicsConeRotateComponent, ConeAngle) == 0x000320, "Member 'UKuroFauxPhysicsConeRotateComponent::ConeAngle' has a wrong offset!");
static_assert(offsetof(UKuroFauxPhysicsConeRotateComponent, LocalConeDirection) == 0x000324, "Member 'UKuroFauxPhysicsConeRotateComponent::LocalConeDirection' has a wrong offset!");
static_assert(offsetof(UKuroFauxPhysicsConeRotateComponent, ConstrainBounce) == 0x000330, "Member 'UKuroFauxPhysicsConeRotateComponent::ConstrainBounce' has a wrong offset!");
static_assert(offsetof(UKuroFauxPhysicsConeRotateComponent, bConstrainTwist) == 0x000334, "Member 'UKuroFauxPhysicsConeRotateComponent::bConstrainTwist' has a wrong offset!");
static_assert(offsetof(UKuroFauxPhysicsConeRotateComponent, ImpactMinStrength) == 0x000338, "Member 'UKuroFauxPhysicsConeRotateComponent::ImpactMinStrength' has a wrong offset!");
static_assert(offsetof(UKuroFauxPhysicsConeRotateComponent, MinTimeBetweenImpacts) == 0x00033C, "Member 'UKuroFauxPhysicsConeRotateComponent::MinTimeBetweenImpacts' has a wrong offset!");
static_assert(offsetof(UKuroFauxPhysicsConeRotateComponent, OnConstraintHit) == 0x000340, "Member 'UKuroFauxPhysicsConeRotateComponent::OnConstraintHit' has a wrong offset!");

// Class KuroFauxPhysics.KuroFauxPhysicsConeRotateComponentVisualizer
// 0x0010 (0x0560 - 0x0550)
class UKuroFauxPhysicsConeRotateComponentVisualizer final : public UKuroPrimitiveComponentVisualizer
{
public:
	uint8                                         Pad_550[0x10];                                     // 0x0550(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroFauxPhysicsConeRotateComponentVisualizer">();
	}
	static class UKuroFauxPhysicsConeRotateComponentVisualizer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroFauxPhysicsConeRotateComponentVisualizer>();
	}
};
static_assert(alignof(UKuroFauxPhysicsConeRotateComponentVisualizer) == 0x000010, "Wrong alignment on UKuroFauxPhysicsConeRotateComponentVisualizer");
static_assert(sizeof(UKuroFauxPhysicsConeRotateComponentVisualizer) == 0x000560, "Wrong size on UKuroFauxPhysicsConeRotateComponentVisualizer");

// Class KuroFauxPhysics.KuroFauxPhysicsFreeRotateComponent
// 0x0050 (0x0320 - 0x02D0)
class UKuroFauxPhysicsFreeRotateComponent final : public UKuroFauxPhysicsRotateComponentBase
{
public:
	uint8                                         Pad_2D0[0x40];                                     // 0x02D0(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ConstrainedAngularVelocityDegrees;                 // 0x0310(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_314[0xC];                                      // 0x0314(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroFauxPhysicsFreeRotateComponent">();
	}
	static class UKuroFauxPhysicsFreeRotateComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroFauxPhysicsFreeRotateComponent>();
	}
};
static_assert(alignof(UKuroFauxPhysicsFreeRotateComponent) == 0x000010, "Wrong alignment on UKuroFauxPhysicsFreeRotateComponent");
static_assert(sizeof(UKuroFauxPhysicsFreeRotateComponent) == 0x000320, "Wrong size on UKuroFauxPhysicsFreeRotateComponent");
static_assert(offsetof(UKuroFauxPhysicsFreeRotateComponent, ConstrainedAngularVelocityDegrees) == 0x000310, "Member 'UKuroFauxPhysicsFreeRotateComponent::ConstrainedAngularVelocityDegrees' has a wrong offset!");

// Class KuroFauxPhysics.KuroFauxPhysicsFreeRotateComponentVisualizer
// 0x0010 (0x0560 - 0x0550)
class UKuroFauxPhysicsFreeRotateComponentVisualizer final : public UKuroPrimitiveComponentVisualizer
{
public:
	uint8                                         Pad_550[0x10];                                     // 0x0550(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroFauxPhysicsFreeRotateComponentVisualizer">();
	}
	static class UKuroFauxPhysicsFreeRotateComponentVisualizer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroFauxPhysicsFreeRotateComponentVisualizer>();
	}
};
static_assert(alignof(UKuroFauxPhysicsFreeRotateComponentVisualizer) == 0x000010, "Wrong alignment on UKuroFauxPhysicsFreeRotateComponentVisualizer");
static_assert(sizeof(UKuroFauxPhysicsFreeRotateComponentVisualizer) == 0x000560, "Wrong size on UKuroFauxPhysicsFreeRotateComponentVisualizer");

// Class KuroFauxPhysics.KuroVisualizedInterface
// 0x0000 (0x0000 - 0x0000)
class IKuroVisualizedInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroVisualizedInterface">();
	}
	static class IKuroVisualizedInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IKuroVisualizedInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IKuroVisualizedInterface) == 0x000001, "Wrong alignment on IKuroVisualizedInterface");
static_assert(sizeof(IKuroVisualizedInterface) == 0x000001, "Wrong size on IKuroVisualizedInterface");

// Class KuroFauxPhysics.KuroVisualizerInterface
// 0x0000 (0x0000 - 0x0000)
class IKuroVisualizerInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroVisualizerInterface">();
	}
	static class IKuroVisualizerInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IKuroVisualizerInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IKuroVisualizerInterface) == 0x000001, "Wrong alignment on IKuroVisualizerInterface");
static_assert(sizeof(IKuroVisualizerInterface) == 0x000001, "Wrong size on IKuroVisualizerInterface");

// Class KuroFauxPhysics.KuroAxisVisualizedInterface
// 0x0000 (0x0000 - 0x0000)
class IKuroAxisVisualizedInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroAxisVisualizedInterface">();
	}
	static class IKuroAxisVisualizedInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IKuroAxisVisualizedInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IKuroAxisVisualizedInterface) == 0x000001, "Wrong alignment on IKuroAxisVisualizedInterface");
static_assert(sizeof(IKuroAxisVisualizedInterface) == 0x000001, "Wrong size on IKuroAxisVisualizedInterface");

// Class KuroFauxPhysics.KuroConeVisualizedInterface
// 0x0000 (0x0000 - 0x0000)
class IKuroConeVisualizedInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroConeVisualizedInterface">();
	}
	static class IKuroConeVisualizedInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IKuroConeVisualizedInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IKuroConeVisualizedInterface) == 0x000001, "Wrong alignment on IKuroConeVisualizedInterface");
static_assert(sizeof(IKuroConeVisualizedInterface) == 0x000001, "Wrong size on IKuroConeVisualizedInterface");

// Class KuroFauxPhysics.KuroFreeVisualizedInterface
// 0x0000 (0x0000 - 0x0000)
class IKuroFreeVisualizedInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroFreeVisualizedInterface">();
	}
	static class IKuroFreeVisualizedInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IKuroFreeVisualizedInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IKuroFreeVisualizedInterface) == 0x000001, "Wrong alignment on IKuroFreeVisualizedInterface");
static_assert(sizeof(IKuroFreeVisualizedInterface) == 0x000001, "Wrong size on IKuroFreeVisualizedInterface");

// Class KuroFauxPhysics.KuroPrimitiveVisualizedInterface
// 0x0000 (0x0000 - 0x0000)
class IKuroPrimitiveVisualizedInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroPrimitiveVisualizedInterface">();
	}
	static class IKuroPrimitiveVisualizedInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IKuroPrimitiveVisualizedInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IKuroPrimitiveVisualizedInterface) == 0x000001, "Wrong alignment on IKuroPrimitiveVisualizedInterface");
static_assert(sizeof(IKuroPrimitiveVisualizedInterface) == 0x000001, "Wrong size on IKuroPrimitiveVisualizedInterface");

// Class KuroFauxPhysics.KuroFauxPhysicsTrackTargetComponent
// 0x00A0 (0x0360 - 0x02C0)
class UKuroFauxPhysicsTrackTargetComponent final : public UKuroFauxPhysicsComponentBase
{
public:
	uint8                                         Pad_2B8[0x10];                                     // 0x02B8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PredictionFactor;                                  // 0x02C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitLinearSpeed;                                   // 0x02CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StopTrackTargetDistance;                           // 0x02D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D4[0x4];                                      // 0x02D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(const struct FVector& CurrentLinearVelocity)> OnStopTrackTarget;   // 0x02D8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	struct FVector                                CurrentLinearVelocity;                             // 0x02E8(0x000C)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinTimeToIntercept;                                // 0x02F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxTimeToIntercept;                                // 0x02F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ForwardOffsetRatio;                                // 0x02FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETrackMethod                                  TrackMethod;                                       // 0x0300(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_301[0x5F];                                     // 0x0301(0x005F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FVector CustomGetDirection(const struct FVector& PosA, const struct FVector& VelA, const struct FVector& PosB, const float SpeedB);
	void StartTrackTarget(class APawn* Target);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroFauxPhysicsTrackTargetComponent">();
	}
	static class UKuroFauxPhysicsTrackTargetComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroFauxPhysicsTrackTargetComponent>();
	}
};
static_assert(alignof(UKuroFauxPhysicsTrackTargetComponent) == 0x000010, "Wrong alignment on UKuroFauxPhysicsTrackTargetComponent");
static_assert(sizeof(UKuroFauxPhysicsTrackTargetComponent) == 0x000360, "Wrong size on UKuroFauxPhysicsTrackTargetComponent");
static_assert(offsetof(UKuroFauxPhysicsTrackTargetComponent, PredictionFactor) == 0x0002C8, "Member 'UKuroFauxPhysicsTrackTargetComponent::PredictionFactor' has a wrong offset!");
static_assert(offsetof(UKuroFauxPhysicsTrackTargetComponent, InitLinearSpeed) == 0x0002CC, "Member 'UKuroFauxPhysicsTrackTargetComponent::InitLinearSpeed' has a wrong offset!");
static_assert(offsetof(UKuroFauxPhysicsTrackTargetComponent, StopTrackTargetDistance) == 0x0002D0, "Member 'UKuroFauxPhysicsTrackTargetComponent::StopTrackTargetDistance' has a wrong offset!");
static_assert(offsetof(UKuroFauxPhysicsTrackTargetComponent, OnStopTrackTarget) == 0x0002D8, "Member 'UKuroFauxPhysicsTrackTargetComponent::OnStopTrackTarget' has a wrong offset!");
static_assert(offsetof(UKuroFauxPhysicsTrackTargetComponent, CurrentLinearVelocity) == 0x0002E8, "Member 'UKuroFauxPhysicsTrackTargetComponent::CurrentLinearVelocity' has a wrong offset!");
static_assert(offsetof(UKuroFauxPhysicsTrackTargetComponent, MinTimeToIntercept) == 0x0002F4, "Member 'UKuroFauxPhysicsTrackTargetComponent::MinTimeToIntercept' has a wrong offset!");
static_assert(offsetof(UKuroFauxPhysicsTrackTargetComponent, MaxTimeToIntercept) == 0x0002F8, "Member 'UKuroFauxPhysicsTrackTargetComponent::MaxTimeToIntercept' has a wrong offset!");
static_assert(offsetof(UKuroFauxPhysicsTrackTargetComponent, ForwardOffsetRatio) == 0x0002FC, "Member 'UKuroFauxPhysicsTrackTargetComponent::ForwardOffsetRatio' has a wrong offset!");
static_assert(offsetof(UKuroFauxPhysicsTrackTargetComponent, TrackMethod) == 0x000300, "Member 'UKuroFauxPhysicsTrackTargetComponent::TrackMethod' has a wrong offset!");

// Class KuroFauxPhysics.KuroFauxPhysicsTrackTargetComponentVisualizer
// 0x0010 (0x0560 - 0x0550)
class UKuroFauxPhysicsTrackTargetComponentVisualizer final : public UKuroPrimitiveComponentVisualizer
{
public:
	uint8                                         Pad_550[0x10];                                     // 0x0550(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroFauxPhysicsTrackTargetComponentVisualizer">();
	}
	static class UKuroFauxPhysicsTrackTargetComponentVisualizer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroFauxPhysicsTrackTargetComponentVisualizer>();
	}
};
static_assert(alignof(UKuroFauxPhysicsTrackTargetComponentVisualizer) == 0x000010, "Wrong alignment on UKuroFauxPhysicsTrackTargetComponentVisualizer");
static_assert(sizeof(UKuroFauxPhysicsTrackTargetComponentVisualizer) == 0x000560, "Wrong size on UKuroFauxPhysicsTrackTargetComponentVisualizer");

}


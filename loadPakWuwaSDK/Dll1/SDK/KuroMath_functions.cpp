#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: KuroMath

#include "Basic.hpp"

#include "KuroMath_classes.hpp"
#include "KuroMath_parameters.hpp"


namespace SDK
{

// Function KuroMath.KuroBitwiseLibrary.BitwiseLeftShift
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const int64                             Source                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             Bit                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 UKuroBitwiseLibrary::BitwiseLeftShift(const int64 Source, const int32 Bit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroBitwiseLibrary", "BitwiseLeftShift");

	Params::KuroBitwiseLibrary_BitwiseLeftShift Parms{};

	Parms.Source = Source;
	Parms.Bit = Bit;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroMath.KuroBitwiseLibrary.BitwiseRightShift
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const int64                             Source                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             Bit                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 UKuroBitwiseLibrary::BitwiseRightShift(const int64 Source, const int32 Bit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroBitwiseLibrary", "BitwiseRightShift");

	Params::KuroBitwiseLibrary_BitwiseRightShift Parms{};

	Parms.Source = Source;
	Parms.Bit = Bit;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroMath.KuroBitwiseLibrary.IntBitwiseAnd
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const int32                             Num1                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             Num2                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKuroBitwiseLibrary::IntBitwiseAnd(const int32 Num1, const int32 Num2)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroBitwiseLibrary", "IntBitwiseAnd");

	Params::KuroBitwiseLibrary_IntBitwiseAnd Parms{};

	Parms.Num1 = Num1;
	Parms.Num2 = Num2;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroMath.KuroBitwiseLibrary.IntBitwiseNot
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const int32                             Num                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKuroBitwiseLibrary::IntBitwiseNot(const int32 Num)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroBitwiseLibrary", "IntBitwiseNot");

	Params::KuroBitwiseLibrary_IntBitwiseNot Parms{};

	Parms.Num = Num;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroMath.KuroBitwiseLibrary.IntBitwiseOr
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const int32                             Num1                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             Num2                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKuroBitwiseLibrary::IntBitwiseOr(const int32 Num1, const int32 Num2)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroBitwiseLibrary", "IntBitwiseOr");

	Params::KuroBitwiseLibrary_IntBitwiseOr Parms{};

	Parms.Num1 = Num1;
	Parms.Num2 = Num2;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroMath.KuroBitwiseLibrary.IntBitwiseXOr
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const int32                             Num1                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             Num2                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKuroBitwiseLibrary::IntBitwiseXOr(const int32 Num1, const int32 Num2)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroBitwiseLibrary", "IntBitwiseXOr");

	Params::KuroBitwiseLibrary_IntBitwiseXOr Parms{};

	Parms.Num1 = Num1;
	Parms.Num2 = Num2;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroMath.KuroBitwiseLibrary.KuroStringToInt64
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FString&                    StringNum                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 UKuroBitwiseLibrary::KuroStringToInt64(const class FString& StringNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroBitwiseLibrary", "KuroStringToInt64");

	Params::KuroBitwiseLibrary_KuroStringToInt64 Parms{};

	Parms.StringNum = std::move(StringNum);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroMath.KuroBitwiseLibrary.LongBitwiseAnd
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const int64                             Num1                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int64                             Num2                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 UKuroBitwiseLibrary::LongBitwiseAnd(const int64 Num1, const int64 Num2)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroBitwiseLibrary", "LongBitwiseAnd");

	Params::KuroBitwiseLibrary_LongBitwiseAnd Parms{};

	Parms.Num1 = Num1;
	Parms.Num2 = Num2;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroMath.KuroBitwiseLibrary.LongBitwiseNot
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const int64                             Num                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 UKuroBitwiseLibrary::LongBitwiseNot(const int64 Num)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroBitwiseLibrary", "LongBitwiseNot");

	Params::KuroBitwiseLibrary_LongBitwiseNot Parms{};

	Parms.Num = Num;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroMath.KuroBitwiseLibrary.LongBitwiseOr
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const int64                             Num1                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int64                             Num2                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 UKuroBitwiseLibrary::LongBitwiseOr(const int64 Num1, const int64 Num2)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroBitwiseLibrary", "LongBitwiseOr");

	Params::KuroBitwiseLibrary_LongBitwiseOr Parms{};

	Parms.Num1 = Num1;
	Parms.Num2 = Num2;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroMath.KuroBitwiseLibrary.LongBitwiseXOr
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const int64                             Num1                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int64                             Num2                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 UKuroBitwiseLibrary::LongBitwiseXOr(const int64 Num1, const int64 Num2)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroBitwiseLibrary", "LongBitwiseXOr");

	Params::KuroBitwiseLibrary_LongBitwiseXOr Parms{};

	Parms.Num1 = Num1;
	Parms.Num2 = Num2;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroMath.KuroEasingLibrary.EaseInBack
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const float                             X                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKuroEasingLibrary::EaseInBack(const float X)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroEasingLibrary", "EaseInBack");

	Params::KuroEasingLibrary_EaseInBack Parms{};

	Parms.X = X;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroMath.KuroEasingLibrary.EaseInBounce
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const float                             X                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKuroEasingLibrary::EaseInBounce(const float X)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroEasingLibrary", "EaseInBounce");

	Params::KuroEasingLibrary_EaseInBounce Parms{};

	Parms.X = X;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroMath.KuroEasingLibrary.EaseInCirc
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const float                             X                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKuroEasingLibrary::EaseInCirc(const float X)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroEasingLibrary", "EaseInCirc");

	Params::KuroEasingLibrary_EaseInCirc Parms{};

	Parms.X = X;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroMath.KuroEasingLibrary.EaseInCubic
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const float                             X                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKuroEasingLibrary::EaseInCubic(const float X)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroEasingLibrary", "EaseInCubic");

	Params::KuroEasingLibrary_EaseInCubic Parms{};

	Parms.X = X;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroMath.KuroEasingLibrary.EaseInElastic
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const float                             X                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKuroEasingLibrary::EaseInElastic(const float X)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroEasingLibrary", "EaseInElastic");

	Params::KuroEasingLibrary_EaseInElastic Parms{};

	Parms.X = X;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroMath.KuroEasingLibrary.EaseInExpo
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const float                             X                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKuroEasingLibrary::EaseInExpo(const float X)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroEasingLibrary", "EaseInExpo");

	Params::KuroEasingLibrary_EaseInExpo Parms{};

	Parms.X = X;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroMath.KuroEasingLibrary.EaseInOutBack
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const float                             X                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKuroEasingLibrary::EaseInOutBack(const float X)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroEasingLibrary", "EaseInOutBack");

	Params::KuroEasingLibrary_EaseInOutBack Parms{};

	Parms.X = X;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroMath.KuroEasingLibrary.EaseInOutBounce
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const float                             X                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKuroEasingLibrary::EaseInOutBounce(const float X)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroEasingLibrary", "EaseInOutBounce");

	Params::KuroEasingLibrary_EaseInOutBounce Parms{};

	Parms.X = X;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroMath.KuroEasingLibrary.EaseInOutCirc
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const float                             X                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKuroEasingLibrary::EaseInOutCirc(const float X)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroEasingLibrary", "EaseInOutCirc");

	Params::KuroEasingLibrary_EaseInOutCirc Parms{};

	Parms.X = X;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroMath.KuroEasingLibrary.EaseInOutCubic
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const float                             X                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKuroEasingLibrary::EaseInOutCubic(const float X)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroEasingLibrary", "EaseInOutCubic");

	Params::KuroEasingLibrary_EaseInOutCubic Parms{};

	Parms.X = X;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroMath.KuroEasingLibrary.EaseInOutElastic
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const float                             X                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKuroEasingLibrary::EaseInOutElastic(const float X)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroEasingLibrary", "EaseInOutElastic");

	Params::KuroEasingLibrary_EaseInOutElastic Parms{};

	Parms.X = X;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroMath.KuroEasingLibrary.EaseInOutExpo
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const float                             X                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKuroEasingLibrary::EaseInOutExpo(const float X)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroEasingLibrary", "EaseInOutExpo");

	Params::KuroEasingLibrary_EaseInOutExpo Parms{};

	Parms.X = X;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroMath.KuroEasingLibrary.EaseInOutQuad
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const float                             X                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKuroEasingLibrary::EaseInOutQuad(const float X)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroEasingLibrary", "EaseInOutQuad");

	Params::KuroEasingLibrary_EaseInOutQuad Parms{};

	Parms.X = X;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroMath.KuroEasingLibrary.EaseInOutQuart
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const float                             X                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKuroEasingLibrary::EaseInOutQuart(const float X)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroEasingLibrary", "EaseInOutQuart");

	Params::KuroEasingLibrary_EaseInOutQuart Parms{};

	Parms.X = X;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroMath.KuroEasingLibrary.EaseInOutQuint
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const float                             X                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKuroEasingLibrary::EaseInOutQuint(const float X)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroEasingLibrary", "EaseInOutQuint");

	Params::KuroEasingLibrary_EaseInOutQuint Parms{};

	Parms.X = X;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroMath.KuroEasingLibrary.EaseInOutSine
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const float                             X                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKuroEasingLibrary::EaseInOutSine(const float X)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroEasingLibrary", "EaseInOutSine");

	Params::KuroEasingLibrary_EaseInOutSine Parms{};

	Parms.X = X;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroMath.KuroEasingLibrary.EaseInQuad
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const float                             X                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKuroEasingLibrary::EaseInQuad(const float X)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroEasingLibrary", "EaseInQuad");

	Params::KuroEasingLibrary_EaseInQuad Parms{};

	Parms.X = X;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroMath.KuroEasingLibrary.EaseInQuart
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const float                             X                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKuroEasingLibrary::EaseInQuart(const float X)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroEasingLibrary", "EaseInQuart");

	Params::KuroEasingLibrary_EaseInQuart Parms{};

	Parms.X = X;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroMath.KuroEasingLibrary.EaseInQuint
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const float                             X                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKuroEasingLibrary::EaseInQuint(const float X)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroEasingLibrary", "EaseInQuint");

	Params::KuroEasingLibrary_EaseInQuint Parms{};

	Parms.X = X;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroMath.KuroEasingLibrary.EaseInSine
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const float                             X                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKuroEasingLibrary::EaseInSine(const float X)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroEasingLibrary", "EaseInSine");

	Params::KuroEasingLibrary_EaseInSine Parms{};

	Parms.X = X;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroMath.KuroEasingLibrary.EaseOutBack
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const float                             X                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKuroEasingLibrary::EaseOutBack(const float X)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroEasingLibrary", "EaseOutBack");

	Params::KuroEasingLibrary_EaseOutBack Parms{};

	Parms.X = X;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroMath.KuroEasingLibrary.EaseOutBounce
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const float                             X                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKuroEasingLibrary::EaseOutBounce(const float X)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroEasingLibrary", "EaseOutBounce");

	Params::KuroEasingLibrary_EaseOutBounce Parms{};

	Parms.X = X;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroMath.KuroEasingLibrary.EaseOutCirc
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const float                             X                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKuroEasingLibrary::EaseOutCirc(const float X)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroEasingLibrary", "EaseOutCirc");

	Params::KuroEasingLibrary_EaseOutCirc Parms{};

	Parms.X = X;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroMath.KuroEasingLibrary.EaseOutCubic
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const float                             X                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKuroEasingLibrary::EaseOutCubic(const float X)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroEasingLibrary", "EaseOutCubic");

	Params::KuroEasingLibrary_EaseOutCubic Parms{};

	Parms.X = X;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroMath.KuroEasingLibrary.EaseOutElastic
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const float                             X                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKuroEasingLibrary::EaseOutElastic(const float X)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroEasingLibrary", "EaseOutElastic");

	Params::KuroEasingLibrary_EaseOutElastic Parms{};

	Parms.X = X;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroMath.KuroEasingLibrary.EaseOutExpo
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const float                             X                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKuroEasingLibrary::EaseOutExpo(const float X)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroEasingLibrary", "EaseOutExpo");

	Params::KuroEasingLibrary_EaseOutExpo Parms{};

	Parms.X = X;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroMath.KuroEasingLibrary.EaseOutQuad
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const float                             X                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKuroEasingLibrary::EaseOutQuad(const float X)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroEasingLibrary", "EaseOutQuad");

	Params::KuroEasingLibrary_EaseOutQuad Parms{};

	Parms.X = X;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroMath.KuroEasingLibrary.EaseOutQuart
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const float                             X                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKuroEasingLibrary::EaseOutQuart(const float X)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroEasingLibrary", "EaseOutQuart");

	Params::KuroEasingLibrary_EaseOutQuart Parms{};

	Parms.X = X;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroMath.KuroEasingLibrary.EaseOutQuint
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const float                             X                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKuroEasingLibrary::EaseOutQuint(const float X)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroEasingLibrary", "EaseOutQuint");

	Params::KuroEasingLibrary_EaseOutQuint Parms{};

	Parms.X = X;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroMath.KuroEasingLibrary.EaseOutSine
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const float                             X                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKuroEasingLibrary::EaseOutSine(const float X)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroEasingLibrary", "EaseOutSine");

	Params::KuroEasingLibrary_EaseOutSine Parms{};

	Parms.X = X;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroMath.KuroEasingLibrary.GetEasedValue
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const EEasingType                       EaseType                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             X                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKuroEasingLibrary::GetEasedValue(const EEasingType EaseType, const float X)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroEasingLibrary", "GetEasedValue");

	Params::KuroEasingLibrary_GetEasedValue Parms{};

	Parms.EaseType = EaseType;
	Parms.X = X;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroMath.KuroSimplePolygonLibrary.Conv_ArrayToKuroGeometrySimplePolygon
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const TArray<struct FVectorDouble>&     PathVertices                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// struct FKuroGeometrySimplePolygon       ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FKuroGeometrySimplePolygon UKuroSimplePolygonLibrary::Conv_ArrayToKuroGeometrySimplePolygon(const TArray<struct FVectorDouble>& PathVertices)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroSimplePolygonLibrary", "Conv_ArrayToKuroGeometrySimplePolygon");

	Params::KuroSimplePolygonLibrary_Conv_ArrayToKuroGeometrySimplePolygon Parms{};

	Parms.PathVertices = std::move(PathVertices);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroMath.KuroSimplePolygonLibrary.Conv_KuroGeometrySimplePolygonToArray
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FKuroGeometrySimplePolygon&Polygon                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<struct FVectorDouble>            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FVectorDouble> UKuroSimplePolygonLibrary::Conv_KuroGeometrySimplePolygonToArray(const struct FKuroGeometrySimplePolygon& Polygon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroSimplePolygonLibrary", "Conv_KuroGeometrySimplePolygonToArray");

	Params::KuroSimplePolygonLibrary_Conv_KuroGeometrySimplePolygonToArray Parms{};

	Parms.Polygon = std::move(Polygon);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroMath.KuroSimplePolygonLibrary.SampleSplineToPolygon
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class USplineComponent*           Spline                                                 (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FKuroGeometrySimplePolygon*      Polygon                                                (Parm, OutParm, NativeAccessSpecifierPublic)
// const struct FKuroSplineSamplingOptions&SamplingOptions                                        (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UKuroSimplePolygonLibrary::SampleSplineToPolygon(const class USplineComponent* Spline, struct FKuroGeometrySimplePolygon* Polygon, const struct FKuroSplineSamplingOptions& SamplingOptions)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroSimplePolygonLibrary", "SampleSplineToPolygon");

	Params::KuroSimplePolygonLibrary_SampleSplineToPolygon Parms{};

	Parms.Spline = Spline;
	Parms.SamplingOptions = std::move(SamplingOptions);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Polygon != nullptr)
		*Polygon = std::move(Parms.Polygon);
}


// Function KuroMath.KuroPolygonListLibrary.AddPolygonToList
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FKuroGeometryGeneralPolygonList& PolygonList                                            (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FKuroGeometrySimplePolygon&OuterPolygon                                           (Parm, NativeAccessSpecifierPublic)
// const TArray<struct FKuroGeometrySimplePolygon>&HolePolygons                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bFixHoleOrientations                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKuroPolygonListLibrary::AddPolygonToList(struct FKuroGeometryGeneralPolygonList& PolygonList, const struct FKuroGeometrySimplePolygon& OuterPolygon, const TArray<struct FKuroGeometrySimplePolygon>& HolePolygons, bool bFixHoleOrientations)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroPolygonListLibrary", "AddPolygonToList");

	Params::KuroPolygonListLibrary_AddPolygonToList Parms{};

	Parms.PolygonList = std::move(PolygonList);
	Parms.OuterPolygon = std::move(OuterPolygon);
	Parms.HolePolygons = std::move(HolePolygons);
	Parms.bFixHoleOrientations = bFixHoleOrientations;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	PolygonList = std::move(Parms.PolygonList);

	return Parms.ReturnValue;
}


// Function KuroMath.KuroPolygonListLibrary.AppendPolygonList
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FKuroGeometryGeneralPolygonList& PolygonList                                            (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FKuroGeometryGeneralPolygonList&PolygonsToAppend                                       (Parm, NativeAccessSpecifierPublic)

void UKuroPolygonListLibrary::AppendPolygonList(struct FKuroGeometryGeneralPolygonList& PolygonList, const struct FKuroGeometryGeneralPolygonList& PolygonsToAppend)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroPolygonListLibrary", "AppendPolygonList");

	Params::KuroPolygonListLibrary_AppendPolygonList Parms{};

	Parms.PolygonList = std::move(PolygonList);
	Parms.PolygonsToAppend = std::move(PolygonsToAppend);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	PolygonList = std::move(Parms.PolygonList);
}


// Function KuroMath.KuroPolygonListLibrary.CreatePolygonListFromSimplePolygons
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<struct FKuroGeometrySimplePolygon>&OuterPolygons                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// struct FKuroGeometryGeneralPolygonList  ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FKuroGeometryGeneralPolygonList UKuroPolygonListLibrary::CreatePolygonListFromSimplePolygons(const TArray<struct FKuroGeometrySimplePolygon>& OuterPolygons)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroPolygonListLibrary", "CreatePolygonListFromSimplePolygons");

	Params::KuroPolygonListLibrary_CreatePolygonListFromSimplePolygons Parms{};

	Parms.OuterPolygons = std::move(OuterPolygons);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroMath.KuroPolygonListLibrary.CreatePolygonListFromSinglePolygon
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FKuroGeometrySimplePolygon&OuterPolygon                                           (Parm, NativeAccessSpecifierPublic)
// const TArray<struct FKuroGeometrySimplePolygon>&HolePolygons                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bFixHoleOrientations                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FKuroGeometryGeneralPolygonList  ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FKuroGeometryGeneralPolygonList UKuroPolygonListLibrary::CreatePolygonListFromSinglePolygon(const struct FKuroGeometrySimplePolygon& OuterPolygon, const TArray<struct FKuroGeometrySimplePolygon>& HolePolygons, bool bFixHoleOrientations)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroPolygonListLibrary", "CreatePolygonListFromSinglePolygon");

	Params::KuroPolygonListLibrary_CreatePolygonListFromSinglePolygon Parms{};

	Parms.OuterPolygon = std::move(OuterPolygon);
	Parms.HolePolygons = std::move(HolePolygons);
	Parms.bFixHoleOrientations = bFixHoleOrientations;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroMath.KuroPolygonListLibrary.GetPolygonCount
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const struct FKuroGeometryGeneralPolygonList&PolygonList                                            (ConstParm, Parm, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKuroPolygonListLibrary::GetPolygonCount(const struct FKuroGeometryGeneralPolygonList& PolygonList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroPolygonListLibrary", "GetPolygonCount");

	Params::KuroPolygonListLibrary_GetPolygonCount Parms{};

	Parms.PolygonList = std::move(PolygonList);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroMath.KuroPolygonListLibrary.GetSimplePolygon
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FKuroGeometryGeneralPolygonList&PolygonList                                            (Parm, NativeAccessSpecifierPublic)
// bool*                                   bValidIndices                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PolygonIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   HoleIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FKuroGeometrySimplePolygon       ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FKuroGeometrySimplePolygon UKuroPolygonListLibrary::GetSimplePolygon(const struct FKuroGeometryGeneralPolygonList& PolygonList, bool* bValidIndices, int32 PolygonIndex, int32 HoleIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroPolygonListLibrary", "GetSimplePolygon");

	Params::KuroPolygonListLibrary_GetSimplePolygon Parms{};

	Parms.PolygonList = std::move(PolygonList);
	Parms.PolygonIndex = PolygonIndex;
	Parms.HoleIndex = HoleIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bValidIndices != nullptr)
		*bValidIndices = Parms.bValidIndices;

	return Parms.ReturnValue;
}


// Function KuroMath.KuroPolygonListLibrary.PolygonsDifference
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const struct FKuroGeometryGeneralPolygonList&PolygonList                                            (Parm, NativeAccessSpecifierPublic)
// const struct FKuroGeometryGeneralPolygonList&PolygonsToSubtract                                     (Parm, NativeAccessSpecifierPublic)
// struct FKuroGeometryGeneralPolygonList  ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FKuroGeometryGeneralPolygonList UKuroPolygonListLibrary::PolygonsDifference(const struct FKuroGeometryGeneralPolygonList& PolygonList, const struct FKuroGeometryGeneralPolygonList& PolygonsToSubtract)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroPolygonListLibrary", "PolygonsDifference");

	Params::KuroPolygonListLibrary_PolygonsDifference Parms{};

	Parms.PolygonList = std::move(PolygonList);
	Parms.PolygonsToSubtract = std::move(PolygonsToSubtract);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroMath.KuroPolygonListLibrary.PolygonsExclusiveOr
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const struct FKuroGeometryGeneralPolygonList&PolygonList                                            (Parm, NativeAccessSpecifierPublic)
// const struct FKuroGeometryGeneralPolygonList&PolygonsToExclusiveOr                                  (Parm, NativeAccessSpecifierPublic)
// struct FKuroGeometryGeneralPolygonList  ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FKuroGeometryGeneralPolygonList UKuroPolygonListLibrary::PolygonsExclusiveOr(const struct FKuroGeometryGeneralPolygonList& PolygonList, const struct FKuroGeometryGeneralPolygonList& PolygonsToExclusiveOr)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroPolygonListLibrary", "PolygonsExclusiveOr");

	Params::KuroPolygonListLibrary_PolygonsExclusiveOr Parms{};

	Parms.PolygonList = std::move(PolygonList);
	Parms.PolygonsToExclusiveOr = std::move(PolygonsToExclusiveOr);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroMath.KuroPolygonListLibrary.PolygonsIntersection
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const struct FKuroGeometryGeneralPolygonList&PolygonList                                            (Parm, NativeAccessSpecifierPublic)
// const struct FKuroGeometryGeneralPolygonList&PolygonsToIntersect                                    (Parm, NativeAccessSpecifierPublic)
// struct FKuroGeometryGeneralPolygonList  ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FKuroGeometryGeneralPolygonList UKuroPolygonListLibrary::PolygonsIntersection(const struct FKuroGeometryGeneralPolygonList& PolygonList, const struct FKuroGeometryGeneralPolygonList& PolygonsToIntersect)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroPolygonListLibrary", "PolygonsIntersection");

	Params::KuroPolygonListLibrary_PolygonsIntersection Parms{};

	Parms.PolygonList = std::move(PolygonList);
	Parms.PolygonsToIntersect = std::move(PolygonsToIntersect);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroMath.KuroPolygonListLibrary.PolygonsOpenPathsDifference
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const struct FKuroGeometryGeneralPolygonList&PolygonList                                            (Parm, NativeAccessSpecifierPublic)
// const struct FKuroGeometryGeneralPolygonList&PolygonsToSubtract                                     (Parm, NativeAccessSpecifierPublic)
// double                                  StrokeWidth                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EJoinType                               JoinType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEndType                                EndType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FKuroGeometryGeneralPolygonList  ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FKuroGeometryGeneralPolygonList UKuroPolygonListLibrary::PolygonsOpenPathsDifference(const struct FKuroGeometryGeneralPolygonList& PolygonList, const struct FKuroGeometryGeneralPolygonList& PolygonsToSubtract, double StrokeWidth, EJoinType JoinType, EEndType EndType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroPolygonListLibrary", "PolygonsOpenPathsDifference");

	Params::KuroPolygonListLibrary_PolygonsOpenPathsDifference Parms{};

	Parms.PolygonList = std::move(PolygonList);
	Parms.PolygonsToSubtract = std::move(PolygonsToSubtract);
	Parms.StrokeWidth = StrokeWidth;
	Parms.JoinType = JoinType;
	Parms.EndType = EndType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroMath.KuroPolygonListLibrary.PolygonsUnion
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const struct FKuroGeometryGeneralPolygonList&PolygonList                                            (Parm, NativeAccessSpecifierPublic)
// bool                                    bCopyInputOnFailure                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FKuroGeometryGeneralPolygonList  ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FKuroGeometryGeneralPolygonList UKuroPolygonListLibrary::PolygonsUnion(const struct FKuroGeometryGeneralPolygonList& PolygonList, bool bCopyInputOnFailure)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroPolygonListLibrary", "PolygonsUnion");

	Params::KuroPolygonListLibrary_PolygonsUnion Parms{};

	Parms.PolygonList = std::move(PolygonList);
	Parms.bCopyInputOnFailure = bCopyInputOnFailure;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroMath.KuroPolygonLibrary.ClipPolygonByWeilerAtherton
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<struct FVector2D>*               Polygon                                                (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<struct FVector2D>*               Window                                                 (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<struct FVector2D>                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FVector2D> UKuroPolygonLibrary::ClipPolygonByWeilerAtherton(TArray<struct FVector2D>* Polygon, TArray<struct FVector2D>* Window)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroPolygonLibrary", "ClipPolygonByWeilerAtherton");

	Params::KuroPolygonLibrary_ClipPolygonByWeilerAtherton Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Polygon != nullptr)
		*Polygon = std::move(Parms.Polygon);

	if (Window != nullptr)
		*Window = std::move(Parms.Window);

	return Parms.ReturnValue;
}


// Function KuroMath.KuroPolygonLibrary.EliminateSplineGaps
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const TArray<class USplineComponent*>&  Splines                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// const float                             Tolerance                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroPolygonLibrary::EliminateSplineGaps(const TArray<class USplineComponent*>& Splines, const float Tolerance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroPolygonLibrary", "EliminateSplineGaps");

	Params::KuroPolygonLibrary_EliminateSplineGaps Parms{};

	Parms.Splines = std::move(Splines);
	Parms.Tolerance = Tolerance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}

}


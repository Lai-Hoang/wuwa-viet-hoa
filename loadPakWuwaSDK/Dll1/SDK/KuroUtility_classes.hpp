#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: KuroUtility

#include "Basic.hpp"

#include "CoreUObject_classes.hpp"
#include "KuroUtility_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"


namespace SDK
{

// Class KuroUtility.AsyncLoadState
// 0x0020 (0x0050 - 0x0030)
class UAsyncLoadState final : public UObject
{
public:
	TMulticastInlineDelegate<void(class UClass* ClassLoaded, class UObject* UserData)> ClassLoadedDelegate; // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UObject* ObjectLoaded, class UObject* UserData)> ObjectLoadedDelegate; // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void AsyncLoadClass(const class FString& InPath, class UObject* UserData);
	void AsyncLoadObject(const class FString& InPath, class UObject* UserData);

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("AsyncLoadState")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"AsyncLoadState")
	}
	static class UAsyncLoadState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAsyncLoadState>();
	}
};
DUMPER7_ASSERTS_UAsyncLoadState;

// Class KuroUtility.HoldPreloadObject
// 0x0060 (0x0090 - 0x0030)
class UHoldPreloadObject final : public UObject
{
public:
	TArray<class UObject*>                        CommonAssets;                                      // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TMap<int32, struct FPreloadObjectCollection>  EntityAssetMap;                                    // 0x0040(0x0050)(NativeAccessSpecifierPrivate)

public:
	void AddCommonAsset(class UObject* InObject);
	bool AddEntityAsset(const int32 EntityId, class UObject* InObject);
	void Clear();
	void ClearCommonAsset();
	void ClearEntityAssetMap();
	TArray<class UObject*> GetCommonAssetArray();
	bool GetEntityAssetArray(const int32 EntityId, TArray<class UObject*>* OutAssets);
	bool RemoveEntityAssets(const int32 EntityId);

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("HoldPreloadObject")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"HoldPreloadObject")
	}
	static class UHoldPreloadObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHoldPreloadObject>();
	}
};
DUMPER7_ASSERTS_UHoldPreloadObject;

// Class KuroUtility.KuroActor
// 0x0000 (0x02B0 - 0x02B0)
class AKuroActor : public AActor
{
public:
	void ReceiveKuroActorBack();
	void ReceiveKuroActorGet();

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("KuroActor")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"KuroActor")
	}
	static class AKuroActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKuroActor>();
	}
};
DUMPER7_ASSERTS_AKuroActor;

// Class KuroUtility.KuroActorComponent
// 0x0000 (0x00C0 - 0x00C0)
class UKuroActorComponent final : public UActorComponent
{
public:
	void EditorTickComponent(float DeltaTime);

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("KuroActorComponent")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"KuroActorComponent")
	}
	static class UKuroActorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroActorComponent>();
	}
};
DUMPER7_ASSERTS_UKuroActorComponent;

// Class KuroUtility.KuroActorEventBinder
// 0x0010 (0x0040 - 0x0030)
class UKuroActorEventBinder final : public UObject
{
public:
	TMulticastInlineDelegate<void(class AActor* Actor, bool bContent)> Callback;                     // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("KuroActorEventBinder")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"KuroActorEventBinder")
	}
	static class UKuroActorEventBinder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroActorEventBinder>();
	}
};
DUMPER7_ASSERTS_UKuroActorEventBinder;

// Class KuroUtility.KuroActorLevelVolume
// 0x00C8 (0x03B0 - 0x02E8)
class AKuroActorLevelVolume final : public AVolume
{
public:
	class FName                                   VolumeId;                                          // 0x02E8(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F4[0x4];                                      // 0x02F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 TAPDUrl;                                           // 0x02F8(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSet<class FString>                           ExcludeActorType;                                  // 0x0308(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)
	TSet<class FString>                           ExcludeActorName;                                  // 0x0358(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)
	EActorPartitionVolumeType                     Type;                                              // 0x03A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A9[0x7];                                      // 0x03A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("KuroActorLevelVolume")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"KuroActorLevelVolume")
	}
	static class AKuroActorLevelVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKuroActorLevelVolume>();
	}
};
DUMPER7_ASSERTS_AKuroActorLevelVolume;

// Class KuroUtility.KuroActorManager
// 0x0000 (0x0030 - 0x0030)
class UKuroActorManager final : public UBlueprintFunctionLibrary
{
public:
	static void Clear();
	static bool ClearAcquiredComponents(class AActor* Actor);
	static class AActor* D_SpawnActor(const class UObject* WorldContextObject, const TSubclassOf<class AActor> ActorClass, const struct FTransformDouble& SpawnTransform, ESpawnActorCollisionHandlingMethod CollisionHandlingOverride, class AActor* Owner, class APawn* Instigator, bool bAsPoolActor);
	static void DestroyActor(class AActor* Actor);
	static TArray<class FString> GetAllAcquiredComponents(class AActor* Actor);
	static class ULevelSequence* GetDummySequence();
	static int32 GetResourceSizeBytes(class AActor* Actor, bool isExclusive);
	static void InitActorManager();
	static bool IsActorPoolEnable();
	static bool IsPooledActor(const class AActor* Actor);
	static void RegisterActorSkipProperties(class UClass* Class_0, const TArray<struct FPropertyPair>& Properties);
	static bool ResetActorToDefault(class AActor* Actor);
	static void ResetClassPropertyCache(class UClass* Class_0);
	static void ResetDelegates(class AActor* Actor);
	static void ResetUberGraph(class UObject* Obj);
	static void ResetUObjectByCDO(class UObject* Obj);
	static class AActor* SpawnActor(const class UObject* WorldContextObject, const TSubclassOf<class AActor> ActorClass, const struct FTransform& SpawnTransform, ESpawnActorCollisionHandlingMethod CollisionHandlingOverride, class AActor* Owner, class APawn* Instigator, bool bAsPoolActor);
	static void UnregisterComponent(class UActorComponent* Componet);

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("KuroActorManager")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"KuroActorManager")
	}
	static class UKuroActorManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroActorManager>();
	}
};
DUMPER7_ASSERTS_UKuroActorManager;

// Class KuroUtility.KuroActorPartitionVolume
// 0x00D0 (0x03B8 - 0x02E8)
class AKuroActorPartitionVolume final : public AVolume
{
public:
	class FName                                   VolumeId;                                          // 0x02E8(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F4[0x4];                                      // 0x02F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 BotURL;                                            // 0x02F8(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EActorPartitionVolumeType                     Type;                                              // 0x0308(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_309[0x7];                                      // 0x0309(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class FString>                           ExcludeActorType;                                  // 0x0310(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)
	TSet<class FString>                           ExcludeActorName;                                  // 0x0360(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B0[0x8];                                      // 0x03B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("KuroActorPartitionVolume")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"KuroActorPartitionVolume")
	}
	static class AKuroActorPartitionVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKuroActorPartitionVolume>();
	}
};
DUMPER7_ASSERTS_AKuroActorPartitionVolume;

// Class KuroUtility.KuroApplicationLibrary
// 0x0000 (0x0030 - 0x0030)
class UKuroApplicationLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool AddApplicationLifetimeDelegate(const TDelegate<void(int32 Type)>& InDelegate);
	static bool AddEditorPreEndPIEDelegate(const TDelegate<void(bool bSimulateInEditor)>& InDelegate);
	static bool AddWindowActivationDelegate(const TDelegate<void(bool Activated)>& InDelegate);
	static bool Test(int32 Type);
	static bool UnBind();

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("KuroApplicationLibrary")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"KuroApplicationLibrary")
	}
	static class UKuroApplicationLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroApplicationLibrary>();
	}
};
DUMPER7_ASSERTS_UKuroApplicationLibrary;

// Class KuroUtility.KuroBlockingVolume
// 0x0010 (0x02F8 - 0x02E8)
class AKuroBlockingVolume final : public AVolume
{
public:
	class FName                                   VolumeId;                                          // 0x02E8(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2F4[0x4];                                      // 0x02F4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("KuroBlockingVolume")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"KuroBlockingVolume")
	}
	static class AKuroBlockingVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKuroBlockingVolume>();
	}
};
DUMPER7_ASSERTS_AKuroBlockingVolume;

// Class KuroUtility.KuroBooleanEventBinder
// 0x0010 (0x0040 - 0x0030)
class UKuroBooleanEventBinder final : public UObject
{
public:
	TMulticastInlineDelegate<void(bool bContent)> Callback;                                          // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("KuroBooleanEventBinder")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"KuroBooleanEventBinder")
	}
	static class UKuroBooleanEventBinder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroBooleanEventBinder>();
	}
};
DUMPER7_ASSERTS_UKuroBooleanEventBinder;

// Class KuroUtility.KuroBpDataAsset
// 0x0000 (0x0038 - 0x0038)
class UKuroBpDataAsset : public UPrimaryDataAsset
{
public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("KuroBpDataAsset")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"KuroBpDataAsset")
	}
	static class UKuroBpDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroBpDataAsset>();
	}
};
DUMPER7_ASSERTS_UKuroBpDataAsset;

// Class KuroUtility.KuroBpDataAssetGroup
// 0x0010 (0x0048 - 0x0038)
class UKuroBpDataAssetGroup final : public UDataAsset
{
public:
	TArray<class UKuroBpDataAsset*>               Data;                                              // 0x0038(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("KuroBpDataAssetGroup")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"KuroBpDataAssetGroup")
	}
	static class UKuroBpDataAssetGroup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroBpDataAssetGroup>();
	}
};
DUMPER7_ASSERTS_UKuroBpDataAssetGroup;

// Class KuroUtility.KuroStateMachineBase
// 0x0070 (0x00A8 - 0x0038)
class UKuroStateMachineBase final : public UPrimaryDataAsset
{
public:
	class FString                                 Name_0;                                            // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FString, class UKuroStateMachineConditionBase*> Transitions;                          // 0x0048(0x0050)(Edit, BlueprintVisible, ExportObject, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UKuroStateMachineBase*>          Children;                                          // 0x0098(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("KuroStateMachineBase")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"KuroStateMachineBase")
	}
	static class UKuroStateMachineBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroStateMachineBase>();
	}
};
DUMPER7_ASSERTS_UKuroStateMachineBase;

// Class KuroUtility.KuroStateMachineGroup
// 0x0010 (0x0048 - 0x0038)
class UKuroStateMachineGroup final : public UDataAsset
{
public:
	TArray<class UKuroStateMachineBase*>          StateMachineList;                                  // 0x0038(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("KuroStateMachineGroup")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"KuroStateMachineGroup")
	}
	static class UKuroStateMachineGroup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroStateMachineGroup>();
	}
};
DUMPER7_ASSERTS_UKuroStateMachineGroup;

// Class KuroUtility.KuroStateMachineConditionBase
// 0x0000 (0x0038 - 0x0038)
class UKuroStateMachineConditionBase : public UPrimaryDataAsset
{
public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("KuroStateMachineConditionBase")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"KuroStateMachineConditionBase")
	}
	static class UKuroStateMachineConditionBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroStateMachineConditionBase>();
	}
};
DUMPER7_ASSERTS_UKuroStateMachineConditionBase;

// Class KuroUtility.KuroStateMachineConditionAnd
// 0x0010 (0x0048 - 0x0038)
class UKuroStateMachineConditionAnd final : public UKuroStateMachineConditionBase
{
public:
	TArray<class UKuroStateMachineConditionBase*> Conditions;                                        // 0x0038(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("KuroStateMachineConditionAnd")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"KuroStateMachineConditionAnd")
	}
	static class UKuroStateMachineConditionAnd* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroStateMachineConditionAnd>();
	}
};
DUMPER7_ASSERTS_UKuroStateMachineConditionAnd;

// Class KuroUtility.KuroStateMachineConditionOr
// 0x0010 (0x0048 - 0x0038)
class UKuroStateMachineConditionOr final : public UKuroStateMachineConditionBase
{
public:
	TArray<class UKuroStateMachineConditionBase*> Conditions;                                        // 0x0038(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("KuroStateMachineConditionOr")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"KuroStateMachineConditionOr")
	}
	static class UKuroStateMachineConditionOr* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroStateMachineConditionOr>();
	}
};
DUMPER7_ASSERTS_UKuroStateMachineConditionOr;

// Class KuroUtility.KuroCollectActorComponent
// 0x0008 (0x00C8 - 0x00C0)
class UKuroCollectActorComponent final : public UActorComponent
{
public:
	ECollectActorType                             CollectActorType;                                  // 0x00C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C1[0x7];                                       // 0x00C1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class AActor* GetActorWithTag(class FName Tag, ECollectActorType Type);

	void AddCollectActorComponentInEditor();
	void RemoveCollectActorComponentInEditor();

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("KuroCollectActorComponent")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"KuroCollectActorComponent")
	}
	static class UKuroCollectActorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroCollectActorComponent>();
	}
};
DUMPER7_ASSERTS_UKuroCollectActorComponent;

// Class KuroUtility.KuroCompressLibrary
// 0x0000 (0x0030 - 0x0030)
class UKuroCompressLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void CompressFileOrFolder(const class FString& Path, const class FString& DestPath, const TDelegate<void(float Rate)>& OnProgress, const TDelegate<void(const TArray<class FString>& SuccessedPaths)>& OnCompressComplete, const TDelegate<void()>& OnFail, int64 MaxSingleFileReadSize);
	static void CompressFilesOrFoldersAsync(const TArray<class FString>& Paths, const class FString& DestPath, const TDelegate<void(float Rate)>& OnProgress, const TDelegate<void(const TArray<class FString>& SuccessedPaths)>& OnCompressComplete, const TDelegate<void()>& OnFail, bool bAutoIncludeFilesUnderFolder, int64 MaxSingleFileReadSize);

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("KuroCompressLibrary")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"KuroCompressLibrary")
	}
	static class UKuroCompressLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroCompressLibrary>();
	}
};
DUMPER7_ASSERTS_UKuroCompressLibrary;

// Class KuroUtility.KuroDemoInteractiveActor
// 0x0000 (0x02B0 - 0x02B0)
class AKuroDemoInteractiveActor final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("KuroDemoInteractiveActor")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"KuroDemoInteractiveActor")
	}
	static class AKuroDemoInteractiveActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKuroDemoInteractiveActor>();
	}
};
DUMPER7_ASSERTS_AKuroDemoInteractiveActor;

// Class KuroUtility.KuroDemoInteractSubSystem
// 0x0070 (0x00A8 - 0x0038)
class UKuroDemoInteractSubSystem final : public UWorldSubsystem
{
public:
	TMulticastInlineDelegate<void(class FName ActorKey)> OnDemoInteractiveActorAdd;                  // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class FName ActorKey)> OnDemoInteractiveActorRemove;               // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMap<class FName, class AActor*>              DemoInteractiveActorMap;                           // 0x0058(0x0050)(NativeAccessSpecifierPrivate)

public:
	class AActor* GetDemoInteractiveActor(class FName ActorKey);

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("KuroDemoInteractSubSystem")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"KuroDemoInteractSubSystem")
	}
	static class UKuroDemoInteractSubSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroDemoInteractSubSystem>();
	}
};
DUMPER7_ASSERTS_UKuroDemoInteractSubSystem;

// Class KuroUtility.KuroEntityActor
// 0x0008 (0x02B8 - 0x02B0)
class AKuroEntityActor final : public AKuroActor
{
public:
	int32                                         EntityId;                                          // 0x02B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B4[0x4];                                      // 0x02B4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("KuroEntityActor")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"KuroEntityActor")
	}
	static class AKuroEntityActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKuroEntityActor>();
	}
};
DUMPER7_ASSERTS_AKuroEntityActor;

// Class KuroUtility.KuroIntEventBinder
// 0x0010 (0x0040 - 0x0030)
class UKuroIntEventBinder final : public UObject
{
public:
	TMulticastInlineDelegate<void(int32 Number)>  Callback;                                          // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("KuroIntEventBinder")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"KuroIntEventBinder")
	}
	static class UKuroIntEventBinder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroIntEventBinder>();
	}
};
DUMPER7_ASSERTS_UKuroIntEventBinder;

// Class KuroUtility.KuroJsStatsLibrary
// 0x0000 (0x0030 - 0x0030)
class UKuroJsStatsLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("KuroJsStatsLibrary")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"KuroJsStatsLibrary")
	}
	static class UKuroJsStatsLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroJsStatsLibrary>();
	}
};
DUMPER7_ASSERTS_UKuroJsStatsLibrary;

// Class KuroUtility.KuroMathLibrary
// 0x0000 (0x0030 - 0x0030)
class UKuroMathLibrary final : public UBlueprintFunctionLibrary
{
public:
	static int64 BitwiseLeftShift(int64 Source, int32 Bit);
	static int64 BitwiseRightShift(int64 Source, int32 Bit);
	static struct FVector2D Max(const struct FVector2D& A, const struct FVector2D& B);
	static struct FVector2D Min(const struct FVector2D& A, const struct FVector2D& B);

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("KuroMathLibrary")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"KuroMathLibrary")
	}
	static class UKuroMathLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroMathLibrary>();
	}
};
DUMPER7_ASSERTS_UKuroMathLibrary;

// Class KuroUtility.KuroMemoryLibrary
// 0x0000 (0x0030 - 0x0030)
class UKuroMemoryLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void PrintUObjectMemoryInfo(class UObject* Object);

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("KuroMemoryLibrary")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"KuroMemoryLibrary")
	}
	static class UKuroMemoryLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroMemoryLibrary>();
	}
};
DUMPER7_ASSERTS_UKuroMemoryLibrary;

// Class KuroUtility.KuroMeshTextureFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UKuroMeshTextureFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool AddMeshesBundleStreamedAllMipsDelegate(const TDelegate<void(const TArray<class USkeletalMesh*>& SkeletalMeshes, const TArray<class UStaticMesh*>& StaticMeshes)>& InDelegate);
	static bool AddSkeletalStreamedAllMipsDelegate(const TDelegate<void(class USkeletalMesh* SkeletalMesh)>& InDelegate);
	static bool AddStaticMeshStreamedAllMipsDelegate(const TDelegate<void(class UStaticMesh* StaticMesh)>& InDelegate);
	static int32 ForceMeshesBundleStreamingInAllMips(const TArray<class USkeletalMesh*>& MeshBundleSkeletalMeshes, const TArray<class UStaticMesh*>& MeshBundleStaticMeshes, const TDelegate<void(const TArray<class USkeletalMesh*>& SkeletalMeshes, const TArray<class UStaticMesh*>& StaticMeshes)>& InDelegate);
	static void HandleMeshesComponentsBundleStreaming(const TArray<class USkeletalMesh*>& MeshBundleSkeletalMeshes, const TArray<class UStaticMesh*>& MeshBundleStaticMeshes, const bool bStartForceStreamIn);
	static void HandleSkeletalMeshComponentStreaming(class USkeletalMesh* skeletalMesh, const bool bStartForceStreamIn);
	static void HandleStaticMeshComponentStreaming(class UStaticMesh* staticMesh, const bool bStartForceStreamIn);
	static bool IsSkeletalMeshComponentStreamingComplete(class USkeletalMesh* skeletalMesh);
	static bool IsStaticMeshComponentStreamingComplete(class UStaticMesh* staticMesh);
	static bool StopMeshesBundleStreamingInAllMips(const int32 UniqueInstanceID);
	static bool UnbindMeshesBundleStreamedAllMipsDelegate();
	static bool UnbindSkeletalStreamedAllMipsDelegate();
	static bool UnbindStaticMeshStreamedAllMipsDelegate();

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("KuroMeshTextureFunctionLibrary")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"KuroMeshTextureFunctionLibrary")
	}
	static class UKuroMeshTextureFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroMeshTextureFunctionLibrary>();
	}
};
DUMPER7_ASSERTS_UKuroMeshTextureFunctionLibrary;

// Class KuroUtility.KuroPerceptionEventBinder
// 0x0010 (0x0040 - 0x0030)
class UKuroPerceptionEventBinder final : public UObject
{
public:
	TMulticastInlineDelegate<void(const TArray<class AActor*>& AddActor, const TArray<class AActor*>& RemoveActor, const TArray<int32>& RemoveActorIds, int32 Num)> Callback; // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("KuroPerceptionEventBinder")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"KuroPerceptionEventBinder")
	}
	static class UKuroPerceptionEventBinder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroPerceptionEventBinder>();
	}
};
DUMPER7_ASSERTS_UKuroPerceptionEventBinder;

// Class KuroUtility.KuroPhysicsLibrary
// 0x0000 (0x0030 - 0x0030)
class UKuroPhysicsLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool GetHitPoint(const struct FVectorDouble& StartLocation, const struct FVectorDouble& EndLocation, class AActor* Actor, class UPrimitiveComponent* TraceComp, class UKuroHitResult* HitResult, float DrawDuration, bool ForceTrace);
	static bool GetSphereHitPoint(const struct FVectorDouble& StartLocation, const struct FVectorDouble& EndLocation, class AActor* Actor, class UPrimitiveComponent* TraceComp, float Radius, class UKuroHitResult* HitResult, float DrawDuration, bool ForceTrace);

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("KuroPhysicsLibrary")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"KuroPhysicsLibrary")
	}
	static class UKuroPhysicsLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroPhysicsLibrary>();
	}
};
DUMPER7_ASSERTS_UKuroPhysicsLibrary;

// Class KuroUtility.KuroPolypartition
// 0x0000 (0x0030 - 0x0030)
class UKuroPolypartition final : public UBlueprintFunctionLibrary
{
public:
	static TArray<int32> BuildTriangleByVertex2D(const TArray<struct FVector2D>& points);

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("KuroPolypartition")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"KuroPolypartition")
	}
	static class UKuroPolypartition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroPolypartition>();
	}
};
DUMPER7_ASSERTS_UKuroPolypartition;

// Class KuroUtility.KuroSilenceGameMode
// 0x0008 (0x03A8 - 0x03A0)
class AKuroSilenceGameMode final : public AGameMode
{
public:
	uint8                                         Pad_3A0[0x8];                                      // 0x03A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GameInitialized();

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("KuroSilenceGameMode")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"KuroSilenceGameMode")
	}
	static class AKuroSilenceGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKuroSilenceGameMode>();
	}
};
DUMPER7_ASSERTS_AKuroSilenceGameMode;

// Class KuroUtility.KuroStaticAndroidLibrary
// 0x0000 (0x0030 - 0x0030)
class UKuroStaticAndroidLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void AddAndroidScreenChangeDelegate(const TDelegate<void()>& Handler);
	static void ClearAndroidScreenChangeDelegate();
	static class FString GetCustomChannel();
	static bool GetDeviceIsEmulator();
	static bool GetDeviceIsRooted();
	static class FString GetHarmonyOSVersion();
	static bool IsHarmonyOS();
	static void OpenAppWithUrl(const class FString& schema, const class FString& failSchema);

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("KuroStaticAndroidLibrary")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"KuroStaticAndroidLibrary")
	}
	static class UKuroStaticAndroidLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroStaticAndroidLibrary>();
	}
};
DUMPER7_ASSERTS_UKuroStaticAndroidLibrary;

// Class KuroUtility.KuroStaticiOSLibrary
// 0x0000 (0x0030 - 0x0030)
class UKuroStaticiOSLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool GetDeviceJailbroken();
	static void OpenAppWithUrl(const class FString& url, const class FString& failUrl);

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("KuroStaticiOSLibrary")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"KuroStaticiOSLibrary")
	}
	static class UKuroStaticiOSLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroStaticiOSLibrary>();
	}
};
DUMPER7_ASSERTS_UKuroStaticiOSLibrary;

// Class KuroUtility.KuroStaticLibrary
// 0x0000 (0x0030 - 0x0030)
class UKuroStaticLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void AddToRoot(class UObject* InObject);
	static void ApplyChangeToBlueprint(class AActor* Actor);
	static struct FArrayBuffer ArrayToBuffer(TArray<uint8>* InArray);
	static class FString Base64Decode(const class FString& inString);
	static class FString Base64Encode(const class FString& inString);
	static class FString Base64EncodeBinary(const struct FArrayBuffer& InBuffer);
	static class FString Base64EncodeWithConvertToUTF8(const class FString& inString);
	static class FString Base64EncodeWithSpecifyChar(const TArray<uint8>& ByteArray, const class FString& SpecifyChar);
	static class FString Base64EncodeWithSpecifyCharWithConvertToUTF8(const class FString& inString, const class FString& SpecifyChar);
	static void BindCustomGetTimeBetweenGarbageCollectionPassesDelegate(const TDelegate<void(float MBFree, float ExtraDevelopmentMemorySize, int32 NumObjects)>& Delegate);
	static void BindDeviceLangChangeDelegate(const TDelegate<void()>& Delegate);
	static void ClearCustomGetTimeBetweenGarbageCollectionPassesDelegate();
	static void ClearPlayerInputCache(class APlayerController** PC);
	static EObjectTypeQuery ConvertToObjectType(const ECollisionChannel InCollisionChannel);
	static ETraceTypeQuery ConvertToTraceType(const ECollisionChannel InCollisionChannel);
	static bool CopyFile(const class FString& SourcePath, const class FString& DstPath);
	static struct FVectorDouble D_GetFirstLocationFromSeqTrack(class UMovieScene3DTransformTrack* TransformTrack);
	static bool DeleteFile(const class FString& Path, const bool bRequireExists, const bool bEvenReadOnly, const bool bQuiet);
	static bool DeleteFolder(const class FString& Path, const bool bRequireExists, const bool bTree);
	static void DestroyObject(class UObject* Object);
	static bool DirectoryExists(const class FString& Path);
	static void DoGameViewPortMouseEnter(class UGameViewportClient* InViewport, int32 x, int32 y);
	static void DumpStackTrace(const class FString& Str);
	static bool EncompassesPoint(class AVolume* Volume, const struct FVector& Point, float SphereRadius);
	static bool ExecProcess(const class FString& URL, const class FString& Params_0, int32* ReturnCode, class FString* OutStd, class FString* OutErr);
	static bool ExecuteFunctionByName(class UObject* Object, const class FString& FunctionName, class FString* Result);
	static void ExitGame(bool force);
	static bool FileExists(const class FString& Path);
	static TArray<class FString> FindFilesSorted(const class FString& Path, const class FString& Extension);
	static void ForceGarbageCollection(bool bFullPurge);
	static struct FDateTime FromUnixTimestamp(const int32 Timestamp);
	static class AActor* GetActorOfClassOnLevelInstance(const TSubclassOf<class AActor> ActorClass, const class ALevelInstance* LevelInstance);
	static TArray<class AActor*> GetActorsOnLevelInstance(const class ALevelInstance* LevelInstance);
	static void GetAnimAssets(const class UAnimBlueprint* InAnimBlueprint, TSet<class UAnimationAsset*>* OutAnimationAssets);
	static void GetAnimAssetsByAnimBlueprintClass(const TSubclassOf<class UAnimInstance>& InAnimClass, TSet<class UAnimationAsset*>* OutAnimationAssets);
	static void GetAnimAssetsByAnimInstance(const class UAnimInstance* InAnimInstance, TSet<class UAnimationAsset*>* OutAnimationAssets);
	static void GetAnimMontageNotifies(const class UAnimMontage* AnimMontage, TArray<struct FAnimNotifyEvent>* OutNotifies);
	static void GetAnimSequenceNotifies(const class UAnimSequenceBase* AnimSequence, TArray<struct FAnimNotifyEvent>* OutNotifies);
	static void GetAnimSequencesByAnimMontage(const class UAnimMontage* AnimMontage, TArray<class UAnimSequenceBase*>* OutAnimSequences);
	static class FString GetBaseBoardInfo();
	static int32 GetBatteryLevel();
	static class FString GetBlueprintCallstack();
	static bool GetCameraShakeInfo(TSubclassOf<class UCameraShakeBase> CameraShakeClass, struct FCameraShakeInfo* OutInfo);
	static void GetCharacterAnimClass(const TSubclassOf<class AActor>& InActorClass, TSubclassOf<class UAnimInstance>* OutAnimClass);
	static void GetCreatureGenDirectoryByMap(const class FString& Path, const int32 MapID, bool* Exist, class FString* Directory);
	static class FString GetCultureRegion();
	static float GetCurCPUFrequency();
	static class UObject* GetDefaultObject(class UClass* Class_0);
	static class FString GetDeviceCPU();
	static TArray<class FString> GetDirectories(const class FString& Path);
	static class FString GetDiskSerialNo();
	static bool GetEnableMobileLowStreaming(class ULevelSequence* Sequence);
	static class FString GetFileAccessTime(const class FString& Path);
	static class FString GetFileCreationTime(const class FString& Path);
	static class FString GetFileModificationTime(const class FString& Path);
	static TArray<class FString> GetFiles(const class FString& Path, const class FString& Extension);
	static TArray<class FString> GetFilesRecursive(const class FString& Path, const class FString& Filter, bool Files, bool Directories);
	static struct FVector GetFirstLocationFromSeqTrack(class UMovieScene3DTransformTrack* TransformTrack);
	static class UGameViewportClient* GetGameViewPort();
	static class FString GetGPUInfo();
	static class FString GetLevelPath(const class UObject* WorldContextObject);
	static class AActor* GetLevelPrefabShowActor(class AActor* Actor);
	static bool GetLocalAdapterAddressesUint32(TArray<int32>* OutAddresses);
	static void GetLocalHostAddresses(TArray<class FString>* OutAddresses, const bool bAppendPort);
	static class FString GetMacAddress();
	static TArray<struct FVector> GetNavPointData(class UObject* WorldContextObject, int32 XNumber, int32 YNumber, int32 Dis, class ANavigationData* NavData, const struct FVector& Point, const struct FVector& QueryExtent, TSubclassOf<class UNavigationQueryFilter> FilterClass);
	static class FString GetOSVersion();
	static float GetPIEStartTimeInSeconds();
	static float GetPlatformTimeInSeconds();
	static class FString GetProcessorId();
	static TArray<class UMovieSceneTrack*> GetSequenceTracksForObjectBindingID(const class ALevelSequenceActor* Actor, class FName TagName);
	static struct FVector2D GetSlateApplicationCursorPos();
	static void GetSlotNamesByAnimMontage(const class UAnimMontage* AnimMontage, TArray<class FName>* OutSlotNames);
	static struct FRotator GetSplineRotationAtSplinePoint(class USplineComponent* Spline, int32 PointIndex, ESplineCoordinateSpace CoordinateSpace);
	static class FString GetStatUnitInfo();
	static class FString GetSysUUID();
	static int64 GetTotalPhysicalMemory();
	static class UMovieSceneTrack* GetTrackByClass(const TArray<class UMovieSceneTrack*>& Tracks, TSubclassOf<class UMovieSceneTrack> Class_0);
	static class FString GetVendorInfo();
	static int32 GetVideoMemoryGB();
	static struct FVector2D GetViewPortMousePosition();
	static bool GetViewPortMousePosition2(struct FVector2D* MousePos);
	static class FString GetWholeStatUnitInfo(float Timespan);
	static class FString HashStringWithSHA1(const class FString& inString);
	static void IcmpPing(const class FString& IpAddress, float Timeout, const TDelegate<void(const class FString& Address, float Time, int32 responseState)>& InDelegate);
	static bool IsEditor(const class UObject* WorldContextObject);
	static bool IsForegroundWindow();
	static bool IsImplementInterface(class UClass* InClass, class UClass* InInterfaceClass);
	static bool IsLowMemoryDevice();
	static bool IsModuleLoaded(const class FString& ModelName);
	static bool IsMontageContainGivenAnimNotify(const class UAnimMontage* AnimMontage, const TSet<class FString>& CheckClassNames);
	static bool IsObjectClassByName(class UObject* Object, class FName ClassName);
	static bool IsViewportFocus();
	static bool IsWithEditor();
	static bool IsWorldTearingDown(const class UWorld* World);
	static bool KuroEnableCustomAffinity();
	static class FString KuroFormatText(const class FString& Format, const TArray<class FString>& Parameters);
	static TArray<class FString> LoadFilesRecursive(const class FString& Path, const class FString& Filter, bool Files, bool Directories);
	static bool LoadFileToArray(const class FString& Path, TArray<uint8>* OutArray);
	static bool LoadFileToString(class FString* Result, const class FString& Filename);
	static TArray<class FString> LoadFileToStringArray(const class FString& FileRevisionPath);
	static bool MakeDirectory(const class FString& Path, const bool bTree);
	static class FString Md5HashAnsiString(const class FString& inString);
	static class FString Md5HashUTF8String(const class FString& inString);
	static void PerceptionConfigureSense(class UAIPerceptionComponent* AIPerception, class UAISenseConfig* AISenseConfig);
	static void RegisterCustomCommandProcessor(const class FString& Category, const TDelegate<void(const class FString& Command)>& Processor);
	static void RemoveFromRoot(class UObject* InObject);
	static void ResetHttpMaxFlushTimeSeconds();
	static bool SaveBufferToFile(const class FString& Path, const struct FArrayBuffer& InBuffer);
	static bool SaveStringToFile(const class FString& SaveText, const class FString& FileName, const bool bWithBom);
	static void SetActorModify(class AActor* Actor);
	static void SetActorPermanent(class AActor* Actor, const bool bIsPermanent, const bool bWithAllChildren);
	static void SetBaseAndSaveBaseLocation(class UCharacterMovementComponent* CharacterMovementComp, class UPrimitiveComponent* NewBase);
	static void SetConsoleVariableWithCurrentPriority_Float(const class FString& InCVar, float InValue);
	static void SetConsoleVariableWithCurrentPriority_Int(const class FString& InCVar, int32 InValue);
	static void SetConsoleVariableWithCurrentPriority_String(const class FString& InCVar, const class FString& InValue);
	static void SetCursorVisibility(bool visible);
	static void SetEditorWidgetSkipTick(bool bSkipTick);
	static void SetGameThreadAffinity(bool bIsInFighting);
	static void SetHangAssertFlag(bool bAssertFlag);
	static void SetHangDuration(float HangDuration);
	static void SetHttpThreadActiveMinimumSleepTimeInSeconds(float InHttpThreadActiveMinimumSleepTimeInSeconds);
	static void SetHttpThreadIdleMinimumSleepTimeInSeconds(float InHttpThreadIdleMinimumSleepTimeInSeconds);
	static void SetInputKeyDeadZone(class UObject* world, int32 playerIndex, const struct FKey& key, const float deadZone);
	static void SetMontageANIndex(const class UAnimMontage* AnimMontage);
	static void SetSplinePointsWithType(class USplineComponent* Spline, const TArray<struct FVector>& Points, ESplineCoordinateSpace CoordinateSpace, ESplinePointType Type, bool bUpdateSpline);
	static void SetStaticMeshVelocity(const TArray<class AActor*>& Actors, const struct FVector& NewVelocity);
	static void SetThreadAffinity(const class FString& ThreadName, int32 AffinityHigh, int32 AffinityLow);
	static void SetThreadPolicy(const class FString& ThreadName, int32 Policy);
	static void SetThreadPriority(const class FString& ThreadName, int32 Priority);
	static void SetThreadPriorityAndPolicy(const class FString& ThreadName, int32 Priority, int32 Policy);
	static void SetThreadPriorityAndPolicyAndAffinity(const class FString& ThreadName, int32 Priority, int32 Policy, int32 AffinityHigh, int32 AffinityLow);
	static void ShowSoftwareCursor(bool visible);
	static class AActor* SpawnActorFromAnother(class AActor* Actor, class AActor* Parent);
	static void StopAllMontagesBySlotName(class UAnimInstance* UAnimInstance, const class FName InSlotName, const float InBlendOutTime);
	static void SynchronizeProperties(class UWidget* InWidget);
	static bool ToggleSequenceNodeActiveByTag(const class ALevelSequenceActor* Actor, class FName TagName, bool bActive);
	static int32 ToUnixTimestamp(const struct FDateTime& InDataTime);
	static void UnBindDeviceLangChangeDelegate();
	static void UnRegisterCustomCommandProcessor(const class FString& Category);
	static bool WriteStringToFile(const class FString& SaveText, const class FString& FileName, const bool bPublic, const bool bWithBom);

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("KuroStaticLibrary")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"KuroStaticLibrary")
	}
	static class UKuroStaticLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroStaticLibrary>();
	}
};
DUMPER7_ASSERTS_UKuroStaticLibrary;

// Class KuroUtility.KuroFFXFSR3BlueprintLibrary
// 0x0000 (0x0030 - 0x0030)
class UKuroFFXFSR3BlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void DumpAMDGPUInfos();
	static bool IsDeviceAMD();
	static bool IsGlobalSwitchOn();
	static bool IsSupported();
	static bool SupportFI();
	static bool SupportFSR3();

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("KuroFFXFSR3BlueprintLibrary")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"KuroFFXFSR3BlueprintLibrary")
	}
	static class UKuroFFXFSR3BlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroFFXFSR3BlueprintLibrary>();
	}
};
DUMPER7_ASSERTS_UKuroFFXFSR3BlueprintLibrary;

// Class KuroUtility.KuroStaticPS5Library
// 0x0000 (0x0030 - 0x0030)
class UKuroStaticPS5Library final : public UBlueprintFunctionLibrary
{
public:
	static void AbortTrophyHandleAsync(int32* handle, const TDelegate<void(int32 ret)>& callback);
	static int32 AbortUdsHandle(int32 handle);
	static void AddCacheMapElement(const class FString& key, const class FString& value);
	static void AddJoinSessionDelegate(const TDelegate<void(const class FString& userId, const class FString& playerSessionId)>& InDelegate);
	static class FString CheckJoinSession();
	static int32 CheckUserPremium(class FString* userId);
	static void ClearJoinSessionDelegate();
	static void ClearJoinSessionHandle();
	static int32 CloseWebBrowser();
	static class FString CreatePlayerSession(int32 joinableUserType, class FString* playerId);
	static void CreateTrophyContextAsync(const class FString& userId, int32 serviceLabel, const class FString& optionsLong, const TDelegate<void(int32 ret, int32 result)>& callback);
	static void CreateTrophyHandleAsync(const TDelegate<void(int32 ret, int32 result)>& callback);
	static int32 CreateUdsContext(class FString* userId, int32* context);
	static int32 CreateUdsEvent(class FString* eventName, int64* outEventPtr, int64* outProPtr);
	static int32 CreateUdsHandle(int32* handle);
	static void DestroyTrophyContextAsync(int32* context, const TDelegate<void(int32 ret)>& callback);
	static void DestroyTrophyHandleAsync(int32* handle, const TDelegate<void(int32 ret)>& callback);
	static int32 DestroyUdsContext(int32 context);
	static int32 DestroyUdsEvent(int64 eventPtr);
	static int32 DestroyUdsHandle(int32 handle);
	static class FString GetAccountIdByUserId(class FString* userId);
	static int32 GetAuthCode(class FString* ClientId, class FString* Scope, class FString* AuthCode, int32* IssuerId);
	static TArray<struct FBasicPresenceData> GetBasicPresence(class FString* accountId);
	static struct FBlockUserData GetBlockUserList(int32* offset, int32* limit);
	static void GetBlockUserListAsync(int32* offset, int32* limit, const TDelegate<void(const struct FBlockUserData& data)>& Delegate);
	static class FString GetCacheMapElement(const class FString& key);
	static void GetCommunicationRestrictionStatusAsync(class FString* accountId, const TDelegate<void(int32 ret, int32 status)>& callback);
	static class FString GetCountryCodeByUserId(class FString* userId);
	static int32 GetIdToken(class FString* ClientId, class FString* ClientSecret, class FString* Scope, class FString* IdToken);
	static void GetMessageDialogStateAsync(const TDelegate<void(int32 ret)>& callback);
	static class FString GetOnlineIdByUserId(class FString* userId);
	static class FString GetPlayerIdByPlayerSessionId(class FString* playerSessionId);
	static TArray<struct FProductData> GetStoreProducts();
	static struct FTrophyInfoData GetTrophyList(class FString* userId, int32* inputOffset, int32 length);
	static struct FTrophyInfoData GetTrophyListWithContextIdAndHandleId(int32 context, int32 handle, int32* inputOffset, int32 length);
	static void GetTrophyListWithContextIdAndHandleIdAsync(int32* inputOffset, int32 length, int32 context, int32 handle, const TDelegate<void(const struct FTrophyInfoData& data)>& callback);
	static class FString GetUserId();
	static class FString GetUserIdByAccountId(class FString* accountId);
	static int32 HidePsStoreIcon();
	static int32 InitNpUniversalDataSystem(int32 poolSize);
	static int32 InitWebApi(class FString* userId);
	static void JoinPlayerSession(class FString* playerSessionId);
	static void LeavePlayerSession();
	static void NotifyPremium(class FString* userId);
	static void NotifyPremiumFeature(class FString* userId, bool isPlayStationOnly);
	static int32 OpenCheckoutDialog(class FString* ProductLabel);
	static void OpenMessageDialog(class FString* userId, int32 openMode, int32 msgType, const TDelegate<void(int32 ret)>& callback);
	static void OpenWebBrowser(class FString* Url);
	static int32 OpenWebView(class FString* Url);
	static int32 PollCheckoutDialogResult();
	static bool PollWebBrowser();
	static int32 PostUdsEvent(int32 context, int32 handle, int64 eventPtr);
	static void RegisterTrophyContextAsync(int32* context, int32* handle, const class FString& optionsLong, const TDelegate<void(int32 ret)>& callback);
	static int32 RegisterUdsContext(int32 context, int32 handle);
	static void RemoveCacheElement(const class FString& key);
	static int32 SceNpGetNpReachabilityState(class FString* userId, int32* outState);
	static void SetPlayerSessionJoinableUserType(int32 joinableUserType);
	static int32 ShowPsStoreIcon(int32 position);
	static void TerminateMessageDialog();
	static int32 TerminateWebBrowser();
	static int32 UdsEventPropertyArraySetString(int64 proPtr, class FString* key, TArray<class FString>* value);
	static int32 UdsEventPropertyObjectSetBool(int64 proPtr, class FString* key, bool value);
	static int32 UdsEventPropertyObjectSetFloat32(int64 proPtr, class FString* key, float value);
	static int32 UdsEventPropertyObjectSetFloat64(int64 proPtr, class FString* key, double value);
	static int32 UdsEventPropertyObjectSetInt32(int64 proPtr, class FString* key, int32 value);
	static int32 UdsEventPropertyObjectSetInt64(int64 proPtr, class FString* key, int64 value);
	static int32 UdsEventPropertyObjectSetString(int64 proPtr, class FString* key, class FString* value);
	static int32 UdsEventPropertyObjectSetUInt32(int64 proPtr, class FString* key, int32 value);
	static int32 UdsEventPropertyObjectSetUInt64(int64 proPtr, class FString* key, int64 value);
	static int32 UnlockTrophy(class FString* userId, int32 trophyId);
	static int32 UnlockTrophyWithContextIdAndHandleId(int32 contextId, int32 handle, int32 trophyId);
	static void UnlockTrophyWithContextIdAndHandleIdAsync(int32 contextId, int32 handle, int32 trophyId, const TDelegate<void(int32 ret)>& callback);
	static int32 UpdateTrophyProgress(class FString* userId, int32 trophyId, int32 progress);
	static int32 UpdateTrophyProgressWithContextIdAndHandleId(int32 context, int32 handle, int32 trophyId, int32 progress);
	static void UpdateTrophyProgressWithContextIdAndHandleIdAsync(int32 context, int32 handle, int32 trophyId, int32 progress, const TDelegate<void(int32 ret)>& callback);

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("KuroStaticPS5Library")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"KuroStaticPS5Library")
	}
	static class UKuroStaticPS5Library* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroStaticPS5Library>();
	}
};
DUMPER7_ASSERTS_UKuroStaticPS5Library;

// Class KuroUtility.KuroSubLevelVisibleSubsystem
// 0x0088 (0x00C0 - 0x0038)
class UKuroSubLevelVisibleSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x88];                                      // 0x0038(0x0088)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UKuroSubLevelVisibleSubsystem* GetSubSystem(const class UGameInstance* GameInstance);

	void AddLevel(int32 LinkId, class ULevel* Level);
	void RemoveLevel(int32 LinkId);
	bool SetLevelActorsVisible(const int32 LinkId, const bool Visible, const TDelegate<void(const int32 LinkId)> FinishCallback);
	void SetOneFrameExecuteCount(const int32 Count);

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("KuroSubLevelVisibleSubsystem")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"KuroSubLevelVisibleSubsystem")
	}
	static class UKuroSubLevelVisibleSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroSubLevelVisibleSubsystem>();
	}
};
DUMPER7_ASSERTS_UKuroSubLevelVisibleSubsystem;

// Class KuroUtility.KuroTencentCOSLibrary
// 0x0000 (0x0030 - 0x0030)
class UKuroTencentCOSLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void ClearAllProgressCallback();
	static void EnableAuthorization(bool Enable);
	static void EnableAutoSendWhenExit();
	static int32 GetAllFileNumNeedToSend();
	static int32 GetSendedFileNum();
	static void InterruptSending();
	static bool IsSending();
	static void SendFileToTencentCOS(const class FString& Path, const class FString& RemoteURI, const class FString& SecretID, const class FString& SecretKey, const class FString& BucketName, const class FString& Region);
	static void SendLogToTencentCOS(const TDelegate<void(int32 State, float Rate)>& OnProgress);
	static void SetAdmissibleValue(int32 SingleLogSizeInMb);
	static void SetFilesToSend(const TArray<class FString>& FilePaths);
	static void SetHandleFunc(const TDelegate<void(const TArray<class FString>& FileNames)>& PrepareFunc, const TDelegate<void(const TArray<class FString>& SendedFiles)>& PostSend);
	static void SetIsAutoSend(bool bIsAutoSend);
	static void SetSendLogConfig(const class FString& SecretID, const class FString& SecretKey, const class FString& BucketName, const class FString& Region);
	static void SetSendLogZipName(const class FString& ZipFileName);

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("KuroTencentCOSLibrary")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"KuroTencentCOSLibrary")
	}
	static class UKuroTencentCOSLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroTencentCOSLibrary>();
	}
};
DUMPER7_ASSERTS_UKuroTencentCOSLibrary;

// Class KuroUtility.KuroTickableManager
// 0x0018 (0x0048 - 0x0030)
class UKuroTickableManager final : public UObject
{
public:
	uint8                                         Pad_30[0x18];                                      // 0x0030(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CreateTickableFunc(class UObject* InOwner, TDelegate<void(float DeltaSeconds)> TickableHandler);
	void RemoveTickableFunc(class UObject* InOwner);

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("KuroTickableManager")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"KuroTickableManager")
	}
	static class UKuroTickableManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroTickableManager>();
	}
};
DUMPER7_ASSERTS_UKuroTickableManager;

// Class KuroUtility.KuroTriggerVolume
// 0x0010 (0x02F8 - 0x02E8)
class AKuroTriggerVolume final : public AVolume
{
public:
	class FName                                   VolumeId;                                          // 0x02E8(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2F4[0x4];                                      // 0x02F4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("KuroTriggerVolume")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"KuroTriggerVolume")
	}
	static class AKuroTriggerVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKuroTriggerVolume>();
	}
};
DUMPER7_ASSERTS_AKuroTriggerVolume;

// Class KuroUtility.KuroTriggerVolumeManager
// 0x0070 (0x00A8 - 0x0038)
class UKuroTriggerVolumeManager final : public UWorldSubsystem
{
public:
	TMulticastInlineDelegate<void(class FName ActorKey)> OnTriggerVolumeAddToSubsystem;              // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class FName ActorKey)> OnTriggerVolumeRemoveFromSubsystem;         // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMap<class FName, class AActor*>              KuroTriggerVolumeMap;                              // 0x0058(0x0050)(NativeAccessSpecifierPrivate)

public:
	class AActor* GetKuroTriggerVolume(class FName ActorKey);

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("KuroTriggerVolumeManager")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"KuroTriggerVolumeManager")
	}
	static class UKuroTriggerVolumeManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroTriggerVolumeManager>();
	}
};
DUMPER7_ASSERTS_UKuroTriggerVolumeManager;

// Class KuroUtility.KuroWaterVolume
// 0x0000 (0x02E8 - 0x02E8)
class AKuroWaterVolume final : public AVolume
{
public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("KuroWaterVolume")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"KuroWaterVolume")
	}
	static class AKuroWaterVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKuroWaterVolume>();
	}
};
DUMPER7_ASSERTS_AKuroWaterVolume;

// Class KuroUtility.LoadMapNotify
// 0x0158 (0x0188 - 0x0030)
class ULoadMapNotify final : public UObject
{
public:
	uint8                                         Pad_30[0x158];                                     // 0x0030(0x0158)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BindBeginLoadMap(TDelegate<void(const class FString& MapName)> BeginLoadMapHandler);
	void BindBeginTravelLoadMap(TDelegate<void(const class FString& MapName)> BeginTravelLoadMapHandler);
	void BindEndLoadMap(TDelegate<void(const class FString& MapName)> EndLoadMapHandler);
	void BindEndLoadTransitionMap(TDelegate<void()> EndLoadTransitionMapHandler);
	void BindLoadStreamLevel(const TDelegate<void(const int32 LinkId, const class FName& LevelName, const class ULevelStreaming* StreamingLevel)> LoadStreamLevelHandler);
	void BindUnLoadStreamLevel(const TDelegate<void(const int32 LinkId, const class FName& LevelName)> UnLoadStreamLevelHandler);
	void Clear();
	int32 LoadStreamLevel(const class FName& Path, bool bMakeVisibleAfterLoad, bool bShouldBlockOnLoad);
	void OnLoadStreamLevel(const int32 LinkID);
	void OnUnLoadStreamLevel(const int32 LinkID);
	int32 UnloadStreamLevel(const class FName& Path, bool bShouldBlockOnLoad);

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("LoadMapNotify")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"LoadMapNotify")
	}
	static class ULoadMapNotify* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoadMapNotify>();
	}
};
DUMPER7_ASSERTS_ULoadMapNotify;

// Class KuroUtility.KuroTickManager
// 0x0080 (0x00B0 - 0x0030)
class UKuroTickManager final : public UObject
{
public:
	uint8                                         Pad_30[0x80];                                      // 0x0030(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddPrerequisiteActor(const ETickingGroup TickingGroup, class AActor* Actor, int32 Priority);
	void AddPrerequisiteActorComponent(const ETickingGroup TickingGroup, class UActorComponent* ActorComp, int32 Priority);
	bool AddTick(const ETickingGroup TickingGroup, const TDelegate<void(float DeltaSeconds)> TickHandler, int32 Priority);
	void CleanCharacterMovementProxyTickFunction(class UCharacterMovementComponent* MoveComp);
	void CleanSkeletalMeshProxyTickFunction(class USkeletalMeshComponent* SkeletalComp);
	void ClearTick();
	void RemovePrerequisiteActor(const ETickingGroup TickingGroup, class AActor* Actor, int32 Priority);
	void RemovePrerequisiteActorComponent(const ETickingGroup TickingGroup, class UActorComponent* ActorComp, int32 Priority);
	bool RemoveTick(const ETickingGroup TickingGroup);
	void SetCharacterMovementProxyTickFunction(const ETickingGroup TickingGroup, class UCharacterMovementComponent* MoveComp, int32 Priority);
	void SetGamePrerequisiteTickFunction(const ETickingGroup TickingGroup, int32 Priority);
	void SetSkeletalMeshComponentPrerequisite(const ETickingGroup TickingGroup, int32 Priority, class USkeletalMeshComponent* SkeletalComp);
	void SetSkeletalMeshProxyTickFunction(const ETickingGroup TickingGroup, class USkeletalMeshComponent* SkeletalComp, int32 Priority);
	void SetTickFunctionCompletionCallbackInMainThread(const ETickingGroup TickingGroup, int32 Priority);

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("KuroTickManager")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"KuroTickManager")
	}
	static class UKuroTickManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroTickManager>();
	}
};
DUMPER7_ASSERTS_UKuroTickManager;

}


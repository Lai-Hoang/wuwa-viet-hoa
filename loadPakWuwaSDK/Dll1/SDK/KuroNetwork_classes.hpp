#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: KuroNetwork

#include "Basic.hpp"

#include "Engine_classes.hpp"
#include "KuroNetwork_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "JsEnv_structs.hpp"


namespace SDK
{

// Class KuroNetwork.KuroDNS
// 0x0000 (0x0030 - 0x0030)
class UKuroDNS final : public UBlueprintFunctionLibrary
{
public:
	static void DNSResolution(const class FString& DomainName, const class FName& Protocol, TDelegate<void(int32 ErrorCode, const TArray<class FString>& IpList)> Callback);

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("KuroDNS")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"KuroDNS")
	}
	static class UKuroDNS* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroDNS>();
	}
};
DUMPER7_ASSERTS_UKuroDNS;

// Class KuroNetwork.KuroHttp
// 0x0000 (0x0030 - 0x0030)
class UKuroHttp final : public UBlueprintFunctionLibrary
{
public:
	static void Get(const class FString& URL, const TMap<class FString, class FString>& HeaderParam, TDelegate<void(bool bConnectedSuccessfully, int32 HttpResponseCode, const class FString& Data)> Handle, float InTimeoutSecs);
	static TMap<class FString, class FString> GetDefaultHeader();
	static void Post(const class FString& URL, const TMap<class FString, class FString>& HeaderParam, const class FString& Content, TDelegate<void(bool bConnectedSuccessfully, int32 HttpResponseCode, const class FString& Data)> Handle, float InTimeoutSecs);
	static void PostAli(const TMap<class FString, class FString>& QueryParameter, TDelegate<void(bool bConnectedSuccessfully, int32 HttpResponseCode, const class FString& Data)> Handle, float InTimeoutSecs);
	static void PostRpt(const class FString& ContentStr, bool IsGlobal, TDelegate<void(const class FString& Data, int32 LocalErrorCode, int32 RemoteErrorCode, int32 HttpResponseCode, bool bConnectedSuccessfully)> Handle, float InTimeoutSecs);
	static void PostRpt1(const class FString& ContentStr, const class FString& Content1Str, bool IsGlobal, TDelegate<void(const class FString& Data, int32 LocalErrorCode, int32 RemoteErrorCode, int32 HttpResponseCode, bool bConnectedSuccessfully)> Handle, float InTimeoutSecs);
	static void PostRpt2(const class FString& Url, const class FString& ContentStr, const class FString& Content1Str, TDelegate<void(const class FString& Data, int32 LocalErrorCode, int32 RemoteErrorCode, int32 HttpResponseCode, bool bConnectedSuccessfully)> Handle, float InTimeoutSecs);

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("KuroHttp")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"KuroHttp")
	}
	static class UKuroHttp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroHttp>();
	}
};
DUMPER7_ASSERTS_UKuroHttp;

// Class KuroNetwork.KuroHttpServerRequestProxy
// 0x00C0 (0x00F0 - 0x0030)
class UKuroHttpServerRequestProxy final : public UObject
{
public:
	uint8                                         Pad_30[0xC0];                                      // 0x0030(0x00C0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool GetHeader(const class FString& Key, TArray<class FString>* OutHeader);
	class FString GetRequest();
	void Response(const class FString& Json, const bool bSuccess);

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("KuroHttpServerRequestProxy")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"KuroHttpServerRequestProxy")
	}
	static class UKuroHttpServerRequestProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroHttpServerRequestProxy>();
	}
};
DUMPER7_ASSERTS_UKuroHttpServerRequestProxy;

// Class KuroNetwork.KuroHttpServerRouterProxy
// 0x0088 (0x00B8 - 0x0030)
class UKuroHttpServerRouterProxy final : public UObject
{
public:
	TDelegate<void(const class FString& ModuleName, const class UKuroHttpServerRequestProxy* RequestProxy)> HttpRequestDelegate; // 0x0030(0x0028)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_58[0x60];                                      // 0x0058(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BindRoute(const class FString& ModuleName);
	void CreateRouter(const int32 Port);
	void StartServer();

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("KuroHttpServerRouterProxy")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"KuroHttpServerRouterProxy")
	}
	static class UKuroHttpServerRouterProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroHttpServerRouterProxy>();
	}
};
DUMPER7_ASSERTS_UKuroHttpServerRouterProxy;

// Class KuroNetwork.KuroKcpClient
// 0x03A0 (0x03D0 - 0x0030)
class UKuroKcpClient final : public UObject
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnConnectSuccess;                                  // 0x0038(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	TDelegate<void(int32 SeqNo, int16 RpdId, uint16 MessageId, const struct FArrayBuffer& MessageBuffer)> OnRecResp; // 0x0048(0x0028)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	TDelegate<void(int32 SeqNo, int16 RpdId, uint32 ErrorCode, const struct FArrayBuffer& StringBuffer)> OnRecException; // 0x0070(0x0028)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	TDelegate<void(int32 SeqNo, uint16 MessageId, const struct FArrayBuffer& MessageBuffer)> OnRecPush; // 0x0098(0x0028)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	TDelegate<void(uint32 ErrorCode)>             OnRecTcpException;                                 // 0x00C0(0x0028)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	TDelegate<void(int32 Code1, int32 Code2, int32 Code3, int32 Code4, int32 Code5)> OnError;        // 0x00E8(0x0028)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	uint32                                        RemoteMtu;                                         // 0x0110(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseNewResolveIp;                                   // 0x0114(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsMultiThreaded;                                   // 0x0115(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsTickDrivenOutside;                               // 0x0116(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          OpenSendVerify;                                    // 0x0117(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnTcpConnected;                                    // 0x0118(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnTcpConnectFailed;                                // 0x0128(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	class UKuroTcpClient*                         TcpClient;                                         // 0x0138(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_140[0x290];                                    // 0x0140(0x0290)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CloseTcpConnect();
	bool Connect(const class FString& Addr, const int32 Port, const bool CrcCheckDisable);
	void Disconnect();
	class FString GetDebugString(const struct FArrayBuffer& ArrayBuffer, const class FString& Separator, int16 MsgId, int32 SeqNo);
	void HandleKcpConnect(const uint32 NeedCrcCheck, const uint32 Conv);
	void HandleTcpConnected();
	void HandleTcpConnectFailed();
	bool SendM(int8 MsgType, int32 SeqNo, int16 RpcId, int16 MsgId, const struct FArrayBuffer& ArrayBuffer, bool UseKcp);
	void SendTcpMessage(int16 RpcId, int16 MsgId, const struct FArrayBuffer& ArrayBuffer);
	void SetEnType(uint8 Type, int16 MsgId);
	bool SetK(uint8 Type, const struct FArrayBuffer& KeyBuffer);
	void SetKcpMtu(int32 Mtu);
	void SetKcpNoDelay(int32 NoDelay, int32 Interval, int32 Resend, int32 Nc);
	void SetKcpSegmentSize(int32 SegmentSize);
	void SetKcpStream(bool bStream);
	void SetKcpWndSize(int32 SndWnd, int32 RcvWnd);
	void StartTcpConnect(const int32 Port);
	void TickOutside(float DeltaSeconds);

	bool IsTcpConnectStart() const;

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("KuroKcpClient")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"KuroKcpClient")
	}
	static class UKuroKcpClient* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroKcpClient>();
	}
};
DUMPER7_ASSERTS_UKuroKcpClient;

// Class KuroNetwork.KuroKcpTestWorker
// 0x0260 (0x0290 - 0x0030)
class UKuroKcpTestWorker final : public UObject
{
public:
	uint8                                         Pad_30[0x260];                                     // 0x0030(0x0260)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnConnectSuccess();
	void OnRecvException(int32 SeqNo, int16 RpcId, int32 ErrorCode, struct FArrayBuffer* MessageBuff);
	void OnRecvPush(int32 SeqNo, uint16 MessageId, struct FArrayBuffer* MessageBuff);
	void OnRecvResponse(int32 SeqNo, int16 RpcId, uint16 MessageId, struct FArrayBuffer* MessageBuff);

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("KuroKcpTestWorker")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"KuroKcpTestWorker")
	}
	static class UKuroKcpTestWorker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroKcpTestWorker>();
	}
};
DUMPER7_ASSERTS_UKuroKcpTestWorker;

// Class KuroNetwork.KuroNetworkChange
// 0x0020 (0x0050 - 0x0030)
class UKuroNetworkChange final : public UObject
{
public:
	TMulticastInlineDelegate<void(uint8 NetworkTransportType)> NetworkChangeDelegate;                // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x10];                                      // 0x0040(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	uint8 GetNetworkType();

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("KuroNetworkChange")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"KuroNetworkChange")
	}
	static class UKuroNetworkChange* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroNetworkChange>();
	}
};
DUMPER7_ASSERTS_UKuroNetworkChange;

// Class KuroNetwork.KuroNetworkDetection
// 0x0000 (0x0030 - 0x0030)
class UKuroNetworkDetection final : public UObject
{
public:
	static void AbortGatewayUdpReachable();
	static void DetectionFinish(bool bSuccess);
	static void GatewayUdpReachable(const class FString& IpAddress, const TArray<int32>& Ports, const class FString& Payload, TDelegate<void(int32 SuccessCount, int32 ErrorCode)> ResultDelegate);
	static class FString GetCurrentProxyAddress();
	static class FString GetDetectionConfig(const class FString& ServerName);
	static void ResolveDomainFinish();
	static void ResolveDomainName(const class FString& DomainName, TDelegate<void(int32 ErrorCode)> Callback);
	static void SetCDNConfig(const class FString& CDNConfig);
	static void TestUdpReachable(const class FString& IpAddress, const TArray<int32>& Ports, TDelegate<void(int32 SuccessCount, int32 ErrorCode)> ResultDelegate);

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("KuroNetworkDetection")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"KuroNetworkDetection")
	}
	static class UKuroNetworkDetection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroNetworkDetection>();
	}
};
DUMPER7_ASSERTS_UKuroNetworkDetection;

// Class KuroNetwork.KuroNetworkSetting
// 0x0058 (0x0088 - 0x0030)
class UKuroNetworkSetting final : public UObject
{
public:
	class FString                                 AlAki;                                             // 0x0030(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AlAks;                                             // 0x0040(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 RptPub;                                            // 0x0050(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 RptUrl;                                            // 0x0060(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 RptUrlGlobal;                                      // 0x0070(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableDump;                                        // 0x0080(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseNativeMethod;                                   // 0x0081(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_82[0x6];                                       // 0x0082(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("KuroNetworkSetting")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"KuroNetworkSetting")
	}
	static class UKuroNetworkSetting* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroNetworkSetting>();
	}
};
DUMPER7_ASSERTS_UKuroNetworkSetting;

// Class KuroNetwork.KuroTcpClient
// 0x0070 (0x00A0 - 0x0030)
class alignas(0x10) UKuroTcpClient final : public UObject
{
public:
	uint8                                         Pad_30[0x30];                                      // 0x0030(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          IsTickDrivenOutside;                               // 0x0060(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x2F];                                      // 0x0061(0x002F)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<uint8>                                 RecvData;                                          // 0x0090(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void CloseSocket();
	void Connect(const class FString& Addr, int32 Port);
	void Disconnect();
	void Send(const TArray<uint8>& Data);
	void ShutDownSocket();
	void TickOutside(float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("KuroTcpClient")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"KuroTcpClient")
	}
	static class UKuroTcpClient* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroTcpClient>();
	}
};
DUMPER7_ASSERTS_UKuroTcpClient;

// Class KuroNetwork.KuroTraceroute
// 0x0010 (0x0040 - 0x0030)
class UKuroTraceroute final : public UObject
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Abort();
	void Traceroute(const class FString& Target, TDelegate<void(bool IsReached)> Callback);

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("KuroTraceroute")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"KuroTraceroute")
	}
	static class UKuroTraceroute* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroTraceroute>();
	}
};
DUMPER7_ASSERTS_UKuroTraceroute;

// Class KuroNetwork.KuroUdp
// 0x0000 (0x0030 - 0x0030)
class UKuroUdp final : public UBlueprintFunctionLibrary
{
public:
	static void SendUdpMessage(const class FString& Ip, int32 Port, const class FString& Message, int32 MaxRecvSize, TDelegate<void(bool IsSuccess, const class FString& Response)> Callback);

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("KuroUdp")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"KuroUdp")
	}
	static class UKuroUdp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroUdp>();
	}
};
DUMPER7_ASSERTS_UKuroUdp;

// Class KuroNetwork.SendHttpRequest
// 0x0020 (0x0058 - 0x0038)
class USendHttpRequest final : public UBlueprintAsyncActionBase
{
public:
	TMulticastInlineDelegate<void(int32 Code, const class FString& Data)> OnSuccess;                 // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(int32 Code, const class FString& Data)> OnFail;                    // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class USendHttpRequest* HttpRequest(const class FString& URL, EHttpMethod Method, const class FString& PostBody);
	static class USendHttpRequest* HttpRequestEx(const class FString& URL, EHttpMethod Method, const class FString& PostBody, const class FString& HeaderParam);

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("SendHttpRequest")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"SendHttpRequest")
	}
	static class USendHttpRequest* GetDefaultObj()
	{
		return GetDefaultObjImpl<USendHttpRequest>();
	}
};
DUMPER7_ASSERTS_USendHttpRequest;

}


#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: KuroComponent

#include "Basic.hpp"

#include "KuroComponent_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"


namespace SDK
{

// Class KuroComponent.GpuNpcAvoidComponent
// 0x00B8 (0x0178 - 0x00C0)
class UGpuNpcAvoidComponent final : public UActorComponent
{
public:
	TArray<struct FGpuNpcConfig>                  GpuNpcCongifs;                                     // 0x00C0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         AvoidDistanceMin;                                  // 0x00D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AvoidDistanceMax;                                  // 0x00D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACharacter*                             WatchingCharacter;                                 // 0x00D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E0[0x98];                                      // 0x00E0(0x0098)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitGpuNpcAvoid();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GpuNpcAvoidComponent">();
	}
	static class UGpuNpcAvoidComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGpuNpcAvoidComponent>();
	}
};
static_assert(alignof(UGpuNpcAvoidComponent) == 0x000008, "Wrong alignment on UGpuNpcAvoidComponent");
static_assert(sizeof(UGpuNpcAvoidComponent) == 0x000178, "Wrong size on UGpuNpcAvoidComponent");
static_assert(offsetof(UGpuNpcAvoidComponent, GpuNpcCongifs) == 0x0000C0, "Member 'UGpuNpcAvoidComponent::GpuNpcCongifs' has a wrong offset!");
static_assert(offsetof(UGpuNpcAvoidComponent, AvoidDistanceMin) == 0x0000D0, "Member 'UGpuNpcAvoidComponent::AvoidDistanceMin' has a wrong offset!");
static_assert(offsetof(UGpuNpcAvoidComponent, AvoidDistanceMax) == 0x0000D4, "Member 'UGpuNpcAvoidComponent::AvoidDistanceMax' has a wrong offset!");
static_assert(offsetof(UGpuNpcAvoidComponent, WatchingCharacter) == 0x0000D8, "Member 'UGpuNpcAvoidComponent::WatchingCharacter' has a wrong offset!");

// Class KuroComponent.GpuNpcDitherComponent
// 0x00E0 (0x01A0 - 0x00C0)
class alignas(0x10) UGpuNpcDitherComponent final : public UActorComponent
{
public:
	class FName                                   DitherCollisionTagName;                            // 0x00C0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GpuNpcCollisionRadius;                             // 0x00CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GpuNpcCollisionHeight;                             // 0x00D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExtraOverlapCheckDistance;                         // 0x00D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DitherExp;                                         // 0x00D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxTickInterval;                                   // 0x00DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinTickIntervalDist;                               // 0x00E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxTickIntervalDist;                               // 0x00E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACharacter*                             WatchingCharacter;                                 // 0x00E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Gravity;                                           // 0x00F0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumCustomData;                                     // 0x00FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_100[0xA0];                                     // 0x0100(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ResetDitherForAllInstance(float Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GpuNpcDitherComponent">();
	}
	static class UGpuNpcDitherComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGpuNpcDitherComponent>();
	}
};
static_assert(alignof(UGpuNpcDitherComponent) == 0x000010, "Wrong alignment on UGpuNpcDitherComponent");
static_assert(sizeof(UGpuNpcDitherComponent) == 0x0001A0, "Wrong size on UGpuNpcDitherComponent");
static_assert(offsetof(UGpuNpcDitherComponent, DitherCollisionTagName) == 0x0000C0, "Member 'UGpuNpcDitherComponent::DitherCollisionTagName' has a wrong offset!");
static_assert(offsetof(UGpuNpcDitherComponent, GpuNpcCollisionRadius) == 0x0000CC, "Member 'UGpuNpcDitherComponent::GpuNpcCollisionRadius' has a wrong offset!");
static_assert(offsetof(UGpuNpcDitherComponent, GpuNpcCollisionHeight) == 0x0000D0, "Member 'UGpuNpcDitherComponent::GpuNpcCollisionHeight' has a wrong offset!");
static_assert(offsetof(UGpuNpcDitherComponent, ExtraOverlapCheckDistance) == 0x0000D4, "Member 'UGpuNpcDitherComponent::ExtraOverlapCheckDistance' has a wrong offset!");
static_assert(offsetof(UGpuNpcDitherComponent, DitherExp) == 0x0000D8, "Member 'UGpuNpcDitherComponent::DitherExp' has a wrong offset!");
static_assert(offsetof(UGpuNpcDitherComponent, MaxTickInterval) == 0x0000DC, "Member 'UGpuNpcDitherComponent::MaxTickInterval' has a wrong offset!");
static_assert(offsetof(UGpuNpcDitherComponent, MinTickIntervalDist) == 0x0000E0, "Member 'UGpuNpcDitherComponent::MinTickIntervalDist' has a wrong offset!");
static_assert(offsetof(UGpuNpcDitherComponent, MaxTickIntervalDist) == 0x0000E4, "Member 'UGpuNpcDitherComponent::MaxTickIntervalDist' has a wrong offset!");
static_assert(offsetof(UGpuNpcDitherComponent, WatchingCharacter) == 0x0000E8, "Member 'UGpuNpcDitherComponent::WatchingCharacter' has a wrong offset!");
static_assert(offsetof(UGpuNpcDitherComponent, Gravity) == 0x0000F0, "Member 'UGpuNpcDitherComponent::Gravity' has a wrong offset!");
static_assert(offsetof(UGpuNpcDitherComponent, NumCustomData) == 0x0000FC, "Member 'UGpuNpcDitherComponent::NumCustomData' has a wrong offset!");

// Class KuroComponent.KuroAnimPerfTestComponent
// 0x00B0 (0x0170 - 0x00C0)
class UKuroAnimPerfTestComponent final : public UActorComponent
{
public:
	int32                                         NumSkeletalMeshActorsToGenerate;                   // 0x00C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAnimPerfTestBornFrom                         BornFrom;                                          // 0x00C4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C5[0x3];                                       // 0x00C5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class APlayerStart>            SkelMeshActorBirthplace;                           // 0x00C8(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAnimPerfTestActorsGenMethod                  GenMethod;                                         // 0x00F8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAnimPerfTestSkelMeshLifeCycle                LifeCycle;                                         // 0x00F9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FA[0x2];                                       // 0x00FA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SkelMeshActorInterval;                             // 0x00FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SkelMeshLOD;                                       // 0x0100(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_104[0x4];                                      // 0x0104(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMesh*                          SkelMeshTemplate;                                  // 0x0108(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimationAsset*                        AnimTemplate;                                      // 0x0110(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAnimPerfTestRandomGenActorGroup              ActorsRandGenGroup;                                // 0x0118(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAnimPerfTestAnimSeqFilterMethod              AnimSeqFilterMethod;                               // 0x0119(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11A[0x6];                                      // 0x011A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         AnimSeqFilter;                                     // 0x0120(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class USkeletalMesh*>                  RandSkelMeshTemplates;                             // 0x0130(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UAnimSequence*>                  RandSkelMeshAniSeqs;                               // 0x0140(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         GeneratedSkelMeshActors;                           // 0x0150(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_160[0x10];                                     // 0x0160(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DestroySkeletalMeshActors();
	void GenerateSkeletalMeshActors();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroAnimPerfTestComponent">();
	}
	static class UKuroAnimPerfTestComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroAnimPerfTestComponent>();
	}
};
static_assert(alignof(UKuroAnimPerfTestComponent) == 0x000008, "Wrong alignment on UKuroAnimPerfTestComponent");
static_assert(sizeof(UKuroAnimPerfTestComponent) == 0x000170, "Wrong size on UKuroAnimPerfTestComponent");
static_assert(offsetof(UKuroAnimPerfTestComponent, NumSkeletalMeshActorsToGenerate) == 0x0000C0, "Member 'UKuroAnimPerfTestComponent::NumSkeletalMeshActorsToGenerate' has a wrong offset!");
static_assert(offsetof(UKuroAnimPerfTestComponent, BornFrom) == 0x0000C4, "Member 'UKuroAnimPerfTestComponent::BornFrom' has a wrong offset!");
static_assert(offsetof(UKuroAnimPerfTestComponent, SkelMeshActorBirthplace) == 0x0000C8, "Member 'UKuroAnimPerfTestComponent::SkelMeshActorBirthplace' has a wrong offset!");
static_assert(offsetof(UKuroAnimPerfTestComponent, GenMethod) == 0x0000F8, "Member 'UKuroAnimPerfTestComponent::GenMethod' has a wrong offset!");
static_assert(offsetof(UKuroAnimPerfTestComponent, LifeCycle) == 0x0000F9, "Member 'UKuroAnimPerfTestComponent::LifeCycle' has a wrong offset!");
static_assert(offsetof(UKuroAnimPerfTestComponent, SkelMeshActorInterval) == 0x0000FC, "Member 'UKuroAnimPerfTestComponent::SkelMeshActorInterval' has a wrong offset!");
static_assert(offsetof(UKuroAnimPerfTestComponent, SkelMeshLOD) == 0x000100, "Member 'UKuroAnimPerfTestComponent::SkelMeshLOD' has a wrong offset!");
static_assert(offsetof(UKuroAnimPerfTestComponent, SkelMeshTemplate) == 0x000108, "Member 'UKuroAnimPerfTestComponent::SkelMeshTemplate' has a wrong offset!");
static_assert(offsetof(UKuroAnimPerfTestComponent, AnimTemplate) == 0x000110, "Member 'UKuroAnimPerfTestComponent::AnimTemplate' has a wrong offset!");
static_assert(offsetof(UKuroAnimPerfTestComponent, ActorsRandGenGroup) == 0x000118, "Member 'UKuroAnimPerfTestComponent::ActorsRandGenGroup' has a wrong offset!");
static_assert(offsetof(UKuroAnimPerfTestComponent, AnimSeqFilterMethod) == 0x000119, "Member 'UKuroAnimPerfTestComponent::AnimSeqFilterMethod' has a wrong offset!");
static_assert(offsetof(UKuroAnimPerfTestComponent, AnimSeqFilter) == 0x000120, "Member 'UKuroAnimPerfTestComponent::AnimSeqFilter' has a wrong offset!");
static_assert(offsetof(UKuroAnimPerfTestComponent, RandSkelMeshTemplates) == 0x000130, "Member 'UKuroAnimPerfTestComponent::RandSkelMeshTemplates' has a wrong offset!");
static_assert(offsetof(UKuroAnimPerfTestComponent, RandSkelMeshAniSeqs) == 0x000140, "Member 'UKuroAnimPerfTestComponent::RandSkelMeshAniSeqs' has a wrong offset!");
static_assert(offsetof(UKuroAnimPerfTestComponent, GeneratedSkelMeshActors) == 0x000150, "Member 'UKuroAnimPerfTestComponent::GeneratedSkelMeshActors' has a wrong offset!");

// Class KuroComponent.KuroChainComponent
// 0x0110 (0x0670 - 0x0560)
#pragma pack(push, 0x1)
class alignas(0x10) UKuroChainComponent : public UMeshComponent
{
public:
	class UStaticMesh*                            ChainMesh;                                         // 0x0560(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Scale;                                             // 0x0568(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Segments;                                          // 0x0574(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AdditiveRotation;                                  // 0x0578(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChainLength;                                       // 0x0584(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                EndPoint;                                          // 0x0588(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AttachStart;                                       // 0x0594(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_595[0x3];                                      // 0x0595(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FComponentReference                    AttachStartTo;                                     // 0x0598(0x0030)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FName                                   AttachStartToSocket;                               // 0x05C8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AttachEnd;                                         // 0x05D4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D5[0x3];                                      // 0x05D5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FComponentReference                    AttachEndTo;                                       // 0x05D8(0x0030)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FName                                   AttachEndToSocket;                                 // 0x0608(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Gravity;                                           // 0x0614(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Stiffness;                                         // 0x0618(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SelfCollision;                                     // 0x061C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61D[0x3];                                      // 0x061D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SelfCollisionWidth;                                // 0x0620(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SelfCollisionThreshold;                            // 0x0624(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FrameSkip;                                         // 0x0628(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_62C[0x4];                                      // 0x062C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UInstancedStaticMeshComponent*          InstanceComponent;                                 // 0x0630(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_638[0x30];                                     // 0x0638(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitChain();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroChainComponent">();
	}
	static class UKuroChainComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroChainComponent>();
	}
};
#pragma pack(pop)
static_assert(alignof(UKuroChainComponent) == 0x000010, "Wrong alignment on UKuroChainComponent");
static_assert(sizeof(UKuroChainComponent) == 0x000670, "Wrong size on UKuroChainComponent");
static_assert(offsetof(UKuroChainComponent, ChainMesh) == 0x000560, "Member 'UKuroChainComponent::ChainMesh' has a wrong offset!");
static_assert(offsetof(UKuroChainComponent, Scale) == 0x000568, "Member 'UKuroChainComponent::Scale' has a wrong offset!");
static_assert(offsetof(UKuroChainComponent, Segments) == 0x000574, "Member 'UKuroChainComponent::Segments' has a wrong offset!");
static_assert(offsetof(UKuroChainComponent, AdditiveRotation) == 0x000578, "Member 'UKuroChainComponent::AdditiveRotation' has a wrong offset!");
static_assert(offsetof(UKuroChainComponent, ChainLength) == 0x000584, "Member 'UKuroChainComponent::ChainLength' has a wrong offset!");
static_assert(offsetof(UKuroChainComponent, EndPoint) == 0x000588, "Member 'UKuroChainComponent::EndPoint' has a wrong offset!");
static_assert(offsetof(UKuroChainComponent, AttachStart) == 0x000594, "Member 'UKuroChainComponent::AttachStart' has a wrong offset!");
static_assert(offsetof(UKuroChainComponent, AttachStartTo) == 0x000598, "Member 'UKuroChainComponent::AttachStartTo' has a wrong offset!");
static_assert(offsetof(UKuroChainComponent, AttachStartToSocket) == 0x0005C8, "Member 'UKuroChainComponent::AttachStartToSocket' has a wrong offset!");
static_assert(offsetof(UKuroChainComponent, AttachEnd) == 0x0005D4, "Member 'UKuroChainComponent::AttachEnd' has a wrong offset!");
static_assert(offsetof(UKuroChainComponent, AttachEndTo) == 0x0005D8, "Member 'UKuroChainComponent::AttachEndTo' has a wrong offset!");
static_assert(offsetof(UKuroChainComponent, AttachEndToSocket) == 0x000608, "Member 'UKuroChainComponent::AttachEndToSocket' has a wrong offset!");
static_assert(offsetof(UKuroChainComponent, Gravity) == 0x000614, "Member 'UKuroChainComponent::Gravity' has a wrong offset!");
static_assert(offsetof(UKuroChainComponent, Stiffness) == 0x000618, "Member 'UKuroChainComponent::Stiffness' has a wrong offset!");
static_assert(offsetof(UKuroChainComponent, SelfCollision) == 0x00061C, "Member 'UKuroChainComponent::SelfCollision' has a wrong offset!");
static_assert(offsetof(UKuroChainComponent, SelfCollisionWidth) == 0x000620, "Member 'UKuroChainComponent::SelfCollisionWidth' has a wrong offset!");
static_assert(offsetof(UKuroChainComponent, SelfCollisionThreshold) == 0x000624, "Member 'UKuroChainComponent::SelfCollisionThreshold' has a wrong offset!");
static_assert(offsetof(UKuroChainComponent, FrameSkip) == 0x000628, "Member 'UKuroChainComponent::FrameSkip' has a wrong offset!");
static_assert(offsetof(UKuroChainComponent, InstanceComponent) == 0x000630, "Member 'UKuroChainComponent::InstanceComponent' has a wrong offset!");

// Class KuroComponent.KuroCharacterAnimationComponent
// 0x0150 (0x0210 - 0x00C0)
class UKuroCharacterAnimationComponent final : public UActorComponent
{
public:
	float                                         BufferTimeLength;                                  // 0x00C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BufferNowTime;                                     // 0x00C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C8[0x148];                                     // 0x00C8(0x0148)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddModelLocation(const struct FVector& Offset);
	void AddModelQuat(const struct FQuat& Quat, bool LockCenter);
	void D_GetTransformOffsetInWorld(const struct FTransformDouble& Child, const struct FTransformDouble& Parent);
	void GetTransformOffsetInWorld(const struct FTransform& Child, const struct FTransform& Parent);
	void ResetModelLocation();
	void ResetModelQuat();
	void SetOriginLocation(const struct FVector& Location);
	void StopModelBuffer();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroCharacterAnimationComponent">();
	}
	static class UKuroCharacterAnimationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroCharacterAnimationComponent>();
	}
};
static_assert(alignof(UKuroCharacterAnimationComponent) == 0x000008, "Wrong alignment on UKuroCharacterAnimationComponent");
static_assert(sizeof(UKuroCharacterAnimationComponent) == 0x000210, "Wrong size on UKuroCharacterAnimationComponent");
static_assert(offsetof(UKuroCharacterAnimationComponent, BufferTimeLength) == 0x0000C0, "Member 'UKuroCharacterAnimationComponent::BufferTimeLength' has a wrong offset!");
static_assert(offsetof(UKuroCharacterAnimationComponent, BufferNowTime) == 0x0000C4, "Member 'UKuroCharacterAnimationComponent::BufferNowTime' has a wrong offset!");

// Class KuroComponent.KuroRegionShapeComponent
// 0x0000 (0x0220 - 0x0220)
class UKuroRegionShapeComponent : public USceneComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroRegionShapeComponent">();
	}
	static class UKuroRegionShapeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroRegionShapeComponent>();
	}
};
static_assert(alignof(UKuroRegionShapeComponent) == 0x000010, "Wrong alignment on UKuroRegionShapeComponent");
static_assert(sizeof(UKuroRegionShapeComponent) == 0x000220, "Wrong size on UKuroRegionShapeComponent");

// Class KuroComponent.KuroRegionBoxComponent
// 0x0010 (0x0230 - 0x0220)
class UKuroRegionBoxComponent final : public UKuroRegionShapeComponent
{
public:
	struct FVector                                BoxExtent;                                         // 0x0220(0x000C)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_22C[0x4];                                      // 0x022C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroRegionBoxComponent">();
	}
	static class UKuroRegionBoxComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroRegionBoxComponent>();
	}
};
static_assert(alignof(UKuroRegionBoxComponent) == 0x000010, "Wrong alignment on UKuroRegionBoxComponent");
static_assert(sizeof(UKuroRegionBoxComponent) == 0x000230, "Wrong size on UKuroRegionBoxComponent");
static_assert(offsetof(UKuroRegionBoxComponent, BoxExtent) == 0x000220, "Member 'UKuroRegionBoxComponent::BoxExtent' has a wrong offset!");

// Class KuroComponent.KuroRegionCylinderComponent
// 0x0010 (0x0230 - 0x0220)
class UKuroRegionCylinderComponent final : public UKuroRegionShapeComponent
{
public:
	float                                         Radius;                                            // 0x0220(0x0004)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HalfHeight;                                        // 0x0224(0x0004)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_228[0x8];                                      // 0x0228(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroRegionCylinderComponent">();
	}
	static class UKuroRegionCylinderComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroRegionCylinderComponent>();
	}
};
static_assert(alignof(UKuroRegionCylinderComponent) == 0x000010, "Wrong alignment on UKuroRegionCylinderComponent");
static_assert(sizeof(UKuroRegionCylinderComponent) == 0x000230, "Wrong size on UKuroRegionCylinderComponent");
static_assert(offsetof(UKuroRegionCylinderComponent, Radius) == 0x000220, "Member 'UKuroRegionCylinderComponent::Radius' has a wrong offset!");
static_assert(offsetof(UKuroRegionCylinderComponent, HalfHeight) == 0x000224, "Member 'UKuroRegionCylinderComponent::HalfHeight' has a wrong offset!");

// Class KuroComponent.KuroRegionDetectComponent
// 0x00A8 (0x0168 - 0x00C0)
class UKuroRegionDetectComponent final : public UActorComponent
{
public:
	uint8                                         Pad_C0[0x8];                                       // 0x00C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, class UKuroRegionShapeComponent*> RegionMap;                                 // 0x00C8(0x0050)(ExportObject, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TMap<int32, struct FRegionDetectInfo>         RegionDetectMap;                                   // 0x0118(0x0050)(NativeAccessSpecifierPrivate)

public:
	int32 GetRegionDetectId();
	class UKuroRegionEventBinder* GetRegionEvent(const class FString& RegionName, int32 Id);
	void RemoveRegionDetect(int32 Id);
	void ResetEventTargets();
	void SetDebugMode(const bool IsOpen);
	void SetEventTarget(class AActor* DetectTarget, int32 Id);
	void SetEventTargets(const TArray<class AActor*>& DetectTargets, int32 Id);

	bool Detect(const struct FVectorDouble& Point, const class FString& RegionName) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroRegionDetectComponent">();
	}
	static class UKuroRegionDetectComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroRegionDetectComponent>();
	}
};
static_assert(alignof(UKuroRegionDetectComponent) == 0x000008, "Wrong alignment on UKuroRegionDetectComponent");
static_assert(sizeof(UKuroRegionDetectComponent) == 0x000168, "Wrong size on UKuroRegionDetectComponent");
static_assert(offsetof(UKuroRegionDetectComponent, RegionMap) == 0x0000C8, "Member 'UKuroRegionDetectComponent::RegionMap' has a wrong offset!");
static_assert(offsetof(UKuroRegionDetectComponent, RegionDetectMap) == 0x000118, "Member 'UKuroRegionDetectComponent::RegionDetectMap' has a wrong offset!");

// Class KuroComponent.KuroRegionEventBinder
// 0x0020 (0x0050 - 0x0030)
class UKuroRegionEventBinder final : public UObject
{
public:
	class FString                                 RegionName;                                        // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool IsInRegion, class AActor* Target)> Callback;                  // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroRegionEventBinder">();
	}
	static class UKuroRegionEventBinder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroRegionEventBinder>();
	}
};
static_assert(alignof(UKuroRegionEventBinder) == 0x000008, "Wrong alignment on UKuroRegionEventBinder");
static_assert(sizeof(UKuroRegionEventBinder) == 0x000050, "Wrong size on UKuroRegionEventBinder");
static_assert(offsetof(UKuroRegionEventBinder, RegionName) == 0x000030, "Member 'UKuroRegionEventBinder::RegionName' has a wrong offset!");
static_assert(offsetof(UKuroRegionEventBinder, Callback) == 0x000040, "Member 'UKuroRegionEventBinder::Callback' has a wrong offset!");

// Class KuroComponent.KuroRegionSectorComponent
// 0x0010 (0x0230 - 0x0220)
class UKuroRegionSectorComponent final : public UKuroRegionShapeComponent
{
public:
	float                                         Radius;                                            // 0x0220(0x0004)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Angle;                                             // 0x0224(0x0004)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HalfHeight;                                        // 0x0228(0x0004)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_22C[0x4];                                      // 0x022C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroRegionSectorComponent">();
	}
	static class UKuroRegionSectorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroRegionSectorComponent>();
	}
};
static_assert(alignof(UKuroRegionSectorComponent) == 0x000010, "Wrong alignment on UKuroRegionSectorComponent");
static_assert(sizeof(UKuroRegionSectorComponent) == 0x000230, "Wrong size on UKuroRegionSectorComponent");
static_assert(offsetof(UKuroRegionSectorComponent, Radius) == 0x000220, "Member 'UKuroRegionSectorComponent::Radius' has a wrong offset!");
static_assert(offsetof(UKuroRegionSectorComponent, Angle) == 0x000224, "Member 'UKuroRegionSectorComponent::Angle' has a wrong offset!");
static_assert(offsetof(UKuroRegionSectorComponent, HalfHeight) == 0x000228, "Member 'UKuroRegionSectorComponent::HalfHeight' has a wrong offset!");

// Class KuroComponent.KuroRegionSphereComponent
// 0x0010 (0x0230 - 0x0220)
class UKuroRegionSphereComponent final : public UKuroRegionShapeComponent
{
public:
	float                                         Radius;                                            // 0x0220(0x0004)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_224[0xC];                                      // 0x0224(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroRegionSphereComponent">();
	}
	static class UKuroRegionSphereComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroRegionSphereComponent>();
	}
};
static_assert(alignof(UKuroRegionSphereComponent) == 0x000010, "Wrong alignment on UKuroRegionSphereComponent");
static_assert(sizeof(UKuroRegionSphereComponent) == 0x000230, "Wrong size on UKuroRegionSphereComponent");
static_assert(offsetof(UKuroRegionSphereComponent, Radius) == 0x000220, "Member 'UKuroRegionSphereComponent::Radius' has a wrong offset!");

// Class KuroComponent.KuroSceneItemGuidePathComponent
// 0x0058 (0x0118 - 0x00C0)
class UKuroSceneItemGuidePathComponent final : public UActorComponent
{
public:
	bool                                          HasFinishTag;                                      // 0x00C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasActiveTag;                                      // 0x00C1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C2[0x6];                                       // 0x00C2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraComponent*                      NiagaraComponent;                                  // 0x00C8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D0[0x48];                                      // 0x00D0(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void StartTick(const struct FLinearColor& Normal, const struct FLinearColor& ChangeCoefficient, const struct FLinearColor& Finish, class FName ParameterName, float TotalCountDown, float CurCountDown);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroSceneItemGuidePathComponent">();
	}
	static class UKuroSceneItemGuidePathComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroSceneItemGuidePathComponent>();
	}
};
static_assert(alignof(UKuroSceneItemGuidePathComponent) == 0x000008, "Wrong alignment on UKuroSceneItemGuidePathComponent");
static_assert(sizeof(UKuroSceneItemGuidePathComponent) == 0x000118, "Wrong size on UKuroSceneItemGuidePathComponent");
static_assert(offsetof(UKuroSceneItemGuidePathComponent, HasFinishTag) == 0x0000C0, "Member 'UKuroSceneItemGuidePathComponent::HasFinishTag' has a wrong offset!");
static_assert(offsetof(UKuroSceneItemGuidePathComponent, HasActiveTag) == 0x0000C1, "Member 'UKuroSceneItemGuidePathComponent::HasActiveTag' has a wrong offset!");
static_assert(offsetof(UKuroSceneItemGuidePathComponent, NiagaraComponent) == 0x0000C8, "Member 'UKuroSceneItemGuidePathComponent::NiagaraComponent' has a wrong offset!");

// Class KuroComponent.KuroSceneItemModelBufferComponent
// 0x0150 (0x0210 - 0x00C0)
class UKuroSceneItemModelBufferComponent final : public UActorComponent
{
public:
	float                                         BufferTimeLength;                                  // 0x00C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BufferNowTime;                                     // 0x00C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C8[0x148];                                     // 0x00C8(0x0148)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddModelLocation(const struct FVector& Offset);
	void AddModelQuat(const struct FQuat& Quat, bool LockCenter);
	void D_GetTransformOffsetInWorld(const struct FTransformDouble& Child, const struct FTransformDouble& Parent, struct FTransformDouble* Out);
	void GetTransformOffsetInWorld(const struct FTransform& Child, const struct FTransform& Parent);
	void ResetModelLocation();
	void ResetModelQuat();
	void SetUpMeshComponent(class USkeletalMeshComponent* InMeshComponent);
	void StopModelBuffer();

	bool SetActorTransformExceptSkeletalMesh(const struct FVectorDouble& NewLocation, const struct FRotator& NewRotation, bool bSweep, struct FHitResult* SweepHitResult, bool bTeleport, bool bIgnoreOverlap) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroSceneItemModelBufferComponent">();
	}
	static class UKuroSceneItemModelBufferComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroSceneItemModelBufferComponent>();
	}
};
static_assert(alignof(UKuroSceneItemModelBufferComponent) == 0x000008, "Wrong alignment on UKuroSceneItemModelBufferComponent");
static_assert(sizeof(UKuroSceneItemModelBufferComponent) == 0x000210, "Wrong size on UKuroSceneItemModelBufferComponent");
static_assert(offsetof(UKuroSceneItemModelBufferComponent, BufferTimeLength) == 0x0000C0, "Member 'UKuroSceneItemModelBufferComponent::BufferTimeLength' has a wrong offset!");
static_assert(offsetof(UKuroSceneItemModelBufferComponent, BufferNowTime) == 0x0000C4, "Member 'UKuroSceneItemModelBufferComponent::BufferNowTime' has a wrong offset!");

// Class KuroComponent.KuroSceneItemMoveComponent
// 0x0220 (0x0320 - 0x0100)
class alignas(0x10) UKuroSceneItemMoveComponent final : public UMovementComponent
{
public:
	uint8                                         Pad_100[0x18];                                     // 0x0100(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CustomTimeDilation;                                // 0x0118(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bUseRVOAvoidance : 1;                              // 0x011C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_11D[0x3];                                      // 0x011D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AvoidanceUID;                                      // 0x0120(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FNavAvoidanceMask                      AvoidanceGroup;                                    // 0x0124(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	struct FNavAvoidanceMask                      GroupsToAvoid;                                     // 0x0128(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	struct FNavAvoidanceMask                      GroupsToIgnore;                                    // 0x012C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	float                                         AvoidanceWeight;                                   // 0x0130(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AvoidanceHeight;                                   // 0x0134(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AvoidanceRadius;                                   // 0x0138(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AvoidanceConsiderationRadius;                      // 0x013C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bWasAvoidanceUpdated : 1;                          // 0x0140(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_141[0x27];                                     // 0x0141(0x0027)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSimpleMoveData                        SimpleMoveData;                                    // 0x0168(0x0098)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FSplineMoveData                        SplineMoveData;                                    // 0x0200(0x0068)(BlueprintVisible, BlueprintReadOnly, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnStopCallback;                                    // 0x0268(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnMoveStopCallback;                                // 0x0278(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(int32 Index)>   OnArrivePointCallback;                             // 0x0288(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_298[0x38];                                     // 0x0298(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnRotateStopCallback;                              // 0x02D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FTargetRotationData                    TargetRotationData;                                // 0x02E0(0x0038)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_318[0x8];                                      // 0x0318(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool FindTimeByValueIn01Curve(const class UCurveFloat* Curve, const float TargetValue, float* ResultTime, int32 MaxSearchDepth, const float Tolerance);

	void AddMoveTarget(const struct FVectorDouble& Loc, float MoveTime, float WaitTime, float MaxSpeed, float Acceleration);
	bool AddRotationStep(const struct FRotator& BeginRotation, const struct FRotator& EndRotation, float TimeSec, float CdSec, class UCurveFloat* RotateCurve);
	void CalcVelocity(const float DeltaTime);
	bool GetNextMoveTarget(struct FVectorDouble* NextTarget, struct FVectorDouble* CurrentVelocity);
	bool InitRotationData(class AActor* TargetActor, bool IsLoop);
	void Kuro_SetGravityDirect(const struct FVector& InGravityDirect);
	void SetAvoidanceEnabled(bool bEnable);
	void SetAvoidanceGroupMask(const struct FNavAvoidanceMask& GroupMask);
	void SetEnableDebugForMove(bool Enable);
	void SetGroupsToAvoidMask(const struct FNavAvoidanceMask& GroupMask);
	void SetGroupsToIgnoreMask(const struct FNavAvoidanceMask& GroupMask);
	void SetMaxDeltaDegreePerSecondForUpdatingLookAt(const float MaxDegreePerSecond);
	void SetTickingMoveEnable(bool bEnabled);
	void SetTickingRotateEnable(bool bEnabled);
	bool StartMoveWithSplineAtConstantTime(class USplineComponent* SplineComponent, bool Repeat, bool Cycle, bool KeepLookAt, const float TimeSec, class UCurveFloat* TimeDisCurve, const float StartTimeOffset, float StartDis, float EndDis);
	bool StartMoveWithSplineAtDynamicSpeed(class USplineComponent* SplineComponent, const int32 MaxMoveTimes, bool Cycle, bool KeepLookAt, const float InitSpeed, const float Acceleration, const float TargetSpeed, const float StartDis, const float EndDis);
	bool StartRotate();
	void StopAllMove(bool bBroadcastStopCallback, bool bBroadcastIndexCallback);
	bool StopRotate(EKuroSceneItemStopRotateMethod StopMethod, bool bBroadcastRotateStopCallback);
	bool UpdateDynamicSpeedSplineMoveParams(const float CurrentSpeed, const float Acceleration, const float TargetSpeed);
	bool UpdateSplineMoveDistance(const float NewDistanceAloneSpline);
	bool UpdateSplineMoveDistanceByPosition(const struct FVectorDouble& NewPosition);

	float GetDistanceAlongSpline() const;
	ESimpleRunState GetSimpleRunState() const;
	ESplineRunState GetSplineRunState() const;
	bool IsMoving(bool ConsiderSimpleWaitAsMoving) const;
	bool IsRotating() const;
	struct FVector Kuro_GetGravityDirect() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroSceneItemMoveComponent">();
	}
	static class UKuroSceneItemMoveComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroSceneItemMoveComponent>();
	}
};
static_assert(alignof(UKuroSceneItemMoveComponent) == 0x000010, "Wrong alignment on UKuroSceneItemMoveComponent");
static_assert(sizeof(UKuroSceneItemMoveComponent) == 0x000320, "Wrong size on UKuroSceneItemMoveComponent");
static_assert(offsetof(UKuroSceneItemMoveComponent, CustomTimeDilation) == 0x000118, "Member 'UKuroSceneItemMoveComponent::CustomTimeDilation' has a wrong offset!");
static_assert(offsetof(UKuroSceneItemMoveComponent, AvoidanceUID) == 0x000120, "Member 'UKuroSceneItemMoveComponent::AvoidanceUID' has a wrong offset!");
static_assert(offsetof(UKuroSceneItemMoveComponent, AvoidanceGroup) == 0x000124, "Member 'UKuroSceneItemMoveComponent::AvoidanceGroup' has a wrong offset!");
static_assert(offsetof(UKuroSceneItemMoveComponent, GroupsToAvoid) == 0x000128, "Member 'UKuroSceneItemMoveComponent::GroupsToAvoid' has a wrong offset!");
static_assert(offsetof(UKuroSceneItemMoveComponent, GroupsToIgnore) == 0x00012C, "Member 'UKuroSceneItemMoveComponent::GroupsToIgnore' has a wrong offset!");
static_assert(offsetof(UKuroSceneItemMoveComponent, AvoidanceWeight) == 0x000130, "Member 'UKuroSceneItemMoveComponent::AvoidanceWeight' has a wrong offset!");
static_assert(offsetof(UKuroSceneItemMoveComponent, AvoidanceHeight) == 0x000134, "Member 'UKuroSceneItemMoveComponent::AvoidanceHeight' has a wrong offset!");
static_assert(offsetof(UKuroSceneItemMoveComponent, AvoidanceRadius) == 0x000138, "Member 'UKuroSceneItemMoveComponent::AvoidanceRadius' has a wrong offset!");
static_assert(offsetof(UKuroSceneItemMoveComponent, AvoidanceConsiderationRadius) == 0x00013C, "Member 'UKuroSceneItemMoveComponent::AvoidanceConsiderationRadius' has a wrong offset!");
static_assert(offsetof(UKuroSceneItemMoveComponent, SimpleMoveData) == 0x000168, "Member 'UKuroSceneItemMoveComponent::SimpleMoveData' has a wrong offset!");
static_assert(offsetof(UKuroSceneItemMoveComponent, SplineMoveData) == 0x000200, "Member 'UKuroSceneItemMoveComponent::SplineMoveData' has a wrong offset!");
static_assert(offsetof(UKuroSceneItemMoveComponent, OnStopCallback) == 0x000268, "Member 'UKuroSceneItemMoveComponent::OnStopCallback' has a wrong offset!");
static_assert(offsetof(UKuroSceneItemMoveComponent, OnMoveStopCallback) == 0x000278, "Member 'UKuroSceneItemMoveComponent::OnMoveStopCallback' has a wrong offset!");
static_assert(offsetof(UKuroSceneItemMoveComponent, OnArrivePointCallback) == 0x000288, "Member 'UKuroSceneItemMoveComponent::OnArrivePointCallback' has a wrong offset!");
static_assert(offsetof(UKuroSceneItemMoveComponent, OnRotateStopCallback) == 0x0002D0, "Member 'UKuroSceneItemMoveComponent::OnRotateStopCallback' has a wrong offset!");
static_assert(offsetof(UKuroSceneItemMoveComponent, TargetRotationData) == 0x0002E0, "Member 'UKuroSceneItemMoveComponent::TargetRotationData' has a wrong offset!");

// Class KuroComponent.KuroSplineChainComponent
// 0x0030 (0x06A0 - 0x0670)
class UKuroSplineChainComponent final : public UKuroChainComponent
{
public:
	float                                         SplineMaxLength;                                   // 0x0668(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MeshMinScale;                                      // 0x066C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MeshMaxScale;                                      // 0x0670(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MeshXYScaleRatio;                                  // 0x0674(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SegmentLengthMinScale;                             // 0x0678(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SegmentLengthMaxScale;                             // 0x067C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USplineComponent*                       SplineComponent;                                   // 0x0680(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_688[0x18];                                     // 0x0688(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void UpdateSplineChainIndex();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroSplineChainComponent">();
	}
	static class UKuroSplineChainComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroSplineChainComponent>();
	}
};
static_assert(alignof(UKuroSplineChainComponent) == 0x000010, "Wrong alignment on UKuroSplineChainComponent");
static_assert(sizeof(UKuroSplineChainComponent) == 0x0006A0, "Wrong size on UKuroSplineChainComponent");
static_assert(offsetof(UKuroSplineChainComponent, SplineMaxLength) == 0x000668, "Member 'UKuroSplineChainComponent::SplineMaxLength' has a wrong offset!");
static_assert(offsetof(UKuroSplineChainComponent, MeshMinScale) == 0x00066C, "Member 'UKuroSplineChainComponent::MeshMinScale' has a wrong offset!");
static_assert(offsetof(UKuroSplineChainComponent, MeshMaxScale) == 0x000670, "Member 'UKuroSplineChainComponent::MeshMaxScale' has a wrong offset!");
static_assert(offsetof(UKuroSplineChainComponent, MeshXYScaleRatio) == 0x000674, "Member 'UKuroSplineChainComponent::MeshXYScaleRatio' has a wrong offset!");
static_assert(offsetof(UKuroSplineChainComponent, SegmentLengthMinScale) == 0x000678, "Member 'UKuroSplineChainComponent::SegmentLengthMinScale' has a wrong offset!");
static_assert(offsetof(UKuroSplineChainComponent, SegmentLengthMaxScale) == 0x00067C, "Member 'UKuroSplineChainComponent::SegmentLengthMaxScale' has a wrong offset!");
static_assert(offsetof(UKuroSplineChainComponent, SplineComponent) == 0x000680, "Member 'UKuroSplineChainComponent::SplineComponent' has a wrong offset!");

}


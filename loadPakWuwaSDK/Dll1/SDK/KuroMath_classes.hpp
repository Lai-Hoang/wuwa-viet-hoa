#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: KuroMath

#include "Basic.hpp"

#include "KuroMath_structs.hpp"
#include "Engine_classes.hpp"


namespace SDK
{

// Class KuroMath.KuroBitwiseLibrary
// 0x0000 (0x0030 - 0x0030)
class UKuroBitwiseLibrary final : public UBlueprintFunctionLibrary
{
public:
	static int64 BitwiseLeftShift(const int64 Source, const int32 Bit);
	static int64 BitwiseRightShift(const int64 Source, const int32 Bit);
	static int32 IntBitwiseAnd(const int32 Num1, const int32 Num2);
	static int32 IntBitwiseNot(const int32 Num);
	static int32 IntBitwiseOr(const int32 Num1, const int32 Num2);
	static int32 IntBitwiseXOr(const int32 Num1, const int32 Num2);
	static int64 KuroStringToInt64(const class FString& StringNum);
	static int64 LongBitwiseAnd(const int64 Num1, const int64 Num2);
	static int64 LongBitwiseNot(const int64 Num);
	static int64 LongBitwiseOr(const int64 Num1, const int64 Num2);
	static int64 LongBitwiseXOr(const int64 Num1, const int64 Num2);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroBitwiseLibrary">();
	}
	static class UKuroBitwiseLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroBitwiseLibrary>();
	}
};
static_assert(alignof(UKuroBitwiseLibrary) == 0x000008, "Wrong alignment on UKuroBitwiseLibrary");
static_assert(sizeof(UKuroBitwiseLibrary) == 0x000030, "Wrong size on UKuroBitwiseLibrary");

// Class KuroMath.KuroEasingLibrary
// 0x0000 (0x0030 - 0x0030)
class UKuroEasingLibrary final : public UBlueprintFunctionLibrary
{
public:
	static float EaseInBack(const float X);
	static float EaseInBounce(const float X);
	static float EaseInCirc(const float X);
	static float EaseInCubic(const float X);
	static float EaseInElastic(const float X);
	static float EaseInExpo(const float X);
	static float EaseInOutBack(const float X);
	static float EaseInOutBounce(const float X);
	static float EaseInOutCirc(const float X);
	static float EaseInOutCubic(const float X);
	static float EaseInOutElastic(const float X);
	static float EaseInOutExpo(const float X);
	static float EaseInOutQuad(const float X);
	static float EaseInOutQuart(const float X);
	static float EaseInOutQuint(const float X);
	static float EaseInOutSine(const float X);
	static float EaseInQuad(const float X);
	static float EaseInQuart(const float X);
	static float EaseInQuint(const float X);
	static float EaseInSine(const float X);
	static float EaseOutBack(const float X);
	static float EaseOutBounce(const float X);
	static float EaseOutCirc(const float X);
	static float EaseOutCubic(const float X);
	static float EaseOutElastic(const float X);
	static float EaseOutExpo(const float X);
	static float EaseOutQuad(const float X);
	static float EaseOutQuart(const float X);
	static float EaseOutQuint(const float X);
	static float EaseOutSine(const float X);
	static float GetEasedValue(const EEasingType EaseType, const float X);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroEasingLibrary">();
	}
	static class UKuroEasingLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroEasingLibrary>();
	}
};
static_assert(alignof(UKuroEasingLibrary) == 0x000008, "Wrong alignment on UKuroEasingLibrary");
static_assert(sizeof(UKuroEasingLibrary) == 0x000030, "Wrong size on UKuroEasingLibrary");

// Class KuroMath.KuroSimplePolygonLibrary
// 0x0000 (0x0030 - 0x0030)
class UKuroSimplePolygonLibrary final : public UBlueprintFunctionLibrary
{
public:
	static struct FKuroGeometrySimplePolygon Conv_ArrayToKuroGeometrySimplePolygon(const TArray<struct FVectorDouble>& PathVertices);
	static TArray<struct FVectorDouble> Conv_KuroGeometrySimplePolygonToArray(const struct FKuroGeometrySimplePolygon& Polygon);
	static void SampleSplineToPolygon(const class USplineComponent* Spline, struct FKuroGeometrySimplePolygon* Polygon, const struct FKuroSplineSamplingOptions& SamplingOptions);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroSimplePolygonLibrary">();
	}
	static class UKuroSimplePolygonLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroSimplePolygonLibrary>();
	}
};
static_assert(alignof(UKuroSimplePolygonLibrary) == 0x000008, "Wrong alignment on UKuroSimplePolygonLibrary");
static_assert(sizeof(UKuroSimplePolygonLibrary) == 0x000030, "Wrong size on UKuroSimplePolygonLibrary");

// Class KuroMath.KuroPolygonListLibrary
// 0x0000 (0x0030 - 0x0030)
class UKuroPolygonListLibrary final : public UBlueprintFunctionLibrary
{
public:
	static int32 AddPolygonToList(struct FKuroGeometryGeneralPolygonList& PolygonList, const struct FKuroGeometrySimplePolygon& OuterPolygon, const TArray<struct FKuroGeometrySimplePolygon>& HolePolygons, bool bFixHoleOrientations);
	static void AppendPolygonList(struct FKuroGeometryGeneralPolygonList& PolygonList, const struct FKuroGeometryGeneralPolygonList& PolygonsToAppend);
	static struct FKuroGeometryGeneralPolygonList CreatePolygonListFromSimplePolygons(const TArray<struct FKuroGeometrySimplePolygon>& OuterPolygons);
	static struct FKuroGeometryGeneralPolygonList CreatePolygonListFromSinglePolygon(const struct FKuroGeometrySimplePolygon& OuterPolygon, const TArray<struct FKuroGeometrySimplePolygon>& HolePolygons, bool bFixHoleOrientations);
	static int32 GetPolygonCount(const struct FKuroGeometryGeneralPolygonList& PolygonList);
	static struct FKuroGeometrySimplePolygon GetSimplePolygon(const struct FKuroGeometryGeneralPolygonList& PolygonList, bool* bValidIndices, int32 PolygonIndex, int32 HoleIndex);
	static struct FKuroGeometryGeneralPolygonList PolygonsDifference(const struct FKuroGeometryGeneralPolygonList& PolygonList, const struct FKuroGeometryGeneralPolygonList& PolygonsToSubtract);
	static struct FKuroGeometryGeneralPolygonList PolygonsExclusiveOr(const struct FKuroGeometryGeneralPolygonList& PolygonList, const struct FKuroGeometryGeneralPolygonList& PolygonsToExclusiveOr);
	static struct FKuroGeometryGeneralPolygonList PolygonsIntersection(const struct FKuroGeometryGeneralPolygonList& PolygonList, const struct FKuroGeometryGeneralPolygonList& PolygonsToIntersect);
	static struct FKuroGeometryGeneralPolygonList PolygonsOpenPathsDifference(const struct FKuroGeometryGeneralPolygonList& PolygonList, const struct FKuroGeometryGeneralPolygonList& PolygonsToSubtract, double StrokeWidth, EJoinType JoinType, EEndType EndType);
	static struct FKuroGeometryGeneralPolygonList PolygonsUnion(const struct FKuroGeometryGeneralPolygonList& PolygonList, bool bCopyInputOnFailure);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroPolygonListLibrary">();
	}
	static class UKuroPolygonListLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroPolygonListLibrary>();
	}
};
static_assert(alignof(UKuroPolygonListLibrary) == 0x000008, "Wrong alignment on UKuroPolygonListLibrary");
static_assert(sizeof(UKuroPolygonListLibrary) == 0x000030, "Wrong size on UKuroPolygonListLibrary");

// Class KuroMath.KuroPolygonLibrary
// 0x0000 (0x0030 - 0x0030)
class UKuroPolygonLibrary final : public UBlueprintFunctionLibrary
{
public:
	static TArray<struct FVector2D> ClipPolygonByWeilerAtherton(TArray<struct FVector2D>* Polygon, TArray<struct FVector2D>* Window);
	static void EliminateSplineGaps(const TArray<class USplineComponent*>& Splines, const float Tolerance);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroPolygonLibrary">();
	}
	static class UKuroPolygonLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroPolygonLibrary>();
	}
};
static_assert(alignof(UKuroPolygonLibrary) == 0x000008, "Wrong alignment on UKuroPolygonLibrary");
static_assert(sizeof(UKuroPolygonLibrary) == 0x000030, "Wrong size on UKuroPolygonLibrary");

}


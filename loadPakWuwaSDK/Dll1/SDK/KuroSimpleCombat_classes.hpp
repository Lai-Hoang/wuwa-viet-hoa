#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: KuroSimpleCombat

#include "Basic.hpp"

#include "KuroSimpleCombat_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "Engine_classes.hpp"


namespace SDK
{

// Class KuroSimpleCombat.KSC_AttrSet
// 0x0058 (0x0088 - 0x0030)
class UKSC_AttrSet final : public UObject
{
public:
	class UKSC_Entity*                            Owner_;                                            // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<EKSC_AttrType, int32>                    Attrs_;                                            // 0x0038(0x0050)(Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KSC_AttrSet">();
	}
	static class UKSC_AttrSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKSC_AttrSet>();
	}
};
static_assert(alignof(UKSC_AttrSet) == 0x000008, "Wrong alignment on UKSC_AttrSet");
static_assert(sizeof(UKSC_AttrSet) == 0x000088, "Wrong size on UKSC_AttrSet");
static_assert(offsetof(UKSC_AttrSet, Owner_) == 0x000030, "Member 'UKSC_AttrSet::Owner_' has a wrong offset!");
static_assert(offsetof(UKSC_AttrSet, Attrs_) == 0x000038, "Member 'UKSC_AttrSet::Attrs_' has a wrong offset!");

// Class KuroSimpleCombat.KSC_Buff
// 0x0020 (0x0050 - 0x0030)
class UKSC_Buff : public UObject
{
public:
	class UKSC_Entity*                            Caster_;                                           // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UKSC_Entity*                            Owner_;                                            // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UKSC_DA_Buff*                           DaBuff_;                                           // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KSC_Buff">();
	}
	static class UKSC_Buff* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKSC_Buff>();
	}
};
static_assert(alignof(UKSC_Buff) == 0x000008, "Wrong alignment on UKSC_Buff");
static_assert(sizeof(UKSC_Buff) == 0x000050, "Wrong size on UKSC_Buff");
static_assert(offsetof(UKSC_Buff, Caster_) == 0x000030, "Member 'UKSC_Buff::Caster_' has a wrong offset!");
static_assert(offsetof(UKSC_Buff, Owner_) == 0x000038, "Member 'UKSC_Buff::Owner_' has a wrong offset!");
static_assert(offsetof(UKSC_Buff, DaBuff_) == 0x000040, "Member 'UKSC_Buff::DaBuff_' has a wrong offset!");

// Class KuroSimpleCombat.KSC_Buff_Period
// 0x0010 (0x0060 - 0x0050)
class UKSC_Buff_Period : public UKSC_Buff
{
public:
	uint8                                         Pad_50[0x10];                                      // 0x0050(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KSC_Buff_Period">();
	}
	static class UKSC_Buff_Period* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKSC_Buff_Period>();
	}
};
static_assert(alignof(UKSC_Buff_Period) == 0x000008, "Wrong alignment on UKSC_Buff_Period");
static_assert(sizeof(UKSC_Buff_Period) == 0x000060, "Wrong size on UKSC_Buff_Period");

// Class KuroSimpleCombat.KSC_Buff_Period_Damage
// 0x0008 (0x0068 - 0x0060)
class UKSC_Buff_Period_Damage final : public UKSC_Buff_Period
{
public:
	uint8                                         Pad_60[0x8];                                       // 0x0060(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KSC_Buff_Period_Damage">();
	}
	static class UKSC_Buff_Period_Damage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKSC_Buff_Period_Damage>();
	}
};
static_assert(alignof(UKSC_Buff_Period_Damage) == 0x000008, "Wrong alignment on UKSC_Buff_Period_Damage");
static_assert(sizeof(UKSC_Buff_Period_Damage) == 0x000068, "Wrong size on UKSC_Buff_Period_Damage");

// Class KuroSimpleCombat.KSC_DA_Entity
// 0x0058 (0x0090 - 0x0038)
class UKSC_DA_Entity : public UDataAsset
{
public:
	TSubclassOf<class UKSC_Entity>                RuntimeClass;                                      // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EKSC_SearchType                               SelfNeighborsType;                                 // 0x0040(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EKSC_SearchType                               TargetNeighborsType;                               // 0x0041(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42[0x6];                                       // 0x0042(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UKSC_DA_EntityRender*                   Render;                                            // 0x0048(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UKSC_DA_AttrSet*                        AttrSet;                                           // 0x0050(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UKSC_DA_Move*                           Move;                                              // 0x0058(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UKSC_DA_Skill*>                  Skills;                                            // 0x0060(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class UKSC_DA_Buff*>                   Buffs;                                             // 0x0070(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         ColliderRadius;                                    // 0x0080(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NeighborDist;                                      // 0x0084(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxNeighborsNum;                                   // 0x0088(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnRate;                                          // 0x008C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KSC_DA_Entity">();
	}
	static class UKSC_DA_Entity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKSC_DA_Entity>();
	}
};
static_assert(alignof(UKSC_DA_Entity) == 0x000008, "Wrong alignment on UKSC_DA_Entity");
static_assert(sizeof(UKSC_DA_Entity) == 0x000090, "Wrong size on UKSC_DA_Entity");
static_assert(offsetof(UKSC_DA_Entity, RuntimeClass) == 0x000038, "Member 'UKSC_DA_Entity::RuntimeClass' has a wrong offset!");
static_assert(offsetof(UKSC_DA_Entity, SelfNeighborsType) == 0x000040, "Member 'UKSC_DA_Entity::SelfNeighborsType' has a wrong offset!");
static_assert(offsetof(UKSC_DA_Entity, TargetNeighborsType) == 0x000041, "Member 'UKSC_DA_Entity::TargetNeighborsType' has a wrong offset!");
static_assert(offsetof(UKSC_DA_Entity, Render) == 0x000048, "Member 'UKSC_DA_Entity::Render' has a wrong offset!");
static_assert(offsetof(UKSC_DA_Entity, AttrSet) == 0x000050, "Member 'UKSC_DA_Entity::AttrSet' has a wrong offset!");
static_assert(offsetof(UKSC_DA_Entity, Move) == 0x000058, "Member 'UKSC_DA_Entity::Move' has a wrong offset!");
static_assert(offsetof(UKSC_DA_Entity, Skills) == 0x000060, "Member 'UKSC_DA_Entity::Skills' has a wrong offset!");
static_assert(offsetof(UKSC_DA_Entity, Buffs) == 0x000070, "Member 'UKSC_DA_Entity::Buffs' has a wrong offset!");
static_assert(offsetof(UKSC_DA_Entity, ColliderRadius) == 0x000080, "Member 'UKSC_DA_Entity::ColliderRadius' has a wrong offset!");
static_assert(offsetof(UKSC_DA_Entity, NeighborDist) == 0x000084, "Member 'UKSC_DA_Entity::NeighborDist' has a wrong offset!");
static_assert(offsetof(UKSC_DA_Entity, MaxNeighborsNum) == 0x000088, "Member 'UKSC_DA_Entity::MaxNeighborsNum' has a wrong offset!");
static_assert(offsetof(UKSC_DA_Entity, TurnRate) == 0x00008C, "Member 'UKSC_DA_Entity::TurnRate' has a wrong offset!");

// Class KuroSimpleCombat.KSC_DA_EntityRender
// 0x0010 (0x0048 - 0x0038)
class UKSC_DA_EntityRender final : public UDataAsset
{
public:
	bool                                          bIsGPUNPC;                                         // 0x0038(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AActor>                     RenderActorClass;                                  // 0x0040(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KSC_DA_EntityRender">();
	}
	static class UKSC_DA_EntityRender* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKSC_DA_EntityRender>();
	}
};
static_assert(alignof(UKSC_DA_EntityRender) == 0x000008, "Wrong alignment on UKSC_DA_EntityRender");
static_assert(sizeof(UKSC_DA_EntityRender) == 0x000048, "Wrong size on UKSC_DA_EntityRender");
static_assert(offsetof(UKSC_DA_EntityRender, bIsGPUNPC) == 0x000038, "Member 'UKSC_DA_EntityRender::bIsGPUNPC' has a wrong offset!");
static_assert(offsetof(UKSC_DA_EntityRender, RenderActorClass) == 0x000040, "Member 'UKSC_DA_EntityRender::RenderActorClass' has a wrong offset!");

// Class KuroSimpleCombat.KSC_DA_Move
// 0x0010 (0x0048 - 0x0038)
class UKSC_DA_Move : public UDataAsset
{
public:
	TSubclassOf<class UKSC_Move>                  RuntimeClass;                                      // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveSpeed;                                         // 0x0040(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveSpeedDeviation;                                // 0x0044(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KSC_DA_Move">();
	}
	static class UKSC_DA_Move* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKSC_DA_Move>();
	}
};
static_assert(alignof(UKSC_DA_Move) == 0x000008, "Wrong alignment on UKSC_DA_Move");
static_assert(sizeof(UKSC_DA_Move) == 0x000048, "Wrong size on UKSC_DA_Move");
static_assert(offsetof(UKSC_DA_Move, RuntimeClass) == 0x000038, "Member 'UKSC_DA_Move::RuntimeClass' has a wrong offset!");
static_assert(offsetof(UKSC_DA_Move, MoveSpeed) == 0x000040, "Member 'UKSC_DA_Move::MoveSpeed' has a wrong offset!");
static_assert(offsetof(UKSC_DA_Move, MoveSpeedDeviation) == 0x000044, "Member 'UKSC_DA_Move::MoveSpeedDeviation' has a wrong offset!");

// Class KuroSimpleCombat.KSC_DA_Skill
// 0x0020 (0x0058 - 0x0038)
class UKSC_DA_Skill : public UDataAsset
{
public:
	TSubclassOf<class UKSC_Skill>                 RuntimeClass;                                      // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsAutoCast;                                        // 0x0040(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CoolDown;                                          // 0x0044(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CostMP;                                            // 0x0048(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PreDelay;                                          // 0x004C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PostDelay;                                         // 0x0050(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CastRange;                                         // 0x0054(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KSC_DA_Skill">();
	}
	static class UKSC_DA_Skill* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKSC_DA_Skill>();
	}
};
static_assert(alignof(UKSC_DA_Skill) == 0x000008, "Wrong alignment on UKSC_DA_Skill");
static_assert(sizeof(UKSC_DA_Skill) == 0x000058, "Wrong size on UKSC_DA_Skill");
static_assert(offsetof(UKSC_DA_Skill, RuntimeClass) == 0x000038, "Member 'UKSC_DA_Skill::RuntimeClass' has a wrong offset!");
static_assert(offsetof(UKSC_DA_Skill, IsAutoCast) == 0x000040, "Member 'UKSC_DA_Skill::IsAutoCast' has a wrong offset!");
static_assert(offsetof(UKSC_DA_Skill, CoolDown) == 0x000044, "Member 'UKSC_DA_Skill::CoolDown' has a wrong offset!");
static_assert(offsetof(UKSC_DA_Skill, CostMP) == 0x000048, "Member 'UKSC_DA_Skill::CostMP' has a wrong offset!");
static_assert(offsetof(UKSC_DA_Skill, PreDelay) == 0x00004C, "Member 'UKSC_DA_Skill::PreDelay' has a wrong offset!");
static_assert(offsetof(UKSC_DA_Skill, PostDelay) == 0x000050, "Member 'UKSC_DA_Skill::PostDelay' has a wrong offset!");
static_assert(offsetof(UKSC_DA_Skill, CastRange) == 0x000054, "Member 'UKSC_DA_Skill::CastRange' has a wrong offset!");

// Class KuroSimpleCombat.KSC_RenderEntityInterface
// 0x0000 (0x0000 - 0x0000)
class IKSC_RenderEntityInterface final
{
public:
	void KSC_AddEntity(const int32& EntityId, const struct FTransform& InTransform);
	void KSC_RemoveEntity(const int32& EntityId);
	void KSC_SetActorTransform(const int32& EntityId, const struct FTransform& InTransform);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KSC_RenderEntityInterface">();
	}
	static class IKSC_RenderEntityInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IKSC_RenderEntityInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IKSC_RenderEntityInterface) == 0x000001, "Wrong alignment on IKSC_RenderEntityInterface");
static_assert(sizeof(IKSC_RenderEntityInterface) == 0x000001, "Wrong size on IKSC_RenderEntityInterface");

// Class KuroSimpleCombat.KSC_DA_Buff
// 0x0010 (0x0048 - 0x0038)
class UKSC_DA_Buff : public UDataAsset
{
public:
	TSubclassOf<class UKSC_Buff>                  RuntimeClass;                                      // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0040(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KSC_DA_Buff">();
	}
	static class UKSC_DA_Buff* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKSC_DA_Buff>();
	}
};
static_assert(alignof(UKSC_DA_Buff) == 0x000008, "Wrong alignment on UKSC_DA_Buff");
static_assert(sizeof(UKSC_DA_Buff) == 0x000048, "Wrong size on UKSC_DA_Buff");
static_assert(offsetof(UKSC_DA_Buff, RuntimeClass) == 0x000038, "Member 'UKSC_DA_Buff::RuntimeClass' has a wrong offset!");
static_assert(offsetof(UKSC_DA_Buff, Duration) == 0x000040, "Member 'UKSC_DA_Buff::Duration' has a wrong offset!");

// Class KuroSimpleCombat.KSC_DA_AttrSet
// 0x0058 (0x0090 - 0x0038)
class UKSC_DA_AttrSet final : public UDataAsset
{
public:
	TSubclassOf<class UKSC_AttrSet>               RuntimeClass;                                      // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EKSC_AttrType, int32>                    Attrs;                                             // 0x0040(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KSC_DA_AttrSet">();
	}
	static class UKSC_DA_AttrSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKSC_DA_AttrSet>();
	}
};
static_assert(alignof(UKSC_DA_AttrSet) == 0x000008, "Wrong alignment on UKSC_DA_AttrSet");
static_assert(sizeof(UKSC_DA_AttrSet) == 0x000090, "Wrong size on UKSC_DA_AttrSet");
static_assert(offsetof(UKSC_DA_AttrSet, RuntimeClass) == 0x000038, "Member 'UKSC_DA_AttrSet::RuntimeClass' has a wrong offset!");
static_assert(offsetof(UKSC_DA_AttrSet, Attrs) == 0x000040, "Member 'UKSC_DA_AttrSet::Attrs' has a wrong offset!");

// Class KuroSimpleCombat.KSC_Skill
// 0x0038 (0x0068 - 0x0030)
class UKSC_Skill : public UObject
{
public:
	class UKSC_DA_Skill*                          DaSkill_;                                          // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UKSC_Entity*                            Caster_;                                           // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UKSC_Entity*                            Target_;                                           // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_48[0x20];                                      // 0x0048(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KSC_Skill">();
	}
	static class UKSC_Skill* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKSC_Skill>();
	}
};
static_assert(alignof(UKSC_Skill) == 0x000008, "Wrong alignment on UKSC_Skill");
static_assert(sizeof(UKSC_Skill) == 0x000068, "Wrong size on UKSC_Skill");
static_assert(offsetof(UKSC_Skill, DaSkill_) == 0x000030, "Member 'UKSC_Skill::DaSkill_' has a wrong offset!");
static_assert(offsetof(UKSC_Skill, Caster_) == 0x000038, "Member 'UKSC_Skill::Caster_' has a wrong offset!");
static_assert(offsetof(UKSC_Skill, Target_) == 0x000040, "Member 'UKSC_Skill::Target_' has a wrong offset!");

// Class KuroSimpleCombat.KSC_DA_Entity_Tower
// 0x0000 (0x0090 - 0x0090)
class UKSC_DA_Entity_Tower final : public UKSC_DA_Entity
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KSC_DA_Entity_Tower">();
	}
	static class UKSC_DA_Entity_Tower* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKSC_DA_Entity_Tower>();
	}
};
static_assert(alignof(UKSC_DA_Entity_Tower) == 0x000008, "Wrong alignment on UKSC_DA_Entity_Tower");
static_assert(sizeof(UKSC_DA_Entity_Tower) == 0x000090, "Wrong size on UKSC_DA_Entity_Tower");

// Class KuroSimpleCombat.KSC_DA_Entity_Enemy
// 0x0000 (0x0090 - 0x0090)
class UKSC_DA_Entity_Enemy final : public UKSC_DA_Entity
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KSC_DA_Entity_Enemy">();
	}
	static class UKSC_DA_Entity_Enemy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKSC_DA_Entity_Enemy>();
	}
};
static_assert(alignof(UKSC_DA_Entity_Enemy) == 0x000008, "Wrong alignment on UKSC_DA_Entity_Enemy");
static_assert(sizeof(UKSC_DA_Entity_Enemy) == 0x000090, "Wrong size on UKSC_DA_Entity_Enemy");

// Class KuroSimpleCombat.KSC_DA_Entity_Projectile
// 0x0008 (0x0098 - 0x0090)
class UKSC_DA_Entity_Projectile final : public UKSC_DA_Entity
{
public:
	struct FKSCDamage                             Damage;                                            // 0x0090(0x0002)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_92[0x6];                                       // 0x0092(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KSC_DA_Entity_Projectile">();
	}
	static class UKSC_DA_Entity_Projectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKSC_DA_Entity_Projectile>();
	}
};
static_assert(alignof(UKSC_DA_Entity_Projectile) == 0x000008, "Wrong alignment on UKSC_DA_Entity_Projectile");
static_assert(sizeof(UKSC_DA_Entity_Projectile) == 0x000098, "Wrong size on UKSC_DA_Entity_Projectile");
static_assert(offsetof(UKSC_DA_Entity_Projectile, Damage) == 0x000090, "Member 'UKSC_DA_Entity_Projectile::Damage' has a wrong offset!");

// Class KuroSimpleCombat.KSC_Move
// 0x0018 (0x0048 - 0x0030)
class UKSC_Move : public UObject
{
public:
	class UKSC_Entity*                            Owner_;                                            // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_38[0x10];                                      // 0x0038(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KSC_Move">();
	}
	static class UKSC_Move* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKSC_Move>();
	}
};
static_assert(alignof(UKSC_Move) == 0x000008, "Wrong alignment on UKSC_Move");
static_assert(sizeof(UKSC_Move) == 0x000048, "Wrong size on UKSC_Move");
static_assert(offsetof(UKSC_Move, Owner_) == 0x000030, "Member 'UKSC_Move::Owner_' has a wrong offset!");

// Class KuroSimpleCombat.KSC_Move_Spline
// 0x0010 (0x0058 - 0x0048)
class UKSC_Move_Spline final : public UKSC_Move
{
public:
	uint8                                         Pad_48[0x10];                                      // 0x0048(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetSpline(class USplineComponent* SplineComp);
	void SetSplineWide(const float Width);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KSC_Move_Spline">();
	}
	static class UKSC_Move_Spline* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKSC_Move_Spline>();
	}
};
static_assert(alignof(UKSC_Move_Spline) == 0x000008, "Wrong alignment on UKSC_Move_Spline");
static_assert(sizeof(UKSC_Move_Spline) == 0x000058, "Wrong size on UKSC_Move_Spline");

// Class KuroSimpleCombat.KSC_DA_Move_Spline
// 0x0000 (0x0048 - 0x0048)
class UKSC_DA_Move_Spline final : public UKSC_DA_Move
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KSC_DA_Move_Spline">();
	}
	static class UKSC_DA_Move_Spline* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKSC_DA_Move_Spline>();
	}
};
static_assert(alignof(UKSC_DA_Move_Spline) == 0x000008, "Wrong alignment on UKSC_DA_Move_Spline");
static_assert(sizeof(UKSC_DA_Move_Spline) == 0x000048, "Wrong size on UKSC_DA_Move_Spline");

// Class KuroSimpleCombat.KSC_DA_Move_Straight
// 0x0000 (0x0048 - 0x0048)
class UKSC_DA_Move_Straight final : public UKSC_DA_Move
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KSC_DA_Move_Straight">();
	}
	static class UKSC_DA_Move_Straight* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKSC_DA_Move_Straight>();
	}
};
static_assert(alignof(UKSC_DA_Move_Straight) == 0x000008, "Wrong alignment on UKSC_DA_Move_Straight");
static_assert(sizeof(UKSC_DA_Move_Straight) == 0x000048, "Wrong size on UKSC_DA_Move_Straight");

// Class KuroSimpleCombat.KSC_DA_Move_Follow
// 0x0000 (0x0048 - 0x0048)
class UKSC_DA_Move_Follow final : public UKSC_DA_Move
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KSC_DA_Move_Follow">();
	}
	static class UKSC_DA_Move_Follow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKSC_DA_Move_Follow>();
	}
};
static_assert(alignof(UKSC_DA_Move_Follow) == 0x000008, "Wrong alignment on UKSC_DA_Move_Follow");
static_assert(sizeof(UKSC_DA_Move_Follow) == 0x000048, "Wrong size on UKSC_DA_Move_Follow");

// Class KuroSimpleCombat.KSC_Skill_ChainAttack
// 0x0018 (0x0080 - 0x0068)
class UKSC_Skill_ChainAttack final : public UKSC_Skill
{
public:
	uint8                                         Pad_68[0x8];                                       // 0x0068(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UKSC_Entity*>                    Targets_;                                          // 0x0070(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KSC_Skill_ChainAttack">();
	}
	static class UKSC_Skill_ChainAttack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKSC_Skill_ChainAttack>();
	}
};
static_assert(alignof(UKSC_Skill_ChainAttack) == 0x000008, "Wrong alignment on UKSC_Skill_ChainAttack");
static_assert(sizeof(UKSC_Skill_ChainAttack) == 0x000080, "Wrong size on UKSC_Skill_ChainAttack");
static_assert(offsetof(UKSC_Skill_ChainAttack, Targets_) == 0x000070, "Member 'UKSC_Skill_ChainAttack::Targets_' has a wrong offset!");

// Class KuroSimpleCombat.KSC_DA_Skill_Attack
// 0x0020 (0x0078 - 0x0058)
class UKSC_DA_Skill_Attack final : public UKSC_DA_Skill
{
public:
	struct FKSCDamage                             Damage;                                            // 0x0058(0x0002)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_5A[0x6];                                       // 0x005A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UKSC_DA_Buff*                           AddBuff;                                           // 0x0060(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UKSC_DA_FX*                             SkillFX;                                           // 0x0068(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UKSC_DA_FX*                             HitFX;                                             // 0x0070(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KSC_DA_Skill_Attack">();
	}
	static class UKSC_DA_Skill_Attack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKSC_DA_Skill_Attack>();
	}
};
static_assert(alignof(UKSC_DA_Skill_Attack) == 0x000008, "Wrong alignment on UKSC_DA_Skill_Attack");
static_assert(sizeof(UKSC_DA_Skill_Attack) == 0x000078, "Wrong size on UKSC_DA_Skill_Attack");
static_assert(offsetof(UKSC_DA_Skill_Attack, Damage) == 0x000058, "Member 'UKSC_DA_Skill_Attack::Damage' has a wrong offset!");
static_assert(offsetof(UKSC_DA_Skill_Attack, AddBuff) == 0x000060, "Member 'UKSC_DA_Skill_Attack::AddBuff' has a wrong offset!");
static_assert(offsetof(UKSC_DA_Skill_Attack, SkillFX) == 0x000068, "Member 'UKSC_DA_Skill_Attack::SkillFX' has a wrong offset!");
static_assert(offsetof(UKSC_DA_Skill_Attack, HitFX) == 0x000070, "Member 'UKSC_DA_Skill_Attack::HitFX' has a wrong offset!");

// Class KuroSimpleCombat.KSC_DA_Skill_MultiAttack
// 0x0020 (0x0078 - 0x0058)
class UKSC_DA_Skill_MultiAttack final : public UKSC_DA_Skill
{
public:
	struct FKSCDamage                             Damage;                                            // 0x0058(0x0002)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_5A[0x2];                                       // 0x005A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MultiNum;                                          // 0x005C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UKSC_DA_Buff*                           AddBuff;                                           // 0x0060(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UKSC_DA_FX*                             SkillFX;                                           // 0x0068(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UKSC_DA_FX*                             HitFX;                                             // 0x0070(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KSC_DA_Skill_MultiAttack">();
	}
	static class UKSC_DA_Skill_MultiAttack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKSC_DA_Skill_MultiAttack>();
	}
};
static_assert(alignof(UKSC_DA_Skill_MultiAttack) == 0x000008, "Wrong alignment on UKSC_DA_Skill_MultiAttack");
static_assert(sizeof(UKSC_DA_Skill_MultiAttack) == 0x000078, "Wrong size on UKSC_DA_Skill_MultiAttack");
static_assert(offsetof(UKSC_DA_Skill_MultiAttack, Damage) == 0x000058, "Member 'UKSC_DA_Skill_MultiAttack::Damage' has a wrong offset!");
static_assert(offsetof(UKSC_DA_Skill_MultiAttack, MultiNum) == 0x00005C, "Member 'UKSC_DA_Skill_MultiAttack::MultiNum' has a wrong offset!");
static_assert(offsetof(UKSC_DA_Skill_MultiAttack, AddBuff) == 0x000060, "Member 'UKSC_DA_Skill_MultiAttack::AddBuff' has a wrong offset!");
static_assert(offsetof(UKSC_DA_Skill_MultiAttack, SkillFX) == 0x000068, "Member 'UKSC_DA_Skill_MultiAttack::SkillFX' has a wrong offset!");
static_assert(offsetof(UKSC_DA_Skill_MultiAttack, HitFX) == 0x000070, "Member 'UKSC_DA_Skill_MultiAttack::HitFX' has a wrong offset!");

// Class KuroSimpleCombat.KSC_DA_Skill_ChainAttack
// 0x0020 (0x0078 - 0x0058)
class UKSC_DA_Skill_ChainAttack final : public UKSC_DA_Skill
{
public:
	struct FKSCDamage                             Damage;                                            // 0x0058(0x0002)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_5A[0x2];                                       // 0x005A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ChainNum;                                          // 0x005C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UKSC_DA_Buff*                           AddBuff;                                           // 0x0060(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UKSC_DA_FX*                             SkillFX;                                           // 0x0068(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UKSC_DA_FX*                             HitFX;                                             // 0x0070(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KSC_DA_Skill_ChainAttack">();
	}
	static class UKSC_DA_Skill_ChainAttack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKSC_DA_Skill_ChainAttack>();
	}
};
static_assert(alignof(UKSC_DA_Skill_ChainAttack) == 0x000008, "Wrong alignment on UKSC_DA_Skill_ChainAttack");
static_assert(sizeof(UKSC_DA_Skill_ChainAttack) == 0x000078, "Wrong size on UKSC_DA_Skill_ChainAttack");
static_assert(offsetof(UKSC_DA_Skill_ChainAttack, Damage) == 0x000058, "Member 'UKSC_DA_Skill_ChainAttack::Damage' has a wrong offset!");
static_assert(offsetof(UKSC_DA_Skill_ChainAttack, ChainNum) == 0x00005C, "Member 'UKSC_DA_Skill_ChainAttack::ChainNum' has a wrong offset!");
static_assert(offsetof(UKSC_DA_Skill_ChainAttack, AddBuff) == 0x000060, "Member 'UKSC_DA_Skill_ChainAttack::AddBuff' has a wrong offset!");
static_assert(offsetof(UKSC_DA_Skill_ChainAttack, SkillFX) == 0x000068, "Member 'UKSC_DA_Skill_ChainAttack::SkillFX' has a wrong offset!");
static_assert(offsetof(UKSC_DA_Skill_ChainAttack, HitFX) == 0x000070, "Member 'UKSC_DA_Skill_ChainAttack::HitFX' has a wrong offset!");

// Class KuroSimpleCombat.KSC_DA_Skill_RangeAttack
// 0x0050 (0x00A8 - 0x0058)
class UKSC_DA_Skill_RangeAttack final : public UKSC_DA_Skill
{
public:
	struct FKSCDamage                             Damage;                                            // 0x0058(0x0002)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_5A[0x6];                                       // 0x005A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UKSC_DA_Buff*                           AddBuff;                                           // 0x0060(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EKSC_ShapeType                                RangeAttackShapeType;                              // 0x0068(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x3];                                       // 0x0069(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Offset;                                            // 0x006C(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HalfExtent;                                        // 0x0078(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rot;                                               // 0x0084(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0090(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UKSC_DA_FX*                             SkillFX;                                           // 0x0098(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UKSC_DA_FX*                             HitFX;                                             // 0x00A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KSC_DA_Skill_RangeAttack">();
	}
	static class UKSC_DA_Skill_RangeAttack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKSC_DA_Skill_RangeAttack>();
	}
};
static_assert(alignof(UKSC_DA_Skill_RangeAttack) == 0x000008, "Wrong alignment on UKSC_DA_Skill_RangeAttack");
static_assert(sizeof(UKSC_DA_Skill_RangeAttack) == 0x0000A8, "Wrong size on UKSC_DA_Skill_RangeAttack");
static_assert(offsetof(UKSC_DA_Skill_RangeAttack, Damage) == 0x000058, "Member 'UKSC_DA_Skill_RangeAttack::Damage' has a wrong offset!");
static_assert(offsetof(UKSC_DA_Skill_RangeAttack, AddBuff) == 0x000060, "Member 'UKSC_DA_Skill_RangeAttack::AddBuff' has a wrong offset!");
static_assert(offsetof(UKSC_DA_Skill_RangeAttack, RangeAttackShapeType) == 0x000068, "Member 'UKSC_DA_Skill_RangeAttack::RangeAttackShapeType' has a wrong offset!");
static_assert(offsetof(UKSC_DA_Skill_RangeAttack, Offset) == 0x00006C, "Member 'UKSC_DA_Skill_RangeAttack::Offset' has a wrong offset!");
static_assert(offsetof(UKSC_DA_Skill_RangeAttack, HalfExtent) == 0x000078, "Member 'UKSC_DA_Skill_RangeAttack::HalfExtent' has a wrong offset!");
static_assert(offsetof(UKSC_DA_Skill_RangeAttack, Rot) == 0x000084, "Member 'UKSC_DA_Skill_RangeAttack::Rot' has a wrong offset!");
static_assert(offsetof(UKSC_DA_Skill_RangeAttack, Radius) == 0x000090, "Member 'UKSC_DA_Skill_RangeAttack::Radius' has a wrong offset!");
static_assert(offsetof(UKSC_DA_Skill_RangeAttack, SkillFX) == 0x000098, "Member 'UKSC_DA_Skill_RangeAttack::SkillFX' has a wrong offset!");
static_assert(offsetof(UKSC_DA_Skill_RangeAttack, HitFX) == 0x0000A0, "Member 'UKSC_DA_Skill_RangeAttack::HitFX' has a wrong offset!");

// Class KuroSimpleCombat.KSC_Move_Straight
// 0x0000 (0x0048 - 0x0048)
class UKSC_Move_Straight final : public UKSC_Move
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KSC_Move_Straight">();
	}
	static class UKSC_Move_Straight* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKSC_Move_Straight>();
	}
};
static_assert(alignof(UKSC_Move_Straight) == 0x000008, "Wrong alignment on UKSC_Move_Straight");
static_assert(sizeof(UKSC_Move_Straight) == 0x000048, "Wrong size on UKSC_Move_Straight");

// Class KuroSimpleCombat.KSC_DA_FX
// 0x0010 (0x0048 - 0x0038)
class UKSC_DA_FX final : public UDataAsset
{
public:
	EKSC_FXType                                   FXType;                                            // 0x0038(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraSystem*                         FX;                                                // 0x0040(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KSC_DA_FX">();
	}
	static class UKSC_DA_FX* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKSC_DA_FX>();
	}
};
static_assert(alignof(UKSC_DA_FX) == 0x000008, "Wrong alignment on UKSC_DA_FX");
static_assert(sizeof(UKSC_DA_FX) == 0x000048, "Wrong size on UKSC_DA_FX");
static_assert(offsetof(UKSC_DA_FX, FXType) == 0x000038, "Member 'UKSC_DA_FX::FXType' has a wrong offset!");
static_assert(offsetof(UKSC_DA_FX, FX) == 0x000040, "Member 'UKSC_DA_FX::FX' has a wrong offset!");

// Class KuroSimpleCombat.KSC_Skill_RangeAttack
// 0x0028 (0x0090 - 0x0068)
class UKSC_Skill_RangeAttack final : public UKSC_Skill
{
public:
	class UKSC_DA_Skill_RangeAttack*              DaSkillRangeAttack_;                               // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UKSC_Entity*>                    Targets_;                                          // 0x0070(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_80[0x10];                                      // 0x0080(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KSC_Skill_RangeAttack">();
	}
	static class UKSC_Skill_RangeAttack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKSC_Skill_RangeAttack>();
	}
};
static_assert(alignof(UKSC_Skill_RangeAttack) == 0x000008, "Wrong alignment on UKSC_Skill_RangeAttack");
static_assert(sizeof(UKSC_Skill_RangeAttack) == 0x000090, "Wrong size on UKSC_Skill_RangeAttack");
static_assert(offsetof(UKSC_Skill_RangeAttack, DaSkillRangeAttack_) == 0x000068, "Member 'UKSC_Skill_RangeAttack::DaSkillRangeAttack_' has a wrong offset!");
static_assert(offsetof(UKSC_Skill_RangeAttack, Targets_) == 0x000070, "Member 'UKSC_Skill_RangeAttack::Targets_' has a wrong offset!");

// Class KuroSimpleCombat.KSC_DA_Skill_Projectile
// 0x0008 (0x0060 - 0x0058)
class UKSC_DA_Skill_Projectile final : public UKSC_DA_Skill
{
public:
	class UKSC_DA_Entity_Projectile*              Projectile;                                        // 0x0058(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KSC_DA_Skill_Projectile">();
	}
	static class UKSC_DA_Skill_Projectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKSC_DA_Skill_Projectile>();
	}
};
static_assert(alignof(UKSC_DA_Skill_Projectile) == 0x000008, "Wrong alignment on UKSC_DA_Skill_Projectile");
static_assert(sizeof(UKSC_DA_Skill_Projectile) == 0x000060, "Wrong size on UKSC_DA_Skill_Projectile");
static_assert(offsetof(UKSC_DA_Skill_Projectile, Projectile) == 0x000058, "Member 'UKSC_DA_Skill_Projectile::Projectile' has a wrong offset!");

// Class KuroSimpleCombat.KSC_DA_Buff_Period
// 0x0008 (0x0050 - 0x0048)
class UKSC_DA_Buff_Period : public UKSC_DA_Buff
{
public:
	float                                         Period;                                            // 0x0048(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KSC_DA_Buff_Period">();
	}
	static class UKSC_DA_Buff_Period* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKSC_DA_Buff_Period>();
	}
};
static_assert(alignof(UKSC_DA_Buff_Period) == 0x000008, "Wrong alignment on UKSC_DA_Buff_Period");
static_assert(sizeof(UKSC_DA_Buff_Period) == 0x000050, "Wrong size on UKSC_DA_Buff_Period");
static_assert(offsetof(UKSC_DA_Buff_Period, Period) == 0x000048, "Member 'UKSC_DA_Buff_Period::Period' has a wrong offset!");

// Class KuroSimpleCombat.KSC_DA_Buff_Period_Damage
// 0x0010 (0x0060 - 0x0050)
class UKSC_DA_Buff_Period_Damage final : public UKSC_DA_Buff_Period
{
public:
	struct FKSCDamage                             Damage;                                            // 0x0050(0x0002)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_52[0x6];                                       // 0x0052(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UKSC_DA_FX*                             HitFX;                                             // 0x0058(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KSC_DA_Buff_Period_Damage">();
	}
	static class UKSC_DA_Buff_Period_Damage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKSC_DA_Buff_Period_Damage>();
	}
};
static_assert(alignof(UKSC_DA_Buff_Period_Damage) == 0x000008, "Wrong alignment on UKSC_DA_Buff_Period_Damage");
static_assert(sizeof(UKSC_DA_Buff_Period_Damage) == 0x000060, "Wrong size on UKSC_DA_Buff_Period_Damage");
static_assert(offsetof(UKSC_DA_Buff_Period_Damage, Damage) == 0x000050, "Member 'UKSC_DA_Buff_Period_Damage::Damage' has a wrong offset!");
static_assert(offsetof(UKSC_DA_Buff_Period_Damage, HitFX) == 0x000058, "Member 'UKSC_DA_Buff_Period_Damage::HitFX' has a wrong offset!");

// Class KuroSimpleCombat.KSCDelegateBase
// 0x0000 (0x0030 - 0x0030)
class UKSCDelegateBase : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KSCDelegateBase">();
	}
	static class UKSCDelegateBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKSCDelegateBase>();
	}
};
static_assert(alignof(UKSCDelegateBase) == 0x000008, "Wrong alignment on UKSCDelegateBase");
static_assert(sizeof(UKSCDelegateBase) == 0x000030, "Wrong size on UKSCDelegateBase");

// Class KuroSimpleCombat.KSCDelegateCommon
// 0x0040 (0x0070 - 0x0030)
class UKSCDelegateCommon final : public UKSCDelegateBase
{
public:
	uint8                                         Pad_30[0x40];                                      // 0x0030(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UKSCDelegateCommon* GetOrAddDelegate();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KSCDelegateCommon">();
	}
	static class UKSCDelegateCommon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKSCDelegateCommon>();
	}
};
static_assert(alignof(UKSCDelegateCommon) == 0x000008, "Wrong alignment on UKSCDelegateCommon");
static_assert(sizeof(UKSCDelegateCommon) == 0x000070, "Wrong size on UKSCDelegateCommon");

// Class KuroSimpleCombat.KSC_Entity
// 0x0160 (0x0190 - 0x0030)
class alignas(0x10) UKSC_Entity : public UObject
{
public:
	class UKSC_Move*                              Move_;                                             // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UKSC_Skill*>                     Skills_;                                           // 0x0038(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TMap<TSubclassOf<class UKSC_Buff>, class UKSC_Buff*> Buffs_;                                     // 0x0048(0x0050)(Protected, NativeAccessSpecifierProtected)
	TMap<TSubclassOf<class UKSC_Buff>, class UKSC_Buff*> ToRemoveBuffs_;                             // 0x0098(0x0050)(Protected, NativeAccessSpecifierProtected)
	class UKSC_AttrSet*                           AttrSet_;                                          // 0x00E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F0[0x60];                                      // 0x00F0(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 RenderActor_;                                      // 0x0150(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_158[0x38];                                     // 0x0158(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UKSC_Move* GetMoveComponent();
	void SetFaction(EKSC_Faction Faction);
	void SetHP(int32 Value);

	class UKSC_AttrSet* GetAttrComponent() const;
	int32 GetHP() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KSC_Entity">();
	}
	static class UKSC_Entity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKSC_Entity>();
	}
};
static_assert(alignof(UKSC_Entity) == 0x000010, "Wrong alignment on UKSC_Entity");
static_assert(sizeof(UKSC_Entity) == 0x000190, "Wrong size on UKSC_Entity");
static_assert(offsetof(UKSC_Entity, Move_) == 0x000030, "Member 'UKSC_Entity::Move_' has a wrong offset!");
static_assert(offsetof(UKSC_Entity, Skills_) == 0x000038, "Member 'UKSC_Entity::Skills_' has a wrong offset!");
static_assert(offsetof(UKSC_Entity, Buffs_) == 0x000048, "Member 'UKSC_Entity::Buffs_' has a wrong offset!");
static_assert(offsetof(UKSC_Entity, ToRemoveBuffs_) == 0x000098, "Member 'UKSC_Entity::ToRemoveBuffs_' has a wrong offset!");
static_assert(offsetof(UKSC_Entity, AttrSet_) == 0x0000E8, "Member 'UKSC_Entity::AttrSet_' has a wrong offset!");
static_assert(offsetof(UKSC_Entity, RenderActor_) == 0x000150, "Member 'UKSC_Entity::RenderActor_' has a wrong offset!");

// Class KuroSimpleCombat.KSC_Move_Follow
// 0x0020 (0x0068 - 0x0048)
class UKSC_Move_Follow final : public UKSC_Move
{
public:
	uint8                                         Pad_48[0x20];                                      // 0x0048(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KSC_Move_Follow">();
	}
	static class UKSC_Move_Follow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKSC_Move_Follow>();
	}
};
static_assert(alignof(UKSC_Move_Follow) == 0x000008, "Wrong alignment on UKSC_Move_Follow");
static_assert(sizeof(UKSC_Move_Follow) == 0x000068, "Wrong size on UKSC_Move_Follow");

// Class KuroSimpleCombat.KSC_Projectile
// 0x0010 (0x01A0 - 0x0190)
class UKSC_Projectile final : public UKSC_Entity
{
public:
	uint8                                         Pad_190[0x10];                                     // 0x0190(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KSC_Projectile">();
	}
	static class UKSC_Projectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKSC_Projectile>();
	}
};
static_assert(alignof(UKSC_Projectile) == 0x000010, "Wrong alignment on UKSC_Projectile");
static_assert(sizeof(UKSC_Projectile) == 0x0001A0, "Wrong size on UKSC_Projectile");

// Class KuroSimpleCombat.KSC_Skill_Attack
// 0x0008 (0x0070 - 0x0068)
class UKSC_Skill_Attack final : public UKSC_Skill
{
public:
	uint8                                         Pad_68[0x8];                                       // 0x0068(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KSC_Skill_Attack">();
	}
	static class UKSC_Skill_Attack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKSC_Skill_Attack>();
	}
};
static_assert(alignof(UKSC_Skill_Attack) == 0x000008, "Wrong alignment on UKSC_Skill_Attack");
static_assert(sizeof(UKSC_Skill_Attack) == 0x000070, "Wrong size on UKSC_Skill_Attack");

// Class KuroSimpleCombat.KSC_Skill_MultiAttack
// 0x0018 (0x0080 - 0x0068)
class UKSC_Skill_MultiAttack final : public UKSC_Skill
{
public:
	uint8                                         Pad_68[0x8];                                       // 0x0068(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UKSC_Entity*>                    Targets_;                                          // 0x0070(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KSC_Skill_MultiAttack">();
	}
	static class UKSC_Skill_MultiAttack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKSC_Skill_MultiAttack>();
	}
};
static_assert(alignof(UKSC_Skill_MultiAttack) == 0x000008, "Wrong alignment on UKSC_Skill_MultiAttack");
static_assert(sizeof(UKSC_Skill_MultiAttack) == 0x000080, "Wrong size on UKSC_Skill_MultiAttack");
static_assert(offsetof(UKSC_Skill_MultiAttack, Targets_) == 0x000070, "Member 'UKSC_Skill_MultiAttack::Targets_' has a wrong offset!");

// Class KuroSimpleCombat.KSC_Skill_Projectile
// 0x0008 (0x0070 - 0x0068)
class UKSC_Skill_Projectile final : public UKSC_Skill
{
public:
	uint8                                         Pad_68[0x8];                                       // 0x0068(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KSC_Skill_Projectile">();
	}
	static class UKSC_Skill_Projectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKSC_Skill_Projectile>();
	}
};
static_assert(alignof(UKSC_Skill_Projectile) == 0x000008, "Wrong alignment on UKSC_Skill_Projectile");
static_assert(sizeof(UKSC_Skill_Projectile) == 0x000070, "Wrong size on UKSC_Skill_Projectile");

// Class KuroSimpleCombat.KSC_World
// 0x0180 (0x01B0 - 0x0030)
class UKSC_World final : public UObject
{
public:
	TArray<class UKSC_Entity*>                    Entities_;                                         // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UKSC_Entity*>                    ToRemoveEntities_;                                 // 0x0040(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UKSC_Entity*>                    ToAddEntities_;                                    // 0x0050(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<class UKSC_Entity*, class AActor*>       RenderActorMap_;                                   // 0x0060(0x0050)(NativeAccessSpecifierPublic)
	TMap<class UKSC_DA_EntityRender*, class AActor*> SharedRenderActorDaMap_;                        // 0x00B0(0x0050)(NativeAccessSpecifierPublic)
	uint8                                         Pad_100[0x10];                                     // 0x0100(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class UClass*, struct FKSC_ObjectPoll>   Pools_;                                            // 0x0110(0x0050)(NativeAccessSpecifierPrivate)
	TSet<class UObject*>                          PoolHelper_;                                       // 0x0160(0x0050)(NativeAccessSpecifierPrivate)

public:
	class UKSC_Entity* AddDaEntity(class UKSC_DA_Entity* DaEntity, const struct FTransform& Transform);
	void RemoveEntity(class UKSC_Entity* Entity);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KSC_World">();
	}
	static class UKSC_World* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKSC_World>();
	}
};
static_assert(alignof(UKSC_World) == 0x000008, "Wrong alignment on UKSC_World");
static_assert(sizeof(UKSC_World) == 0x0001B0, "Wrong size on UKSC_World");
static_assert(offsetof(UKSC_World, Entities_) == 0x000030, "Member 'UKSC_World::Entities_' has a wrong offset!");
static_assert(offsetof(UKSC_World, ToRemoveEntities_) == 0x000040, "Member 'UKSC_World::ToRemoveEntities_' has a wrong offset!");
static_assert(offsetof(UKSC_World, ToAddEntities_) == 0x000050, "Member 'UKSC_World::ToAddEntities_' has a wrong offset!");
static_assert(offsetof(UKSC_World, RenderActorMap_) == 0x000060, "Member 'UKSC_World::RenderActorMap_' has a wrong offset!");
static_assert(offsetof(UKSC_World, SharedRenderActorDaMap_) == 0x0000B0, "Member 'UKSC_World::SharedRenderActorDaMap_' has a wrong offset!");
static_assert(offsetof(UKSC_World, Pools_) == 0x000110, "Member 'UKSC_World::Pools_' has a wrong offset!");
static_assert(offsetof(UKSC_World, PoolHelper_) == 0x000160, "Member 'UKSC_World::PoolHelper_' has a wrong offset!");

// Class KuroSimpleCombat.KuroSimpleCombatSubsystem
// 0x0010 (0x0048 - 0x0038)
class UKuroSimpleCombatSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UKSC_World*                             world;                                             // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class UKSC_World* CreateWorld();
	void DestoryWorld();
	void EntityBeginCastProxy(uint32 EntityId, TSubclassOf<class UKSC_Entity> EntityClass, const struct FTransform& EntityTransform, TSubclassOf<class UKSC_Skill> SkillClass);
	void EntityHitProxy(uint32 FromEntityId, TSubclassOf<class UKSC_Entity> FromEntityClass, uint32 ToEntityId, TSubclassOf<class UKSC_Entity> ToEntityClass, const struct FTransform& HitTransform);
	void EntityInitProxy(uint32 EntityId, TSubclassOf<class UKSC_Entity> EntityClass, const struct FTransform& EntityTransform);
	void EntityUninitProxy(uint32 EntityId, TSubclassOf<class UKSC_Entity> EntityClass);
	class UKSC_World* GetKSCWorld();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroSimpleCombatSubsystem">();
	}
	static class UKuroSimpleCombatSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroSimpleCombatSubsystem>();
	}
};
static_assert(alignof(UKuroSimpleCombatSubsystem) == 0x000008, "Wrong alignment on UKuroSimpleCombatSubsystem");
static_assert(sizeof(UKuroSimpleCombatSubsystem) == 0x000048, "Wrong size on UKuroSimpleCombatSubsystem");
static_assert(offsetof(UKuroSimpleCombatSubsystem, world) == 0x000040, "Member 'UKuroSimpleCombatSubsystem::world' has a wrong offset!");

}


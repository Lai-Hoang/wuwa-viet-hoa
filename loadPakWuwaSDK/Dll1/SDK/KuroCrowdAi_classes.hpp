#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: KuroCrowdAi

#include "Basic.hpp"

#include "KuroCrowdAi_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "Engine_classes.hpp"


namespace SDK
{

// Class KuroCrowdAi.KuroCrowdAiBoidAnimUpdater
// 0x0240 (0x0270 - 0x0030)
class UKuroCrowdAiBoidAnimUpdater final : public UObject
{
public:
	uint8                                         Pad_30[0x240];                                     // 0x0030(0x0240)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FMontageSectionInfoItem GetMontageSectionInfo(int32 AnimIndex, class FName SectionName);
	bool PlayMontage(int32 AnimIndex, float PlayRate, float StartPos, bool bIsLoop);
	bool SetMontageNextSection(int32 AnimIndex, class FName FromSection, class FName ToSection);
	bool SetMontagePlayRate(int32 AnimIndex, float NewPlayRate);
	bool SetMontagePosition(int32 AnimIndex, float NewPosition);
	bool StopMontage(int32 AnimIndex, bool bImmediately);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroCrowdAiBoidAnimUpdater">();
	}
	static class UKuroCrowdAiBoidAnimUpdater* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroCrowdAiBoidAnimUpdater>();
	}
};
static_assert(alignof(UKuroCrowdAiBoidAnimUpdater) == 0x000008, "Wrong alignment on UKuroCrowdAiBoidAnimUpdater");
static_assert(sizeof(UKuroCrowdAiBoidAnimUpdater) == 0x000270, "Wrong size on UKuroCrowdAiBoidAnimUpdater");

// Class KuroCrowdAi.KuroCrowdAiBoidActorSystem
// 0x0530 (0x0800 - 0x02D0)
class AKuroCrowdAiBoidActorSystem : public ABakedBoneMeshActor
{
public:
	class UBakedBoneMeshComponent*                BakedBoneMeshComp;                                 // 0x02D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UKuroMaterialControllerComponent*       MaterialControllerComp;                            // 0x02D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxBoidCount;                                      // 0x02E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x02E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HalfHeight;                                        // 0x02E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EC[0x4];                                      // 0x02EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             RelativeTrans;                                     // 0x02F0(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         MaxSpeed;                                          // 0x0320(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAccel;                                          // 0x0324(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroundFriction;                                    // 0x0328(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovingRadiusFactor;                                // 0x032C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnThresholdSpeed;                                // 0x0330(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnInterpSpeed;                                   // 0x0334(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FleeRadius;                                        // 0x0338(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovingFleeRadiusFactor;                            // 0x033C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArrivalRadius;                                     // 0x0340(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinDistToNavEdge;                                  // 0x0344(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExtraQueryOffset;                                  // 0x0348(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdlePerformMinCD;                                  // 0x034C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdlePerformMaxCD;                                  // 0x0350(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdlePerformMaxPortion;                             // 0x0354(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_358[0x8];                                      // 0x0358(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, int32>                            BoidIdToInstanceIdMap;                             // 0x0360(0x0050)(Edit, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B0[0x2F8];                                    // 0x03B0(0x02F8)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class UKuroCrowdAiBoidAnimUpdater*>      AllocatedAnimUpdater;                              // 0x06A8(0x0050)(NativeAccessSpecifierPrivate)
	TMap<int32, EKuroCrowdAiBoidAnimState>        AnimStateConfig;                                   // 0x06F8(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FKuroCrowdAiAnimSequenceConfig> AnimSequenceConfig;                                // 0x0748(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<class UKuroMaterialControllerDataAsset*, int32> MaterialEffectWithTextureConfig;            // 0x0758(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         Pad_7A8[0x58];                                     // 0x07A8(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool InitGpuNpc();
	int32 SpawnBoidActor(const struct FTransform& InTransform, bool bForce);
	void SwitchBoidToPerformState(int32 BoidId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroCrowdAiBoidActorSystem">();
	}
	static class AKuroCrowdAiBoidActorSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKuroCrowdAiBoidActorSystem>();
	}
};
static_assert(alignof(AKuroCrowdAiBoidActorSystem) == 0x000010, "Wrong alignment on AKuroCrowdAiBoidActorSystem");
static_assert(sizeof(AKuroCrowdAiBoidActorSystem) == 0x000800, "Wrong size on AKuroCrowdAiBoidActorSystem");
static_assert(offsetof(AKuroCrowdAiBoidActorSystem, BakedBoneMeshComp) == 0x0002D0, "Member 'AKuroCrowdAiBoidActorSystem::BakedBoneMeshComp' has a wrong offset!");
static_assert(offsetof(AKuroCrowdAiBoidActorSystem, MaterialControllerComp) == 0x0002D8, "Member 'AKuroCrowdAiBoidActorSystem::MaterialControllerComp' has a wrong offset!");
static_assert(offsetof(AKuroCrowdAiBoidActorSystem, MaxBoidCount) == 0x0002E0, "Member 'AKuroCrowdAiBoidActorSystem::MaxBoidCount' has a wrong offset!");
static_assert(offsetof(AKuroCrowdAiBoidActorSystem, Radius) == 0x0002E4, "Member 'AKuroCrowdAiBoidActorSystem::Radius' has a wrong offset!");
static_assert(offsetof(AKuroCrowdAiBoidActorSystem, HalfHeight) == 0x0002E8, "Member 'AKuroCrowdAiBoidActorSystem::HalfHeight' has a wrong offset!");
static_assert(offsetof(AKuroCrowdAiBoidActorSystem, RelativeTrans) == 0x0002F0, "Member 'AKuroCrowdAiBoidActorSystem::RelativeTrans' has a wrong offset!");
static_assert(offsetof(AKuroCrowdAiBoidActorSystem, MaxSpeed) == 0x000320, "Member 'AKuroCrowdAiBoidActorSystem::MaxSpeed' has a wrong offset!");
static_assert(offsetof(AKuroCrowdAiBoidActorSystem, MaxAccel) == 0x000324, "Member 'AKuroCrowdAiBoidActorSystem::MaxAccel' has a wrong offset!");
static_assert(offsetof(AKuroCrowdAiBoidActorSystem, GroundFriction) == 0x000328, "Member 'AKuroCrowdAiBoidActorSystem::GroundFriction' has a wrong offset!");
static_assert(offsetof(AKuroCrowdAiBoidActorSystem, MovingRadiusFactor) == 0x00032C, "Member 'AKuroCrowdAiBoidActorSystem::MovingRadiusFactor' has a wrong offset!");
static_assert(offsetof(AKuroCrowdAiBoidActorSystem, TurnThresholdSpeed) == 0x000330, "Member 'AKuroCrowdAiBoidActorSystem::TurnThresholdSpeed' has a wrong offset!");
static_assert(offsetof(AKuroCrowdAiBoidActorSystem, TurnInterpSpeed) == 0x000334, "Member 'AKuroCrowdAiBoidActorSystem::TurnInterpSpeed' has a wrong offset!");
static_assert(offsetof(AKuroCrowdAiBoidActorSystem, FleeRadius) == 0x000338, "Member 'AKuroCrowdAiBoidActorSystem::FleeRadius' has a wrong offset!");
static_assert(offsetof(AKuroCrowdAiBoidActorSystem, MovingFleeRadiusFactor) == 0x00033C, "Member 'AKuroCrowdAiBoidActorSystem::MovingFleeRadiusFactor' has a wrong offset!");
static_assert(offsetof(AKuroCrowdAiBoidActorSystem, ArrivalRadius) == 0x000340, "Member 'AKuroCrowdAiBoidActorSystem::ArrivalRadius' has a wrong offset!");
static_assert(offsetof(AKuroCrowdAiBoidActorSystem, MinDistToNavEdge) == 0x000344, "Member 'AKuroCrowdAiBoidActorSystem::MinDistToNavEdge' has a wrong offset!");
static_assert(offsetof(AKuroCrowdAiBoidActorSystem, ExtraQueryOffset) == 0x000348, "Member 'AKuroCrowdAiBoidActorSystem::ExtraQueryOffset' has a wrong offset!");
static_assert(offsetof(AKuroCrowdAiBoidActorSystem, IdlePerformMinCD) == 0x00034C, "Member 'AKuroCrowdAiBoidActorSystem::IdlePerformMinCD' has a wrong offset!");
static_assert(offsetof(AKuroCrowdAiBoidActorSystem, IdlePerformMaxCD) == 0x000350, "Member 'AKuroCrowdAiBoidActorSystem::IdlePerformMaxCD' has a wrong offset!");
static_assert(offsetof(AKuroCrowdAiBoidActorSystem, IdlePerformMaxPortion) == 0x000354, "Member 'AKuroCrowdAiBoidActorSystem::IdlePerformMaxPortion' has a wrong offset!");
static_assert(offsetof(AKuroCrowdAiBoidActorSystem, BoidIdToInstanceIdMap) == 0x000360, "Member 'AKuroCrowdAiBoidActorSystem::BoidIdToInstanceIdMap' has a wrong offset!");
static_assert(offsetof(AKuroCrowdAiBoidActorSystem, AllocatedAnimUpdater) == 0x0006A8, "Member 'AKuroCrowdAiBoidActorSystem::AllocatedAnimUpdater' has a wrong offset!");
static_assert(offsetof(AKuroCrowdAiBoidActorSystem, AnimStateConfig) == 0x0006F8, "Member 'AKuroCrowdAiBoidActorSystem::AnimStateConfig' has a wrong offset!");
static_assert(offsetof(AKuroCrowdAiBoidActorSystem, AnimSequenceConfig) == 0x000748, "Member 'AKuroCrowdAiBoidActorSystem::AnimSequenceConfig' has a wrong offset!");
static_assert(offsetof(AKuroCrowdAiBoidActorSystem, MaterialEffectWithTextureConfig) == 0x000758, "Member 'AKuroCrowdAiBoidActorSystem::MaterialEffectWithTextureConfig' has a wrong offset!");

// Class KuroCrowdAi.KuroCrowdAiBoidComponent
// 0x0180 (0x0240 - 0x00C0)
class UKuroCrowdAiBoidComponent final : public UActorComponent
{
public:
	uint8                                         Pad_C0[0x8];                                       // 0x00C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        UpdatedComponent;                                  // 0x00C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, DuplicateTransient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BoidId;                                            // 0x00D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GroupId;                                           // 0x00D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WatchingBoidId;                                    // 0x00D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DC[0x4];                                       // 0x00DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Transform;                                         // 0x00E0(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, Transient, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Velocity;                                          // 0x0110(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Steering;                                          // 0x011C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Gravity;                                           // 0x0128(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_134[0xC];                                      // 0x0134(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             LastTransform;                                     // 0x0140(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, Transient, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                LastVelocity;                                      // 0x0170(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LastSteering;                                      // 0x017C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsCrowdAiControlled;                               // 0x0188(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_189[0x3];                                      // 0x0189(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Radius;                                            // 0x018C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HalfHeight;                                        // 0x0190(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSpeed;                                          // 0x0194(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAccel;                                          // 0x0198(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroundFriction;                                    // 0x019C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LocationOffset;                                    // 0x01A0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RotationOffset;                                    // 0x01AC(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         FleeRadius;                                        // 0x01B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArrivalRadius;                                     // 0x01BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinDistToNavEdge;                                  // 0x01C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExtraQueryOffset;                                  // 0x01C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStickToGround;                                    // 0x01C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C9[0x3];                                      // 0x01C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TurnThresholdSpeed;                                // 0x01CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnInterpSpeed;                                   // 0x01D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExtrusionRadius;                                   // 0x01D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ShapeCollisionTagName;                             // 0x01D8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E4[0x5C];                                     // 0x01E4(0x005C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EnableBoidCollision(bool bEnable);
	void InitializeShapeBoids();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroCrowdAiBoidComponent">();
	}
	static class UKuroCrowdAiBoidComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroCrowdAiBoidComponent>();
	}
};
static_assert(alignof(UKuroCrowdAiBoidComponent) == 0x000010, "Wrong alignment on UKuroCrowdAiBoidComponent");
static_assert(sizeof(UKuroCrowdAiBoidComponent) == 0x000240, "Wrong size on UKuroCrowdAiBoidComponent");
static_assert(offsetof(UKuroCrowdAiBoidComponent, UpdatedComponent) == 0x0000C8, "Member 'UKuroCrowdAiBoidComponent::UpdatedComponent' has a wrong offset!");
static_assert(offsetof(UKuroCrowdAiBoidComponent, BoidId) == 0x0000D0, "Member 'UKuroCrowdAiBoidComponent::BoidId' has a wrong offset!");
static_assert(offsetof(UKuroCrowdAiBoidComponent, GroupId) == 0x0000D4, "Member 'UKuroCrowdAiBoidComponent::GroupId' has a wrong offset!");
static_assert(offsetof(UKuroCrowdAiBoidComponent, WatchingBoidId) == 0x0000D8, "Member 'UKuroCrowdAiBoidComponent::WatchingBoidId' has a wrong offset!");
static_assert(offsetof(UKuroCrowdAiBoidComponent, Transform) == 0x0000E0, "Member 'UKuroCrowdAiBoidComponent::Transform' has a wrong offset!");
static_assert(offsetof(UKuroCrowdAiBoidComponent, Velocity) == 0x000110, "Member 'UKuroCrowdAiBoidComponent::Velocity' has a wrong offset!");
static_assert(offsetof(UKuroCrowdAiBoidComponent, Steering) == 0x00011C, "Member 'UKuroCrowdAiBoidComponent::Steering' has a wrong offset!");
static_assert(offsetof(UKuroCrowdAiBoidComponent, Gravity) == 0x000128, "Member 'UKuroCrowdAiBoidComponent::Gravity' has a wrong offset!");
static_assert(offsetof(UKuroCrowdAiBoidComponent, LastTransform) == 0x000140, "Member 'UKuroCrowdAiBoidComponent::LastTransform' has a wrong offset!");
static_assert(offsetof(UKuroCrowdAiBoidComponent, LastVelocity) == 0x000170, "Member 'UKuroCrowdAiBoidComponent::LastVelocity' has a wrong offset!");
static_assert(offsetof(UKuroCrowdAiBoidComponent, LastSteering) == 0x00017C, "Member 'UKuroCrowdAiBoidComponent::LastSteering' has a wrong offset!");
static_assert(offsetof(UKuroCrowdAiBoidComponent, IsCrowdAiControlled) == 0x000188, "Member 'UKuroCrowdAiBoidComponent::IsCrowdAiControlled' has a wrong offset!");
static_assert(offsetof(UKuroCrowdAiBoidComponent, Radius) == 0x00018C, "Member 'UKuroCrowdAiBoidComponent::Radius' has a wrong offset!");
static_assert(offsetof(UKuroCrowdAiBoidComponent, HalfHeight) == 0x000190, "Member 'UKuroCrowdAiBoidComponent::HalfHeight' has a wrong offset!");
static_assert(offsetof(UKuroCrowdAiBoidComponent, MaxSpeed) == 0x000194, "Member 'UKuroCrowdAiBoidComponent::MaxSpeed' has a wrong offset!");
static_assert(offsetof(UKuroCrowdAiBoidComponent, MaxAccel) == 0x000198, "Member 'UKuroCrowdAiBoidComponent::MaxAccel' has a wrong offset!");
static_assert(offsetof(UKuroCrowdAiBoidComponent, GroundFriction) == 0x00019C, "Member 'UKuroCrowdAiBoidComponent::GroundFriction' has a wrong offset!");
static_assert(offsetof(UKuroCrowdAiBoidComponent, LocationOffset) == 0x0001A0, "Member 'UKuroCrowdAiBoidComponent::LocationOffset' has a wrong offset!");
static_assert(offsetof(UKuroCrowdAiBoidComponent, RotationOffset) == 0x0001AC, "Member 'UKuroCrowdAiBoidComponent::RotationOffset' has a wrong offset!");
static_assert(offsetof(UKuroCrowdAiBoidComponent, FleeRadius) == 0x0001B8, "Member 'UKuroCrowdAiBoidComponent::FleeRadius' has a wrong offset!");
static_assert(offsetof(UKuroCrowdAiBoidComponent, ArrivalRadius) == 0x0001BC, "Member 'UKuroCrowdAiBoidComponent::ArrivalRadius' has a wrong offset!");
static_assert(offsetof(UKuroCrowdAiBoidComponent, MinDistToNavEdge) == 0x0001C0, "Member 'UKuroCrowdAiBoidComponent::MinDistToNavEdge' has a wrong offset!");
static_assert(offsetof(UKuroCrowdAiBoidComponent, ExtraQueryOffset) == 0x0001C4, "Member 'UKuroCrowdAiBoidComponent::ExtraQueryOffset' has a wrong offset!");
static_assert(offsetof(UKuroCrowdAiBoidComponent, bStickToGround) == 0x0001C8, "Member 'UKuroCrowdAiBoidComponent::bStickToGround' has a wrong offset!");
static_assert(offsetof(UKuroCrowdAiBoidComponent, TurnThresholdSpeed) == 0x0001CC, "Member 'UKuroCrowdAiBoidComponent::TurnThresholdSpeed' has a wrong offset!");
static_assert(offsetof(UKuroCrowdAiBoidComponent, TurnInterpSpeed) == 0x0001D0, "Member 'UKuroCrowdAiBoidComponent::TurnInterpSpeed' has a wrong offset!");
static_assert(offsetof(UKuroCrowdAiBoidComponent, ExtrusionRadius) == 0x0001D4, "Member 'UKuroCrowdAiBoidComponent::ExtrusionRadius' has a wrong offset!");
static_assert(offsetof(UKuroCrowdAiBoidComponent, ShapeCollisionTagName) == 0x0001D8, "Member 'UKuroCrowdAiBoidComponent::ShapeCollisionTagName' has a wrong offset!");

// Class KuroCrowdAi.KuroCrowdAiBoidInstanceSequenceProxy
// 0x0018 (0x02C8 - 0x02B0)
class AKuroCrowdAiBoidInstanceSequenceProxy final : public AActor
{
public:
	class USceneComponent*                        RootSceneComponent;                                // 0x02B0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B8[0x10];                                     // 0x02B8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void PlayAnimation(int32 AnimationIndex, float PlayRate, float StartPos, bool bIsLoop);
	void StopAnimation(int32 AnimationIndex, bool bImmediately);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroCrowdAiBoidInstanceSequenceProxy">();
	}
	static class AKuroCrowdAiBoidInstanceSequenceProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKuroCrowdAiBoidInstanceSequenceProxy>();
	}
};
static_assert(alignof(AKuroCrowdAiBoidInstanceSequenceProxy) == 0x000008, "Wrong alignment on AKuroCrowdAiBoidInstanceSequenceProxy");
static_assert(sizeof(AKuroCrowdAiBoidInstanceSequenceProxy) == 0x0002C8, "Wrong size on AKuroCrowdAiBoidInstanceSequenceProxy");
static_assert(offsetof(AKuroCrowdAiBoidInstanceSequenceProxy, RootSceneComponent) == 0x0002B0, "Member 'AKuroCrowdAiBoidInstanceSequenceProxy::RootSceneComponent' has a wrong offset!");

// Class KuroCrowdAi.KuroCrowdAiBoidInstanceSequenceProxyRouter
// 0x00F8 (0x03A8 - 0x02B0)
class AKuroCrowdAiBoidInstanceSequenceProxyRouter final : public AActor
{
public:
	TMap<class AKuroCrowdAiBoidInstanceSequenceProxy*, int32> ProxyActorToBoidId;                    // 0x02B0(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<int32, class AKuroCrowdAiBoidInstanceSequenceProxy*> BoidIdToProxyActor;                    // 0x0300(0x0050)(Transient, NativeAccessSpecifierPrivate)
	class UKuroCrowdAiSubsystem*                  CrowdAiSubsystem;                                  // 0x0350(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSet<class AKuroCrowdAiBoidInstanceSequenceProxy*> ProxyActorsBusyRouting;                       // 0x0358(0x0050)(Transient, NativeAccessSpecifierPrivate)

public:
	bool AddRoute(class AKuroCrowdAiBoidInstanceSequenceProxy* ProxyActor, int32 InstanceId);
	void ClearRoute();
	class AKuroCrowdAiBoidInstanceSequenceProxy* GetRouteSource(int32 BoidId);
	int32 GetRouteTarget(const class AKuroCrowdAiBoidInstanceSequenceProxy* ProxyActor);
	bool RemoveRouteByBoidId(int32 BoidId);
	bool RemoveRouteByProxyActor(const class AKuroCrowdAiBoidInstanceSequenceProxy* ProxyActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroCrowdAiBoidInstanceSequenceProxyRouter">();
	}
	static class AKuroCrowdAiBoidInstanceSequenceProxyRouter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKuroCrowdAiBoidInstanceSequenceProxyRouter>();
	}
};
static_assert(alignof(AKuroCrowdAiBoidInstanceSequenceProxyRouter) == 0x000008, "Wrong alignment on AKuroCrowdAiBoidInstanceSequenceProxyRouter");
static_assert(sizeof(AKuroCrowdAiBoidInstanceSequenceProxyRouter) == 0x0003A8, "Wrong size on AKuroCrowdAiBoidInstanceSequenceProxyRouter");
static_assert(offsetof(AKuroCrowdAiBoidInstanceSequenceProxyRouter, ProxyActorToBoidId) == 0x0002B0, "Member 'AKuroCrowdAiBoidInstanceSequenceProxyRouter::ProxyActorToBoidId' has a wrong offset!");
static_assert(offsetof(AKuroCrowdAiBoidInstanceSequenceProxyRouter, BoidIdToProxyActor) == 0x000300, "Member 'AKuroCrowdAiBoidInstanceSequenceProxyRouter::BoidIdToProxyActor' has a wrong offset!");
static_assert(offsetof(AKuroCrowdAiBoidInstanceSequenceProxyRouter, CrowdAiSubsystem) == 0x000350, "Member 'AKuroCrowdAiBoidInstanceSequenceProxyRouter::CrowdAiSubsystem' has a wrong offset!");
static_assert(offsetof(AKuroCrowdAiBoidInstanceSequenceProxyRouter, ProxyActorsBusyRouting) == 0x000358, "Member 'AKuroCrowdAiBoidInstanceSequenceProxyRouter::ProxyActorsBusyRouting' has a wrong offset!");

// Class KuroCrowdAi.KuroCrowdAiSubsystem
// 0x0548 (0x0580 - 0x0038)
class UKuroCrowdAiSubsystem final : public UWorldSubsystem
{
public:
	float                                         GroupSplitRadius;                                  // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroupNavigationInterval;                           // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PauseSeekMinDist;                                  // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PauseSeekMaxTime;                                  // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PauseSeekMaxSpeed;                                 // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableFollowLimitation;                           // 0x004C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FanWingEdgesAngle;                                 // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FanWingEdgesLen;                                   // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FanBottomEdgeHalfLen;                              // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FanBottomEdgeDistToWatchingBoid;                   // 0x005C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BornDelayMaxTime;                                  // 0x0060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DestroyDelayMaxTime;                               // 0x0064(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableTeleport;                                   // 0x0068(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x3];                                       // 0x0069(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TeleportMinPlanarDist;                             // 0x006C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TeleportMinVerticalDist;                           // 0x0070(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PauseTeleportMaxPlanarSpeed;                       // 0x0074(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TeleportMinTime;                                   // 0x0078(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TeleportMaxTime;                                   // 0x007C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TeleportTargetMaxRadius;                           // 0x0080(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TeleportTargetMinRadius;                           // 0x0084(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TeleportTryCount;                                  // 0x0088(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStickToGround;                                    // 0x008C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8D[0x4F3];                                     // 0x008D(0x04F3)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool BoidPlayAnimation(int32 BoidId, int32 AnimIndex, float PlayRate, float StartPos, bool bIsLoop);
	bool BoidStopAnimation(int32 BoidId, int32 AnimIndex, bool bImmediately);
	bool ChangeGroupWatchingBoid(int32 GroupId, int32 BoidId);
	void EnableBoidIdlePerform(int32 BoidId, bool bEnable);
	void EnableDebugMode(bool Enable);
	void GetAllGroupIds(TArray<int32>* OutGroupIds);
	class UKuroCrowdAiBoidAnimUpdater* GetBoidAnimUpdater(int32 BoidId);
	int32 GetBoidGroupId(int32 BoidId);
	struct FTransform GetBoidLastTransform(int32 BoidId);
	struct FVector GetBoidLastVelocity(int32 BoidId);
	struct FTransform GetBoidTransform(int32 BoidId);
	struct FVector GetBoidVelocity(int32 BoidId);
	void NotifyBoidsAround();
	void NotifyBoidsMoveTo(const struct FVector& NewLocation);
	struct FVector QueryUsablePositionForBoid(const struct FVector& QueryPosition, float QueryRadius, float BoidRadius, int32 MaxTryCount);
	bool RemoveBoid(int32 BoidId, bool bForce);
	bool SetBoidAppearanceInfo(int32 BoidId, TArray<float>* CustomDataArray);
	bool SetBoidControlledByCrowdAi(int32 BoidId, bool Enable);
	bool SetBoidScale(int32 BoidId, const struct FVector& NewScale);
	bool SetBoidTransform(int32 BoidId, const struct FTransform& NewTransform, bool bTeleport);
	int32 SetWatchingBoidAndJoinGroup(int32 BoidId, int32 WatchingBoidId);
	void UpdateDebugNavMeshEdges(const struct FBox& Range);
	bool WasBoidControlledByCrowdAi(int32 BoidId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroCrowdAiSubsystem">();
	}
	static class UKuroCrowdAiSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroCrowdAiSubsystem>();
	}
};
static_assert(alignof(UKuroCrowdAiSubsystem) == 0x000008, "Wrong alignment on UKuroCrowdAiSubsystem");
static_assert(sizeof(UKuroCrowdAiSubsystem) == 0x000580, "Wrong size on UKuroCrowdAiSubsystem");
static_assert(offsetof(UKuroCrowdAiSubsystem, GroupSplitRadius) == 0x000038, "Member 'UKuroCrowdAiSubsystem::GroupSplitRadius' has a wrong offset!");
static_assert(offsetof(UKuroCrowdAiSubsystem, GroupNavigationInterval) == 0x00003C, "Member 'UKuroCrowdAiSubsystem::GroupNavigationInterval' has a wrong offset!");
static_assert(offsetof(UKuroCrowdAiSubsystem, PauseSeekMinDist) == 0x000040, "Member 'UKuroCrowdAiSubsystem::PauseSeekMinDist' has a wrong offset!");
static_assert(offsetof(UKuroCrowdAiSubsystem, PauseSeekMaxTime) == 0x000044, "Member 'UKuroCrowdAiSubsystem::PauseSeekMaxTime' has a wrong offset!");
static_assert(offsetof(UKuroCrowdAiSubsystem, PauseSeekMaxSpeed) == 0x000048, "Member 'UKuroCrowdAiSubsystem::PauseSeekMaxSpeed' has a wrong offset!");
static_assert(offsetof(UKuroCrowdAiSubsystem, bEnableFollowLimitation) == 0x00004C, "Member 'UKuroCrowdAiSubsystem::bEnableFollowLimitation' has a wrong offset!");
static_assert(offsetof(UKuroCrowdAiSubsystem, FanWingEdgesAngle) == 0x000050, "Member 'UKuroCrowdAiSubsystem::FanWingEdgesAngle' has a wrong offset!");
static_assert(offsetof(UKuroCrowdAiSubsystem, FanWingEdgesLen) == 0x000054, "Member 'UKuroCrowdAiSubsystem::FanWingEdgesLen' has a wrong offset!");
static_assert(offsetof(UKuroCrowdAiSubsystem, FanBottomEdgeHalfLen) == 0x000058, "Member 'UKuroCrowdAiSubsystem::FanBottomEdgeHalfLen' has a wrong offset!");
static_assert(offsetof(UKuroCrowdAiSubsystem, FanBottomEdgeDistToWatchingBoid) == 0x00005C, "Member 'UKuroCrowdAiSubsystem::FanBottomEdgeDistToWatchingBoid' has a wrong offset!");
static_assert(offsetof(UKuroCrowdAiSubsystem, BornDelayMaxTime) == 0x000060, "Member 'UKuroCrowdAiSubsystem::BornDelayMaxTime' has a wrong offset!");
static_assert(offsetof(UKuroCrowdAiSubsystem, DestroyDelayMaxTime) == 0x000064, "Member 'UKuroCrowdAiSubsystem::DestroyDelayMaxTime' has a wrong offset!");
static_assert(offsetof(UKuroCrowdAiSubsystem, bEnableTeleport) == 0x000068, "Member 'UKuroCrowdAiSubsystem::bEnableTeleport' has a wrong offset!");
static_assert(offsetof(UKuroCrowdAiSubsystem, TeleportMinPlanarDist) == 0x00006C, "Member 'UKuroCrowdAiSubsystem::TeleportMinPlanarDist' has a wrong offset!");
static_assert(offsetof(UKuroCrowdAiSubsystem, TeleportMinVerticalDist) == 0x000070, "Member 'UKuroCrowdAiSubsystem::TeleportMinVerticalDist' has a wrong offset!");
static_assert(offsetof(UKuroCrowdAiSubsystem, PauseTeleportMaxPlanarSpeed) == 0x000074, "Member 'UKuroCrowdAiSubsystem::PauseTeleportMaxPlanarSpeed' has a wrong offset!");
static_assert(offsetof(UKuroCrowdAiSubsystem, TeleportMinTime) == 0x000078, "Member 'UKuroCrowdAiSubsystem::TeleportMinTime' has a wrong offset!");
static_assert(offsetof(UKuroCrowdAiSubsystem, TeleportMaxTime) == 0x00007C, "Member 'UKuroCrowdAiSubsystem::TeleportMaxTime' has a wrong offset!");
static_assert(offsetof(UKuroCrowdAiSubsystem, TeleportTargetMaxRadius) == 0x000080, "Member 'UKuroCrowdAiSubsystem::TeleportTargetMaxRadius' has a wrong offset!");
static_assert(offsetof(UKuroCrowdAiSubsystem, TeleportTargetMinRadius) == 0x000084, "Member 'UKuroCrowdAiSubsystem::TeleportTargetMinRadius' has a wrong offset!");
static_assert(offsetof(UKuroCrowdAiSubsystem, TeleportTryCount) == 0x000088, "Member 'UKuroCrowdAiSubsystem::TeleportTryCount' has a wrong offset!");
static_assert(offsetof(UKuroCrowdAiSubsystem, bStickToGround) == 0x00008C, "Member 'UKuroCrowdAiSubsystem::bStickToGround' has a wrong offset!");

// Class KuroCrowdAi.KuroCrowdAiManagerProxyActor
// 0x0020 (0x02D0 - 0x02B0)
class AKuroCrowdAiManagerProxyActor final : public AActor
{
public:
	class USceneComponent*                        RootSceneComponent;                                // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxSimulationIterations;                           // 0x02B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSimulationTimeStep;                             // 0x02BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C0[0x10];                                     // 0x02C0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetEnableParallelUpdate(bool bEnable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroCrowdAiManagerProxyActor">();
	}
	static class AKuroCrowdAiManagerProxyActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKuroCrowdAiManagerProxyActor>();
	}
};
static_assert(alignof(AKuroCrowdAiManagerProxyActor) == 0x000008, "Wrong alignment on AKuroCrowdAiManagerProxyActor");
static_assert(sizeof(AKuroCrowdAiManagerProxyActor) == 0x0002D0, "Wrong size on AKuroCrowdAiManagerProxyActor");
static_assert(offsetof(AKuroCrowdAiManagerProxyActor, RootSceneComponent) == 0x0002B0, "Member 'AKuroCrowdAiManagerProxyActor::RootSceneComponent' has a wrong offset!");
static_assert(offsetof(AKuroCrowdAiManagerProxyActor, MaxSimulationIterations) == 0x0002B8, "Member 'AKuroCrowdAiManagerProxyActor::MaxSimulationIterations' has a wrong offset!");
static_assert(offsetof(AKuroCrowdAiManagerProxyActor, MaxSimulationTimeStep) == 0x0002BC, "Member 'AKuroCrowdAiManagerProxyActor::MaxSimulationTimeStep' has a wrong offset!");

}


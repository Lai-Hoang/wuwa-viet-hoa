#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: KuroSimpleCombat

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "KuroSimpleCombat_structs.hpp"


namespace SDK::Params
{

// Function KuroSimpleCombat.KSC_RenderEntityInterface.KSC_AddEntity
// 0x0040 (0x0040 - 0x0000)
struct KSC_RenderEntityInterface_KSC_AddEntity final
{
public:
	int32                                         EntityId;                                          // 0x0000(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0xC];                                        // 0x0004(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             InTransform;                                       // 0x0010(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(KSC_RenderEntityInterface_KSC_AddEntity) == 0x000010, "Wrong alignment on KSC_RenderEntityInterface_KSC_AddEntity");
static_assert(sizeof(KSC_RenderEntityInterface_KSC_AddEntity) == 0x000040, "Wrong size on KSC_RenderEntityInterface_KSC_AddEntity");
static_assert(offsetof(KSC_RenderEntityInterface_KSC_AddEntity, EntityId) == 0x000000, "Member 'KSC_RenderEntityInterface_KSC_AddEntity::EntityId' has a wrong offset!");
static_assert(offsetof(KSC_RenderEntityInterface_KSC_AddEntity, InTransform) == 0x000010, "Member 'KSC_RenderEntityInterface_KSC_AddEntity::InTransform' has a wrong offset!");

// Function KuroSimpleCombat.KSC_RenderEntityInterface.KSC_RemoveEntity
// 0x0004 (0x0004 - 0x0000)
struct KSC_RenderEntityInterface_KSC_RemoveEntity final
{
public:
	int32                                         EntityId;                                          // 0x0000(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KSC_RenderEntityInterface_KSC_RemoveEntity) == 0x000004, "Wrong alignment on KSC_RenderEntityInterface_KSC_RemoveEntity");
static_assert(sizeof(KSC_RenderEntityInterface_KSC_RemoveEntity) == 0x000004, "Wrong size on KSC_RenderEntityInterface_KSC_RemoveEntity");
static_assert(offsetof(KSC_RenderEntityInterface_KSC_RemoveEntity, EntityId) == 0x000000, "Member 'KSC_RenderEntityInterface_KSC_RemoveEntity::EntityId' has a wrong offset!");

// Function KuroSimpleCombat.KSC_RenderEntityInterface.KSC_SetActorTransform
// 0x0040 (0x0040 - 0x0000)
struct KSC_RenderEntityInterface_KSC_SetActorTransform final
{
public:
	int32                                         EntityId;                                          // 0x0000(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0xC];                                        // 0x0004(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             InTransform;                                       // 0x0010(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(KSC_RenderEntityInterface_KSC_SetActorTransform) == 0x000010, "Wrong alignment on KSC_RenderEntityInterface_KSC_SetActorTransform");
static_assert(sizeof(KSC_RenderEntityInterface_KSC_SetActorTransform) == 0x000040, "Wrong size on KSC_RenderEntityInterface_KSC_SetActorTransform");
static_assert(offsetof(KSC_RenderEntityInterface_KSC_SetActorTransform, EntityId) == 0x000000, "Member 'KSC_RenderEntityInterface_KSC_SetActorTransform::EntityId' has a wrong offset!");
static_assert(offsetof(KSC_RenderEntityInterface_KSC_SetActorTransform, InTransform) == 0x000010, "Member 'KSC_RenderEntityInterface_KSC_SetActorTransform::InTransform' has a wrong offset!");

// Function KuroSimpleCombat.KSC_Move_Spline.SetSpline
// 0x0008 (0x0008 - 0x0000)
struct KSC_Move_Spline_SetSpline final
{
public:
	class USplineComponent*                       SplineComp;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KSC_Move_Spline_SetSpline) == 0x000008, "Wrong alignment on KSC_Move_Spline_SetSpline");
static_assert(sizeof(KSC_Move_Spline_SetSpline) == 0x000008, "Wrong size on KSC_Move_Spline_SetSpline");
static_assert(offsetof(KSC_Move_Spline_SetSpline, SplineComp) == 0x000000, "Member 'KSC_Move_Spline_SetSpline::SplineComp' has a wrong offset!");

// Function KuroSimpleCombat.KSC_Move_Spline.SetSplineWide
// 0x0004 (0x0004 - 0x0000)
struct KSC_Move_Spline_SetSplineWide final
{
public:
	float                                         Width;                                             // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KSC_Move_Spline_SetSplineWide) == 0x000004, "Wrong alignment on KSC_Move_Spline_SetSplineWide");
static_assert(sizeof(KSC_Move_Spline_SetSplineWide) == 0x000004, "Wrong size on KSC_Move_Spline_SetSplineWide");
static_assert(offsetof(KSC_Move_Spline_SetSplineWide, Width) == 0x000000, "Member 'KSC_Move_Spline_SetSplineWide::Width' has a wrong offset!");

// Function KuroSimpleCombat.KSCDelegateCommon.GetOrAddDelegate
// 0x0008 (0x0008 - 0x0000)
struct KSCDelegateCommon_GetOrAddDelegate final
{
public:
	class UKSCDelegateCommon*                     ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KSCDelegateCommon_GetOrAddDelegate) == 0x000008, "Wrong alignment on KSCDelegateCommon_GetOrAddDelegate");
static_assert(sizeof(KSCDelegateCommon_GetOrAddDelegate) == 0x000008, "Wrong size on KSCDelegateCommon_GetOrAddDelegate");
static_assert(offsetof(KSCDelegateCommon_GetOrAddDelegate, ReturnValue) == 0x000000, "Member 'KSCDelegateCommon_GetOrAddDelegate::ReturnValue' has a wrong offset!");

// Function KuroSimpleCombat.KSC_Entity.GetMoveComponent
// 0x0008 (0x0008 - 0x0000)
struct KSC_Entity_GetMoveComponent final
{
public:
	class UKSC_Move*                              ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KSC_Entity_GetMoveComponent) == 0x000008, "Wrong alignment on KSC_Entity_GetMoveComponent");
static_assert(sizeof(KSC_Entity_GetMoveComponent) == 0x000008, "Wrong size on KSC_Entity_GetMoveComponent");
static_assert(offsetof(KSC_Entity_GetMoveComponent, ReturnValue) == 0x000000, "Member 'KSC_Entity_GetMoveComponent::ReturnValue' has a wrong offset!");

// Function KuroSimpleCombat.KSC_Entity.SetFaction
// 0x0001 (0x0001 - 0x0000)
struct KSC_Entity_SetFaction final
{
public:
	EKSC_Faction                                  Faction;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KSC_Entity_SetFaction) == 0x000001, "Wrong alignment on KSC_Entity_SetFaction");
static_assert(sizeof(KSC_Entity_SetFaction) == 0x000001, "Wrong size on KSC_Entity_SetFaction");
static_assert(offsetof(KSC_Entity_SetFaction, Faction) == 0x000000, "Member 'KSC_Entity_SetFaction::Faction' has a wrong offset!");

// Function KuroSimpleCombat.KSC_Entity.SetHP
// 0x0004 (0x0004 - 0x0000)
struct KSC_Entity_SetHP final
{
public:
	int32                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KSC_Entity_SetHP) == 0x000004, "Wrong alignment on KSC_Entity_SetHP");
static_assert(sizeof(KSC_Entity_SetHP) == 0x000004, "Wrong size on KSC_Entity_SetHP");
static_assert(offsetof(KSC_Entity_SetHP, Value) == 0x000000, "Member 'KSC_Entity_SetHP::Value' has a wrong offset!");

// Function KuroSimpleCombat.KSC_Entity.GetAttrComponent
// 0x0008 (0x0008 - 0x0000)
struct KSC_Entity_GetAttrComponent final
{
public:
	class UKSC_AttrSet*                           ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KSC_Entity_GetAttrComponent) == 0x000008, "Wrong alignment on KSC_Entity_GetAttrComponent");
static_assert(sizeof(KSC_Entity_GetAttrComponent) == 0x000008, "Wrong size on KSC_Entity_GetAttrComponent");
static_assert(offsetof(KSC_Entity_GetAttrComponent, ReturnValue) == 0x000000, "Member 'KSC_Entity_GetAttrComponent::ReturnValue' has a wrong offset!");

// Function KuroSimpleCombat.KSC_Entity.GetHP
// 0x0004 (0x0004 - 0x0000)
struct KSC_Entity_GetHP final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KSC_Entity_GetHP) == 0x000004, "Wrong alignment on KSC_Entity_GetHP");
static_assert(sizeof(KSC_Entity_GetHP) == 0x000004, "Wrong size on KSC_Entity_GetHP");
static_assert(offsetof(KSC_Entity_GetHP, ReturnValue) == 0x000000, "Member 'KSC_Entity_GetHP::ReturnValue' has a wrong offset!");

// Function KuroSimpleCombat.KSC_World.AddDaEntity
// 0x0050 (0x0050 - 0x0000)
struct KSC_World_AddDaEntity final
{
public:
	class UKSC_DA_Entity*                         DaEntity;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Transform;                                         // 0x0010(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class UKSC_Entity*                            ReturnValue;                                       // 0x0040(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KSC_World_AddDaEntity) == 0x000010, "Wrong alignment on KSC_World_AddDaEntity");
static_assert(sizeof(KSC_World_AddDaEntity) == 0x000050, "Wrong size on KSC_World_AddDaEntity");
static_assert(offsetof(KSC_World_AddDaEntity, DaEntity) == 0x000000, "Member 'KSC_World_AddDaEntity::DaEntity' has a wrong offset!");
static_assert(offsetof(KSC_World_AddDaEntity, Transform) == 0x000010, "Member 'KSC_World_AddDaEntity::Transform' has a wrong offset!");
static_assert(offsetof(KSC_World_AddDaEntity, ReturnValue) == 0x000040, "Member 'KSC_World_AddDaEntity::ReturnValue' has a wrong offset!");

// Function KuroSimpleCombat.KSC_World.RemoveEntity
// 0x0008 (0x0008 - 0x0000)
struct KSC_World_RemoveEntity final
{
public:
	class UKSC_Entity*                            Entity;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KSC_World_RemoveEntity) == 0x000008, "Wrong alignment on KSC_World_RemoveEntity");
static_assert(sizeof(KSC_World_RemoveEntity) == 0x000008, "Wrong size on KSC_World_RemoveEntity");
static_assert(offsetof(KSC_World_RemoveEntity, Entity) == 0x000000, "Member 'KSC_World_RemoveEntity::Entity' has a wrong offset!");

// Function KuroSimpleCombat.KuroSimpleCombatSubsystem.CreateWorld
// 0x0008 (0x0008 - 0x0000)
struct KuroSimpleCombatSubsystem_CreateWorld final
{
public:
	class UKSC_World*                             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroSimpleCombatSubsystem_CreateWorld) == 0x000008, "Wrong alignment on KuroSimpleCombatSubsystem_CreateWorld");
static_assert(sizeof(KuroSimpleCombatSubsystem_CreateWorld) == 0x000008, "Wrong size on KuroSimpleCombatSubsystem_CreateWorld");
static_assert(offsetof(KuroSimpleCombatSubsystem_CreateWorld, ReturnValue) == 0x000000, "Member 'KuroSimpleCombatSubsystem_CreateWorld::ReturnValue' has a wrong offset!");

// Function KuroSimpleCombat.KuroSimpleCombatSubsystem.EntityBeginCastProxy
// 0x0050 (0x0050 - 0x0000)
struct KuroSimpleCombatSubsystem_EntityBeginCastProxy final
{
public:
	uint32                                        EntityId;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UKSC_Entity>                EntityClass;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             EntityTransform;                                   // 0x0010(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	TSubclassOf<class UKSC_Skill>                 SkillClass;                                        // 0x0040(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroSimpleCombatSubsystem_EntityBeginCastProxy) == 0x000010, "Wrong alignment on KuroSimpleCombatSubsystem_EntityBeginCastProxy");
static_assert(sizeof(KuroSimpleCombatSubsystem_EntityBeginCastProxy) == 0x000050, "Wrong size on KuroSimpleCombatSubsystem_EntityBeginCastProxy");
static_assert(offsetof(KuroSimpleCombatSubsystem_EntityBeginCastProxy, EntityId) == 0x000000, "Member 'KuroSimpleCombatSubsystem_EntityBeginCastProxy::EntityId' has a wrong offset!");
static_assert(offsetof(KuroSimpleCombatSubsystem_EntityBeginCastProxy, EntityClass) == 0x000008, "Member 'KuroSimpleCombatSubsystem_EntityBeginCastProxy::EntityClass' has a wrong offset!");
static_assert(offsetof(KuroSimpleCombatSubsystem_EntityBeginCastProxy, EntityTransform) == 0x000010, "Member 'KuroSimpleCombatSubsystem_EntityBeginCastProxy::EntityTransform' has a wrong offset!");
static_assert(offsetof(KuroSimpleCombatSubsystem_EntityBeginCastProxy, SkillClass) == 0x000040, "Member 'KuroSimpleCombatSubsystem_EntityBeginCastProxy::SkillClass' has a wrong offset!");

// Function KuroSimpleCombat.KuroSimpleCombatSubsystem.EntityHitProxy
// 0x0050 (0x0050 - 0x0000)
struct KuroSimpleCombatSubsystem_EntityHitProxy final
{
public:
	uint32                                        FromEntityId;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UKSC_Entity>                FromEntityClass;                                   // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        ToEntityId;                                        // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UKSC_Entity>                ToEntityClass;                                     // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             HitTransform;                                      // 0x0020(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroSimpleCombatSubsystem_EntityHitProxy) == 0x000010, "Wrong alignment on KuroSimpleCombatSubsystem_EntityHitProxy");
static_assert(sizeof(KuroSimpleCombatSubsystem_EntityHitProxy) == 0x000050, "Wrong size on KuroSimpleCombatSubsystem_EntityHitProxy");
static_assert(offsetof(KuroSimpleCombatSubsystem_EntityHitProxy, FromEntityId) == 0x000000, "Member 'KuroSimpleCombatSubsystem_EntityHitProxy::FromEntityId' has a wrong offset!");
static_assert(offsetof(KuroSimpleCombatSubsystem_EntityHitProxy, FromEntityClass) == 0x000008, "Member 'KuroSimpleCombatSubsystem_EntityHitProxy::FromEntityClass' has a wrong offset!");
static_assert(offsetof(KuroSimpleCombatSubsystem_EntityHitProxy, ToEntityId) == 0x000010, "Member 'KuroSimpleCombatSubsystem_EntityHitProxy::ToEntityId' has a wrong offset!");
static_assert(offsetof(KuroSimpleCombatSubsystem_EntityHitProxy, ToEntityClass) == 0x000018, "Member 'KuroSimpleCombatSubsystem_EntityHitProxy::ToEntityClass' has a wrong offset!");
static_assert(offsetof(KuroSimpleCombatSubsystem_EntityHitProxy, HitTransform) == 0x000020, "Member 'KuroSimpleCombatSubsystem_EntityHitProxy::HitTransform' has a wrong offset!");

// Function KuroSimpleCombat.KuroSimpleCombatSubsystem.EntityInitProxy
// 0x0040 (0x0040 - 0x0000)
struct KuroSimpleCombatSubsystem_EntityInitProxy final
{
public:
	uint32                                        EntityId;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UKSC_Entity>                EntityClass;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             EntityTransform;                                   // 0x0010(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroSimpleCombatSubsystem_EntityInitProxy) == 0x000010, "Wrong alignment on KuroSimpleCombatSubsystem_EntityInitProxy");
static_assert(sizeof(KuroSimpleCombatSubsystem_EntityInitProxy) == 0x000040, "Wrong size on KuroSimpleCombatSubsystem_EntityInitProxy");
static_assert(offsetof(KuroSimpleCombatSubsystem_EntityInitProxy, EntityId) == 0x000000, "Member 'KuroSimpleCombatSubsystem_EntityInitProxy::EntityId' has a wrong offset!");
static_assert(offsetof(KuroSimpleCombatSubsystem_EntityInitProxy, EntityClass) == 0x000008, "Member 'KuroSimpleCombatSubsystem_EntityInitProxy::EntityClass' has a wrong offset!");
static_assert(offsetof(KuroSimpleCombatSubsystem_EntityInitProxy, EntityTransform) == 0x000010, "Member 'KuroSimpleCombatSubsystem_EntityInitProxy::EntityTransform' has a wrong offset!");

// Function KuroSimpleCombat.KuroSimpleCombatSubsystem.EntityUninitProxy
// 0x0010 (0x0010 - 0x0000)
struct KuroSimpleCombatSubsystem_EntityUninitProxy final
{
public:
	uint32                                        EntityId;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UKSC_Entity>                EntityClass;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroSimpleCombatSubsystem_EntityUninitProxy) == 0x000008, "Wrong alignment on KuroSimpleCombatSubsystem_EntityUninitProxy");
static_assert(sizeof(KuroSimpleCombatSubsystem_EntityUninitProxy) == 0x000010, "Wrong size on KuroSimpleCombatSubsystem_EntityUninitProxy");
static_assert(offsetof(KuroSimpleCombatSubsystem_EntityUninitProxy, EntityId) == 0x000000, "Member 'KuroSimpleCombatSubsystem_EntityUninitProxy::EntityId' has a wrong offset!");
static_assert(offsetof(KuroSimpleCombatSubsystem_EntityUninitProxy, EntityClass) == 0x000008, "Member 'KuroSimpleCombatSubsystem_EntityUninitProxy::EntityClass' has a wrong offset!");

// Function KuroSimpleCombat.KuroSimpleCombatSubsystem.GetKSCWorld
// 0x0008 (0x0008 - 0x0000)
struct KuroSimpleCombatSubsystem_GetKSCWorld final
{
public:
	class UKSC_World*                             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroSimpleCombatSubsystem_GetKSCWorld) == 0x000008, "Wrong alignment on KuroSimpleCombatSubsystem_GetKSCWorld");
static_assert(sizeof(KuroSimpleCombatSubsystem_GetKSCWorld) == 0x000008, "Wrong size on KuroSimpleCombatSubsystem_GetKSCWorld");
static_assert(offsetof(KuroSimpleCombatSubsystem_GetKSCWorld, ReturnValue) == 0x000000, "Member 'KuroSimpleCombatSubsystem_GetKSCWorld::ReturnValue' has a wrong offset!");

}


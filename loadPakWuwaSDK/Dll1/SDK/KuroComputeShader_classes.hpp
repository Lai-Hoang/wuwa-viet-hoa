#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: KuroComputeShader

#include "Basic.hpp"

#include "KuroRenderingRuntimeBPPlugin_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "Engine_classes.hpp"
#include "KuroComputeShader_structs.hpp"


namespace SDK
{

// Class KuroComputeShader.KuroCS_Cloth_DynamicPin
// 0x00D0 (0x0380 - 0x02B0)
class AKuroCS_Cloth_DynamicPin final : public AActor
{
public:
	class USceneComponent*                        Root;                                              // 0x02B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          useExternalRT;                                     // 0x02B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B9[0x7];                                      // 0x02B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextureRenderTarget2D*                 RenderTarget;                                      // 0x02C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FKuroCSParticle_Cloth_DynamicPin> DebugArr;                                        // 0x02C8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         XCount;                                            // 0x02D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         YCount;                                            // 0x02DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DisStiffness;                                      // 0x02E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         bendStiffness;                                     // 0x02E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                playerPos;                                         // 0x02E8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         collisionR;                                        // 0x02F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ParticleCount;                                     // 0x02F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         linkDis;                                           // 0x02FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         linkDisY;                                          // 0x0300(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         substepCount;                                      // 0x0304(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                accel_ext;                                         // 0x0308(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                actorPos;                                          // 0x0314(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         restoringOrNot;                                    // 0x0320(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         k;                                                 // 0x0324(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         c;                                                 // 0x0328(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         deltaTime;                                         // 0x032C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         lerpGravityOrNot;                                  // 0x0330(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PinnedPointsOrNot;                                 // 0x0334(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         dragCoefficient;                                   // 0x0338(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                pinned11;                                          // 0x033C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                pinned12;                                          // 0x0348(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                pinned21;                                          // 0x0354(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                pinned22;                                          // 0x0360(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPinRow0;                                          // 0x036C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPinRowN;                                          // 0x036D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPinCol0;                                          // 0x036E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPinColN;                                          // 0x036F(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOffsetFirstPoint;                                 // 0x0370(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_371[0xF];                                      // 0x0371(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitShaderManager();
	void ReleaseShaderManager();
	void StartSimulation();
	void StopSimulation();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroCS_Cloth_DynamicPin">();
	}
	static class AKuroCS_Cloth_DynamicPin* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKuroCS_Cloth_DynamicPin>();
	}
};
static_assert(alignof(AKuroCS_Cloth_DynamicPin) == 0x000008, "Wrong alignment on AKuroCS_Cloth_DynamicPin");
static_assert(sizeof(AKuroCS_Cloth_DynamicPin) == 0x000380, "Wrong size on AKuroCS_Cloth_DynamicPin");
static_assert(offsetof(AKuroCS_Cloth_DynamicPin, Root) == 0x0002B0, "Member 'AKuroCS_Cloth_DynamicPin::Root' has a wrong offset!");
static_assert(offsetof(AKuroCS_Cloth_DynamicPin, useExternalRT) == 0x0002B8, "Member 'AKuroCS_Cloth_DynamicPin::useExternalRT' has a wrong offset!");
static_assert(offsetof(AKuroCS_Cloth_DynamicPin, RenderTarget) == 0x0002C0, "Member 'AKuroCS_Cloth_DynamicPin::RenderTarget' has a wrong offset!");
static_assert(offsetof(AKuroCS_Cloth_DynamicPin, DebugArr) == 0x0002C8, "Member 'AKuroCS_Cloth_DynamicPin::DebugArr' has a wrong offset!");
static_assert(offsetof(AKuroCS_Cloth_DynamicPin, XCount) == 0x0002D8, "Member 'AKuroCS_Cloth_DynamicPin::XCount' has a wrong offset!");
static_assert(offsetof(AKuroCS_Cloth_DynamicPin, YCount) == 0x0002DC, "Member 'AKuroCS_Cloth_DynamicPin::YCount' has a wrong offset!");
static_assert(offsetof(AKuroCS_Cloth_DynamicPin, DisStiffness) == 0x0002E0, "Member 'AKuroCS_Cloth_DynamicPin::DisStiffness' has a wrong offset!");
static_assert(offsetof(AKuroCS_Cloth_DynamicPin, bendStiffness) == 0x0002E4, "Member 'AKuroCS_Cloth_DynamicPin::bendStiffness' has a wrong offset!");
static_assert(offsetof(AKuroCS_Cloth_DynamicPin, playerPos) == 0x0002E8, "Member 'AKuroCS_Cloth_DynamicPin::playerPos' has a wrong offset!");
static_assert(offsetof(AKuroCS_Cloth_DynamicPin, collisionR) == 0x0002F4, "Member 'AKuroCS_Cloth_DynamicPin::collisionR' has a wrong offset!");
static_assert(offsetof(AKuroCS_Cloth_DynamicPin, ParticleCount) == 0x0002F8, "Member 'AKuroCS_Cloth_DynamicPin::ParticleCount' has a wrong offset!");
static_assert(offsetof(AKuroCS_Cloth_DynamicPin, linkDis) == 0x0002FC, "Member 'AKuroCS_Cloth_DynamicPin::linkDis' has a wrong offset!");
static_assert(offsetof(AKuroCS_Cloth_DynamicPin, linkDisY) == 0x000300, "Member 'AKuroCS_Cloth_DynamicPin::linkDisY' has a wrong offset!");
static_assert(offsetof(AKuroCS_Cloth_DynamicPin, substepCount) == 0x000304, "Member 'AKuroCS_Cloth_DynamicPin::substepCount' has a wrong offset!");
static_assert(offsetof(AKuroCS_Cloth_DynamicPin, accel_ext) == 0x000308, "Member 'AKuroCS_Cloth_DynamicPin::accel_ext' has a wrong offset!");
static_assert(offsetof(AKuroCS_Cloth_DynamicPin, actorPos) == 0x000314, "Member 'AKuroCS_Cloth_DynamicPin::actorPos' has a wrong offset!");
static_assert(offsetof(AKuroCS_Cloth_DynamicPin, restoringOrNot) == 0x000320, "Member 'AKuroCS_Cloth_DynamicPin::restoringOrNot' has a wrong offset!");
static_assert(offsetof(AKuroCS_Cloth_DynamicPin, k) == 0x000324, "Member 'AKuroCS_Cloth_DynamicPin::k' has a wrong offset!");
static_assert(offsetof(AKuroCS_Cloth_DynamicPin, c) == 0x000328, "Member 'AKuroCS_Cloth_DynamicPin::c' has a wrong offset!");
static_assert(offsetof(AKuroCS_Cloth_DynamicPin, deltaTime) == 0x00032C, "Member 'AKuroCS_Cloth_DynamicPin::deltaTime' has a wrong offset!");
static_assert(offsetof(AKuroCS_Cloth_DynamicPin, lerpGravityOrNot) == 0x000330, "Member 'AKuroCS_Cloth_DynamicPin::lerpGravityOrNot' has a wrong offset!");
static_assert(offsetof(AKuroCS_Cloth_DynamicPin, PinnedPointsOrNot) == 0x000334, "Member 'AKuroCS_Cloth_DynamicPin::PinnedPointsOrNot' has a wrong offset!");
static_assert(offsetof(AKuroCS_Cloth_DynamicPin, dragCoefficient) == 0x000338, "Member 'AKuroCS_Cloth_DynamicPin::dragCoefficient' has a wrong offset!");
static_assert(offsetof(AKuroCS_Cloth_DynamicPin, pinned11) == 0x00033C, "Member 'AKuroCS_Cloth_DynamicPin::pinned11' has a wrong offset!");
static_assert(offsetof(AKuroCS_Cloth_DynamicPin, pinned12) == 0x000348, "Member 'AKuroCS_Cloth_DynamicPin::pinned12' has a wrong offset!");
static_assert(offsetof(AKuroCS_Cloth_DynamicPin, pinned21) == 0x000354, "Member 'AKuroCS_Cloth_DynamicPin::pinned21' has a wrong offset!");
static_assert(offsetof(AKuroCS_Cloth_DynamicPin, pinned22) == 0x000360, "Member 'AKuroCS_Cloth_DynamicPin::pinned22' has a wrong offset!");
static_assert(offsetof(AKuroCS_Cloth_DynamicPin, bPinRow0) == 0x00036C, "Member 'AKuroCS_Cloth_DynamicPin::bPinRow0' has a wrong offset!");
static_assert(offsetof(AKuroCS_Cloth_DynamicPin, bPinRowN) == 0x00036D, "Member 'AKuroCS_Cloth_DynamicPin::bPinRowN' has a wrong offset!");
static_assert(offsetof(AKuroCS_Cloth_DynamicPin, bPinCol0) == 0x00036E, "Member 'AKuroCS_Cloth_DynamicPin::bPinCol0' has a wrong offset!");
static_assert(offsetof(AKuroCS_Cloth_DynamicPin, bPinColN) == 0x00036F, "Member 'AKuroCS_Cloth_DynamicPin::bPinColN' has a wrong offset!");
static_assert(offsetof(AKuroCS_Cloth_DynamicPin, bOffsetFirstPoint) == 0x000370, "Member 'AKuroCS_Cloth_DynamicPin::bOffsetFirstPoint' has a wrong offset!");

// Class KuroComputeShader.KuroCS_Cloth_Path
// 0x0080 (0x0330 - 0x02B0)
class AKuroCS_Cloth_Path final : public AActor
{
public:
	class USceneComponent*                        Root;                                              // 0x02B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          useExternalRT;                                     // 0x02B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B9[0x7];                                      // 0x02B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextureRenderTarget2D*                 RenderTarget;                                      // 0x02C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextureRenderTarget2D*                 RenderTarget_N;                                    // 0x02C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FKuroCSParticle_Cloth_Path>     DebugArr;                                          // 0x02D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         XCount;                                            // 0x02E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         YCount;                                            // 0x02E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DisStiffness;                                      // 0x02E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                playerPos;                                         // 0x02EC(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         collisionR;                                        // 0x02F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         upOffset;                                          // 0x02FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         volDamping;                                        // 0x0300(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         linkDisScale;                                      // 0x0304(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         attenuationPower;                                  // 0x0308(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                actorPos;                                          // 0x030C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FKuroCSParticle_Cloth_Path>     ParticlesArr;                                      // 0x0318(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_328[0x8];                                      // 0x0328(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitShaderManager();
	void ReleaseShaderManager();
	void StartSimulation();
	void StopSimulation();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroCS_Cloth_Path">();
	}
	static class AKuroCS_Cloth_Path* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKuroCS_Cloth_Path>();
	}
};
static_assert(alignof(AKuroCS_Cloth_Path) == 0x000008, "Wrong alignment on AKuroCS_Cloth_Path");
static_assert(sizeof(AKuroCS_Cloth_Path) == 0x000330, "Wrong size on AKuroCS_Cloth_Path");
static_assert(offsetof(AKuroCS_Cloth_Path, Root) == 0x0002B0, "Member 'AKuroCS_Cloth_Path::Root' has a wrong offset!");
static_assert(offsetof(AKuroCS_Cloth_Path, useExternalRT) == 0x0002B8, "Member 'AKuroCS_Cloth_Path::useExternalRT' has a wrong offset!");
static_assert(offsetof(AKuroCS_Cloth_Path, RenderTarget) == 0x0002C0, "Member 'AKuroCS_Cloth_Path::RenderTarget' has a wrong offset!");
static_assert(offsetof(AKuroCS_Cloth_Path, RenderTarget_N) == 0x0002C8, "Member 'AKuroCS_Cloth_Path::RenderTarget_N' has a wrong offset!");
static_assert(offsetof(AKuroCS_Cloth_Path, DebugArr) == 0x0002D0, "Member 'AKuroCS_Cloth_Path::DebugArr' has a wrong offset!");
static_assert(offsetof(AKuroCS_Cloth_Path, XCount) == 0x0002E0, "Member 'AKuroCS_Cloth_Path::XCount' has a wrong offset!");
static_assert(offsetof(AKuroCS_Cloth_Path, YCount) == 0x0002E4, "Member 'AKuroCS_Cloth_Path::YCount' has a wrong offset!");
static_assert(offsetof(AKuroCS_Cloth_Path, DisStiffness) == 0x0002E8, "Member 'AKuroCS_Cloth_Path::DisStiffness' has a wrong offset!");
static_assert(offsetof(AKuroCS_Cloth_Path, playerPos) == 0x0002EC, "Member 'AKuroCS_Cloth_Path::playerPos' has a wrong offset!");
static_assert(offsetof(AKuroCS_Cloth_Path, collisionR) == 0x0002F8, "Member 'AKuroCS_Cloth_Path::collisionR' has a wrong offset!");
static_assert(offsetof(AKuroCS_Cloth_Path, upOffset) == 0x0002FC, "Member 'AKuroCS_Cloth_Path::upOffset' has a wrong offset!");
static_assert(offsetof(AKuroCS_Cloth_Path, volDamping) == 0x000300, "Member 'AKuroCS_Cloth_Path::volDamping' has a wrong offset!");
static_assert(offsetof(AKuroCS_Cloth_Path, linkDisScale) == 0x000304, "Member 'AKuroCS_Cloth_Path::linkDisScale' has a wrong offset!");
static_assert(offsetof(AKuroCS_Cloth_Path, attenuationPower) == 0x000308, "Member 'AKuroCS_Cloth_Path::attenuationPower' has a wrong offset!");
static_assert(offsetof(AKuroCS_Cloth_Path, actorPos) == 0x00030C, "Member 'AKuroCS_Cloth_Path::actorPos' has a wrong offset!");
static_assert(offsetof(AKuroCS_Cloth_Path, ParticlesArr) == 0x000318, "Member 'AKuroCS_Cloth_Path::ParticlesArr' has a wrong offset!");

// Class KuroComputeShader.KuroCS_liuShu
// 0x0090 (0x0438 - 0x03A8)
class AKuroCS_liuShu final : public AKuroBPCustomCookActor
{
public:
	class USceneComponent*                        Root;                                              // 0x03A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          useExternalRT;                                     // 0x03B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B1[0x7];                                      // 0x03B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextureRenderTarget2D*                 RenderTarget;                                      // 0x03B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DisStiffness;                                      // 0x03C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                playerPos;                                         // 0x03C4(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         collisionR;                                        // 0x03D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ParticleCount;                                     // 0x03D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                accel_ext;                                         // 0x03D8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         volDamping;                                        // 0x03E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CustomDetalTime;                                   // 0x03E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                actorPos;                                          // 0x03EC(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WindForce;                                         // 0x03F8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SubstepCount;                                      // 0x0404(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         particleCountPerChain;                             // 0x0408(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_40C[0xC];                                      // 0x040C(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FKuroCSParticle_liuShu>         ParticlesArr;                                      // 0x0418(0x0010)(BlueprintVisible, ZeroConstructor, AdvancedDisplay, NativeAccessSpecifierPrivate)
	TArray<struct FKuroCSParticle_liuShu>         DebugArr;                                          // 0x0428(0x0010)(BlueprintVisible, ZeroConstructor, AdvancedDisplay, NativeAccessSpecifierPrivate)

public:
	void InitShaderManager();
	void ReleaseShaderManager();
	void StartSimulation();
	void StopSimulation();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroCS_liuShu">();
	}
	static class AKuroCS_liuShu* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKuroCS_liuShu>();
	}
};
static_assert(alignof(AKuroCS_liuShu) == 0x000008, "Wrong alignment on AKuroCS_liuShu");
static_assert(sizeof(AKuroCS_liuShu) == 0x000438, "Wrong size on AKuroCS_liuShu");
static_assert(offsetof(AKuroCS_liuShu, Root) == 0x0003A8, "Member 'AKuroCS_liuShu::Root' has a wrong offset!");
static_assert(offsetof(AKuroCS_liuShu, useExternalRT) == 0x0003B0, "Member 'AKuroCS_liuShu::useExternalRT' has a wrong offset!");
static_assert(offsetof(AKuroCS_liuShu, RenderTarget) == 0x0003B8, "Member 'AKuroCS_liuShu::RenderTarget' has a wrong offset!");
static_assert(offsetof(AKuroCS_liuShu, DisStiffness) == 0x0003C0, "Member 'AKuroCS_liuShu::DisStiffness' has a wrong offset!");
static_assert(offsetof(AKuroCS_liuShu, playerPos) == 0x0003C4, "Member 'AKuroCS_liuShu::playerPos' has a wrong offset!");
static_assert(offsetof(AKuroCS_liuShu, collisionR) == 0x0003D0, "Member 'AKuroCS_liuShu::collisionR' has a wrong offset!");
static_assert(offsetof(AKuroCS_liuShu, ParticleCount) == 0x0003D4, "Member 'AKuroCS_liuShu::ParticleCount' has a wrong offset!");
static_assert(offsetof(AKuroCS_liuShu, accel_ext) == 0x0003D8, "Member 'AKuroCS_liuShu::accel_ext' has a wrong offset!");
static_assert(offsetof(AKuroCS_liuShu, volDamping) == 0x0003E4, "Member 'AKuroCS_liuShu::volDamping' has a wrong offset!");
static_assert(offsetof(AKuroCS_liuShu, CustomDetalTime) == 0x0003E8, "Member 'AKuroCS_liuShu::CustomDetalTime' has a wrong offset!");
static_assert(offsetof(AKuroCS_liuShu, actorPos) == 0x0003EC, "Member 'AKuroCS_liuShu::actorPos' has a wrong offset!");
static_assert(offsetof(AKuroCS_liuShu, WindForce) == 0x0003F8, "Member 'AKuroCS_liuShu::WindForce' has a wrong offset!");
static_assert(offsetof(AKuroCS_liuShu, SubstepCount) == 0x000404, "Member 'AKuroCS_liuShu::SubstepCount' has a wrong offset!");
static_assert(offsetof(AKuroCS_liuShu, particleCountPerChain) == 0x000408, "Member 'AKuroCS_liuShu::particleCountPerChain' has a wrong offset!");
static_assert(offsetof(AKuroCS_liuShu, ParticlesArr) == 0x000418, "Member 'AKuroCS_liuShu::ParticlesArr' has a wrong offset!");
static_assert(offsetof(AKuroCS_liuShu, DebugArr) == 0x000428, "Member 'AKuroCS_liuShu::DebugArr' has a wrong offset!");

// Class KuroComputeShader.KuroCSChain
// 0x00B0 (0x0360 - 0x02B0)
class AKuroCSChain final : public AActor
{
public:
	class USceneComponent*                        Root;                                              // 0x02B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          useExternalRT;                                     // 0x02B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B9[0x7];                                      // 0x02B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextureRenderTarget2D*                 RenderTarget;                                      // 0x02C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextureRenderTarget2D*                 RenderTarget_N;                                    // 0x02C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FKuroCSParticle_chain>          DebugArr;                                          // 0x02D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         DisStiffness;                                      // 0x02E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         bendStiffness;                                     // 0x02E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                playerPos;                                         // 0x02E8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         collisionR;                                        // 0x02F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ParticleCount;                                     // 0x02F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         linkDis;                                           // 0x02FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         initDis;                                           // 0x0300(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         substepCount;                                      // 0x0304(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                accel_ext;                                         // 0x0308(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                actorPos;                                          // 0x0314(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableCPURead;                                    // 0x0320(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_321[0x3];                                      // 0x0321(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                playerDir;                                         // 0x0324(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                startPos;                                          // 0x0330(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                dynamicGravity;                                    // 0x033C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FKuroCSParticle_chain>          ParticlesArr;                                      // 0x0348(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_358[0x8];                                      // 0x0358(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitShaderManager();
	void ReleaseShaderManager();
	void StartSimulation();
	void StopSimulation();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroCSChain">();
	}
	static class AKuroCSChain* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKuroCSChain>();
	}
};
static_assert(alignof(AKuroCSChain) == 0x000008, "Wrong alignment on AKuroCSChain");
static_assert(sizeof(AKuroCSChain) == 0x000360, "Wrong size on AKuroCSChain");
static_assert(offsetof(AKuroCSChain, Root) == 0x0002B0, "Member 'AKuroCSChain::Root' has a wrong offset!");
static_assert(offsetof(AKuroCSChain, useExternalRT) == 0x0002B8, "Member 'AKuroCSChain::useExternalRT' has a wrong offset!");
static_assert(offsetof(AKuroCSChain, RenderTarget) == 0x0002C0, "Member 'AKuroCSChain::RenderTarget' has a wrong offset!");
static_assert(offsetof(AKuroCSChain, RenderTarget_N) == 0x0002C8, "Member 'AKuroCSChain::RenderTarget_N' has a wrong offset!");
static_assert(offsetof(AKuroCSChain, DebugArr) == 0x0002D0, "Member 'AKuroCSChain::DebugArr' has a wrong offset!");
static_assert(offsetof(AKuroCSChain, DisStiffness) == 0x0002E0, "Member 'AKuroCSChain::DisStiffness' has a wrong offset!");
static_assert(offsetof(AKuroCSChain, bendStiffness) == 0x0002E4, "Member 'AKuroCSChain::bendStiffness' has a wrong offset!");
static_assert(offsetof(AKuroCSChain, playerPos) == 0x0002E8, "Member 'AKuroCSChain::playerPos' has a wrong offset!");
static_assert(offsetof(AKuroCSChain, collisionR) == 0x0002F4, "Member 'AKuroCSChain::collisionR' has a wrong offset!");
static_assert(offsetof(AKuroCSChain, ParticleCount) == 0x0002F8, "Member 'AKuroCSChain::ParticleCount' has a wrong offset!");
static_assert(offsetof(AKuroCSChain, linkDis) == 0x0002FC, "Member 'AKuroCSChain::linkDis' has a wrong offset!");
static_assert(offsetof(AKuroCSChain, initDis) == 0x000300, "Member 'AKuroCSChain::initDis' has a wrong offset!");
static_assert(offsetof(AKuroCSChain, substepCount) == 0x000304, "Member 'AKuroCSChain::substepCount' has a wrong offset!");
static_assert(offsetof(AKuroCSChain, accel_ext) == 0x000308, "Member 'AKuroCSChain::accel_ext' has a wrong offset!");
static_assert(offsetof(AKuroCSChain, actorPos) == 0x000314, "Member 'AKuroCSChain::actorPos' has a wrong offset!");
static_assert(offsetof(AKuroCSChain, bEnableCPURead) == 0x000320, "Member 'AKuroCSChain::bEnableCPURead' has a wrong offset!");
static_assert(offsetof(AKuroCSChain, playerDir) == 0x000324, "Member 'AKuroCSChain::playerDir' has a wrong offset!");
static_assert(offsetof(AKuroCSChain, startPos) == 0x000330, "Member 'AKuroCSChain::startPos' has a wrong offset!");
static_assert(offsetof(AKuroCSChain, dynamicGravity) == 0x00033C, "Member 'AKuroCSChain::dynamicGravity' has a wrong offset!");
static_assert(offsetof(AKuroCSChain, ParticlesArr) == 0x000348, "Member 'AKuroCSChain::ParticlesArr' has a wrong offset!");

// Class KuroComputeShader.KuroCSChain30
// 0x00B8 (0x0460 - 0x03A8)
class AKuroCSChain30 final : public AKuroBPActor
{
public:
	class USceneComponent*                        Root;                                              // 0x03A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          useExternalRT;                                     // 0x03B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B1[0x7];                                      // 0x03B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextureRenderTarget2D*                 RenderTarget;                                      // 0x03B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextureRenderTarget2D*                 RenderTarget_N;                                    // 0x03C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextureRenderTarget2D*                 RenderTarget_P;                                    // 0x03C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FKuroCSParticle_chain30>        DebugArr;                                          // 0x03D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FKuroCSParticle_chain30>        ParticlesArr;                                      // 0x03E0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         DisStiffness;                                      // 0x03F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         bendStiffness;                                     // 0x03F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                playerPos;                                         // 0x03F8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         collisionR;                                        // 0x0404(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ParticleCount;                                     // 0x0408(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         linkDis;                                           // 0x040C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         substepCount;                                      // 0x0410(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                accel_ext;                                         // 0x0414(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                actorPos;                                          // 0x0420(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableCPURead;                                    // 0x042C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42D[0x3];                                      // 0x042D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                startPos;                                          // 0x0430(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                endPos;                                            // 0x043C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                dynamicGravity;                                    // 0x0448(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_454[0xC];                                      // 0x0454(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitShaderManager();
	void ReleaseShaderManager();
	void StartSimulation();
	void StopSimulation();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroCSChain30">();
	}
	static class AKuroCSChain30* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKuroCSChain30>();
	}
};
static_assert(alignof(AKuroCSChain30) == 0x000008, "Wrong alignment on AKuroCSChain30");
static_assert(sizeof(AKuroCSChain30) == 0x000460, "Wrong size on AKuroCSChain30");
static_assert(offsetof(AKuroCSChain30, Root) == 0x0003A8, "Member 'AKuroCSChain30::Root' has a wrong offset!");
static_assert(offsetof(AKuroCSChain30, useExternalRT) == 0x0003B0, "Member 'AKuroCSChain30::useExternalRT' has a wrong offset!");
static_assert(offsetof(AKuroCSChain30, RenderTarget) == 0x0003B8, "Member 'AKuroCSChain30::RenderTarget' has a wrong offset!");
static_assert(offsetof(AKuroCSChain30, RenderTarget_N) == 0x0003C0, "Member 'AKuroCSChain30::RenderTarget_N' has a wrong offset!");
static_assert(offsetof(AKuroCSChain30, RenderTarget_P) == 0x0003C8, "Member 'AKuroCSChain30::RenderTarget_P' has a wrong offset!");
static_assert(offsetof(AKuroCSChain30, DebugArr) == 0x0003D0, "Member 'AKuroCSChain30::DebugArr' has a wrong offset!");
static_assert(offsetof(AKuroCSChain30, ParticlesArr) == 0x0003E0, "Member 'AKuroCSChain30::ParticlesArr' has a wrong offset!");
static_assert(offsetof(AKuroCSChain30, DisStiffness) == 0x0003F0, "Member 'AKuroCSChain30::DisStiffness' has a wrong offset!");
static_assert(offsetof(AKuroCSChain30, bendStiffness) == 0x0003F4, "Member 'AKuroCSChain30::bendStiffness' has a wrong offset!");
static_assert(offsetof(AKuroCSChain30, playerPos) == 0x0003F8, "Member 'AKuroCSChain30::playerPos' has a wrong offset!");
static_assert(offsetof(AKuroCSChain30, collisionR) == 0x000404, "Member 'AKuroCSChain30::collisionR' has a wrong offset!");
static_assert(offsetof(AKuroCSChain30, ParticleCount) == 0x000408, "Member 'AKuroCSChain30::ParticleCount' has a wrong offset!");
static_assert(offsetof(AKuroCSChain30, linkDis) == 0x00040C, "Member 'AKuroCSChain30::linkDis' has a wrong offset!");
static_assert(offsetof(AKuroCSChain30, substepCount) == 0x000410, "Member 'AKuroCSChain30::substepCount' has a wrong offset!");
static_assert(offsetof(AKuroCSChain30, accel_ext) == 0x000414, "Member 'AKuroCSChain30::accel_ext' has a wrong offset!");
static_assert(offsetof(AKuroCSChain30, actorPos) == 0x000420, "Member 'AKuroCSChain30::actorPos' has a wrong offset!");
static_assert(offsetof(AKuroCSChain30, bEnableCPURead) == 0x00042C, "Member 'AKuroCSChain30::bEnableCPURead' has a wrong offset!");
static_assert(offsetof(AKuroCSChain30, startPos) == 0x000430, "Member 'AKuroCSChain30::startPos' has a wrong offset!");
static_assert(offsetof(AKuroCSChain30, endPos) == 0x00043C, "Member 'AKuroCSChain30::endPos' has a wrong offset!");
static_assert(offsetof(AKuroCSChain30, dynamicGravity) == 0x000448, "Member 'AKuroCSChain30::dynamicGravity' has a wrong offset!");

// Class KuroComputeShader.KuroCSCloth
// 0x00B0 (0x0360 - 0x02B0)
class AKuroCSCloth final : public AActor
{
public:
	class USceneComponent*                        Root;                                              // 0x02B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          useExternalRT;                                     // 0x02B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B9[0x7];                                      // 0x02B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextureRenderTarget2D*                 RenderTarget;                                      // 0x02C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextureRenderTarget2D*                 RenderTarget_N;                                    // 0x02C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FKuroCSParticle_cloth>          DebugArr;                                          // 0x02D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         XCount;                                            // 0x02E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         YCount;                                            // 0x02E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DisStiffness;                                      // 0x02E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                boxCenter;                                         // 0x02EC(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                boxHalfSize;                                       // 0x02F8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInverseBox;                                       // 0x0304(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_305[0x3];                                      // 0x0305(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         gravityZeroDistance;                               // 0x0308(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         collisionFriction;                                 // 0x030C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHypotenuseConstraint;                             // 0x0310(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_311[0x3];                                      // 0x0311(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         bendStiffness;                                     // 0x0314(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                playerPos;                                         // 0x0318(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         collisionR;                                        // 0x0324(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ParticleCount;                                     // 0x0328(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         linkDis;                                           // 0x032C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         linkDisY;                                          // 0x0330(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         substepCount;                                      // 0x0334(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                accel_ext;                                         // 0x0338(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                actorPos;                                          // 0x0344(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         deltaTime;                                         // 0x0350(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bYZPlane;                                          // 0x0354(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_355[0xB];                                      // 0x0355(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitShaderManager();
	void ReleaseShaderManager();
	void StartSimulation();
	void StopSimulation();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroCSCloth">();
	}
	static class AKuroCSCloth* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKuroCSCloth>();
	}
};
static_assert(alignof(AKuroCSCloth) == 0x000008, "Wrong alignment on AKuroCSCloth");
static_assert(sizeof(AKuroCSCloth) == 0x000360, "Wrong size on AKuroCSCloth");
static_assert(offsetof(AKuroCSCloth, Root) == 0x0002B0, "Member 'AKuroCSCloth::Root' has a wrong offset!");
static_assert(offsetof(AKuroCSCloth, useExternalRT) == 0x0002B8, "Member 'AKuroCSCloth::useExternalRT' has a wrong offset!");
static_assert(offsetof(AKuroCSCloth, RenderTarget) == 0x0002C0, "Member 'AKuroCSCloth::RenderTarget' has a wrong offset!");
static_assert(offsetof(AKuroCSCloth, RenderTarget_N) == 0x0002C8, "Member 'AKuroCSCloth::RenderTarget_N' has a wrong offset!");
static_assert(offsetof(AKuroCSCloth, DebugArr) == 0x0002D0, "Member 'AKuroCSCloth::DebugArr' has a wrong offset!");
static_assert(offsetof(AKuroCSCloth, XCount) == 0x0002E0, "Member 'AKuroCSCloth::XCount' has a wrong offset!");
static_assert(offsetof(AKuroCSCloth, YCount) == 0x0002E4, "Member 'AKuroCSCloth::YCount' has a wrong offset!");
static_assert(offsetof(AKuroCSCloth, DisStiffness) == 0x0002E8, "Member 'AKuroCSCloth::DisStiffness' has a wrong offset!");
static_assert(offsetof(AKuroCSCloth, boxCenter) == 0x0002EC, "Member 'AKuroCSCloth::boxCenter' has a wrong offset!");
static_assert(offsetof(AKuroCSCloth, boxHalfSize) == 0x0002F8, "Member 'AKuroCSCloth::boxHalfSize' has a wrong offset!");
static_assert(offsetof(AKuroCSCloth, bInverseBox) == 0x000304, "Member 'AKuroCSCloth::bInverseBox' has a wrong offset!");
static_assert(offsetof(AKuroCSCloth, gravityZeroDistance) == 0x000308, "Member 'AKuroCSCloth::gravityZeroDistance' has a wrong offset!");
static_assert(offsetof(AKuroCSCloth, collisionFriction) == 0x00030C, "Member 'AKuroCSCloth::collisionFriction' has a wrong offset!");
static_assert(offsetof(AKuroCSCloth, bHypotenuseConstraint) == 0x000310, "Member 'AKuroCSCloth::bHypotenuseConstraint' has a wrong offset!");
static_assert(offsetof(AKuroCSCloth, bendStiffness) == 0x000314, "Member 'AKuroCSCloth::bendStiffness' has a wrong offset!");
static_assert(offsetof(AKuroCSCloth, playerPos) == 0x000318, "Member 'AKuroCSCloth::playerPos' has a wrong offset!");
static_assert(offsetof(AKuroCSCloth, collisionR) == 0x000324, "Member 'AKuroCSCloth::collisionR' has a wrong offset!");
static_assert(offsetof(AKuroCSCloth, ParticleCount) == 0x000328, "Member 'AKuroCSCloth::ParticleCount' has a wrong offset!");
static_assert(offsetof(AKuroCSCloth, linkDis) == 0x00032C, "Member 'AKuroCSCloth::linkDis' has a wrong offset!");
static_assert(offsetof(AKuroCSCloth, linkDisY) == 0x000330, "Member 'AKuroCSCloth::linkDisY' has a wrong offset!");
static_assert(offsetof(AKuroCSCloth, substepCount) == 0x000334, "Member 'AKuroCSCloth::substepCount' has a wrong offset!");
static_assert(offsetof(AKuroCSCloth, accel_ext) == 0x000338, "Member 'AKuroCSCloth::accel_ext' has a wrong offset!");
static_assert(offsetof(AKuroCSCloth, actorPos) == 0x000344, "Member 'AKuroCSCloth::actorPos' has a wrong offset!");
static_assert(offsetof(AKuroCSCloth, deltaTime) == 0x000350, "Member 'AKuroCSCloth::deltaTime' has a wrong offset!");
static_assert(offsetof(AKuroCSCloth, bYZPlane) == 0x000354, "Member 'AKuroCSCloth::bYZPlane' has a wrong offset!");

// Class KuroComputeShader.KuroCSDoubleChain
// 0x0090 (0x0340 - 0x02B0)
class AKuroCSDoubleChain final : public AActor
{
public:
	class USceneComponent*                        Root;                                              // 0x02B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          useExternalRT;                                     // 0x02B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B9[0x7];                                      // 0x02B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextureRenderTarget2D*                 RenderTarget;                                      // 0x02C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FKuroCSParticle_doubleChain>    DebugArr;                                          // 0x02C8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         XCount;                                            // 0x02D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         YCount;                                            // 0x02DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DisStiffness;                                      // 0x02E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         bendStiffness;                                     // 0x02E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                playerPos;                                         // 0x02E8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         collisionR;                                        // 0x02F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ParticleCount;                                     // 0x02F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         linkDis;                                           // 0x02FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         substepCount;                                      // 0x0300(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                accel_ext;                                         // 0x0304(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                actorPos;                                          // 0x0310(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SecondArrayStart;                                  // 0x031C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SecondArrayIndex;                                  // 0x0328(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LocalPosOffset;                                    // 0x032C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_338[0x8];                                      // 0x0338(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void StartSimulation();
	void StopSimulation();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroCSDoubleChain">();
	}
	static class AKuroCSDoubleChain* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKuroCSDoubleChain>();
	}
};
static_assert(alignof(AKuroCSDoubleChain) == 0x000008, "Wrong alignment on AKuroCSDoubleChain");
static_assert(sizeof(AKuroCSDoubleChain) == 0x000340, "Wrong size on AKuroCSDoubleChain");
static_assert(offsetof(AKuroCSDoubleChain, Root) == 0x0002B0, "Member 'AKuroCSDoubleChain::Root' has a wrong offset!");
static_assert(offsetof(AKuroCSDoubleChain, useExternalRT) == 0x0002B8, "Member 'AKuroCSDoubleChain::useExternalRT' has a wrong offset!");
static_assert(offsetof(AKuroCSDoubleChain, RenderTarget) == 0x0002C0, "Member 'AKuroCSDoubleChain::RenderTarget' has a wrong offset!");
static_assert(offsetof(AKuroCSDoubleChain, DebugArr) == 0x0002C8, "Member 'AKuroCSDoubleChain::DebugArr' has a wrong offset!");
static_assert(offsetof(AKuroCSDoubleChain, XCount) == 0x0002D8, "Member 'AKuroCSDoubleChain::XCount' has a wrong offset!");
static_assert(offsetof(AKuroCSDoubleChain, YCount) == 0x0002DC, "Member 'AKuroCSDoubleChain::YCount' has a wrong offset!");
static_assert(offsetof(AKuroCSDoubleChain, DisStiffness) == 0x0002E0, "Member 'AKuroCSDoubleChain::DisStiffness' has a wrong offset!");
static_assert(offsetof(AKuroCSDoubleChain, bendStiffness) == 0x0002E4, "Member 'AKuroCSDoubleChain::bendStiffness' has a wrong offset!");
static_assert(offsetof(AKuroCSDoubleChain, playerPos) == 0x0002E8, "Member 'AKuroCSDoubleChain::playerPos' has a wrong offset!");
static_assert(offsetof(AKuroCSDoubleChain, collisionR) == 0x0002F4, "Member 'AKuroCSDoubleChain::collisionR' has a wrong offset!");
static_assert(offsetof(AKuroCSDoubleChain, ParticleCount) == 0x0002F8, "Member 'AKuroCSDoubleChain::ParticleCount' has a wrong offset!");
static_assert(offsetof(AKuroCSDoubleChain, linkDis) == 0x0002FC, "Member 'AKuroCSDoubleChain::linkDis' has a wrong offset!");
static_assert(offsetof(AKuroCSDoubleChain, substepCount) == 0x000300, "Member 'AKuroCSDoubleChain::substepCount' has a wrong offset!");
static_assert(offsetof(AKuroCSDoubleChain, accel_ext) == 0x000304, "Member 'AKuroCSDoubleChain::accel_ext' has a wrong offset!");
static_assert(offsetof(AKuroCSDoubleChain, actorPos) == 0x000310, "Member 'AKuroCSDoubleChain::actorPos' has a wrong offset!");
static_assert(offsetof(AKuroCSDoubleChain, SecondArrayStart) == 0x00031C, "Member 'AKuroCSDoubleChain::SecondArrayStart' has a wrong offset!");
static_assert(offsetof(AKuroCSDoubleChain, SecondArrayIndex) == 0x000328, "Member 'AKuroCSDoubleChain::SecondArrayIndex' has a wrong offset!");
static_assert(offsetof(AKuroCSDoubleChain, LocalPosOffset) == 0x00032C, "Member 'AKuroCSDoubleChain::LocalPosOffset' has a wrong offset!");

// Class KuroComputeShader.KuroCSGenericCloth
// 0x00D8 (0x0480 - 0x03A8)
class AKuroCSGenericCloth final : public AKuroBPActor
{
public:
	class USceneComponent*                        Root;                                              // 0x03A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          useExternalRT;                                     // 0x03B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B1[0x7];                                      // 0x03B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextureRenderTarget2D*                 RenderTarget;                                      // 0x03B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextureRenderTarget2D*                 RenderTarget_N;                                    // 0x03C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FKuroCSParticle_genericCloth>   DebugArr;                                          // 0x03C8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         DisStiffness;                                      // 0x03D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         revertOrNot;                                       // 0x03DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                playerPos;                                         // 0x03E0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         collisionR;                                        // 0x03EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ParticleCount;                                     // 0x03F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         linkDis;                                           // 0x03F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         moveableDis;                                       // 0x03F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         substepCount;                                      // 0x03FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                accel_ext;                                         // 0x0400(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                actorPos;                                          // 0x040C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                actorRotator;                                      // 0x0418(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableCPURead;                                    // 0x0424(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_425[0x3];                                      // 0x0425(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         XCount;                                            // 0x0428(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         springK;                                           // 0x042C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         springC;                                           // 0x0430(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         pushStrength;                                      // 0x0434(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RT2DOrNot;                                         // 0x0438(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         lockXYZ;                                           // 0x043C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         deltaTime;                                         // 0x0440(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         attackOrNot;                                       // 0x0444(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         overlapOrNot;                                      // 0x0448(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44C[0x4];                                      // 0x044C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FKuroCSParticle_genericCloth>   ParticlesArr;                                      // 0x0450(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FKuroCSUnifiedCollider_genericCloth> Colliders;                                    // 0x0460(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         useStaticCol;                                      // 0x0470(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_474[0xC];                                      // 0x0474(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitShaderManager();
	void ReleaseShaderManager();
	void StartSimulation();
	void StopSimulation();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroCSGenericCloth">();
	}
	static class AKuroCSGenericCloth* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKuroCSGenericCloth>();
	}
};
static_assert(alignof(AKuroCSGenericCloth) == 0x000008, "Wrong alignment on AKuroCSGenericCloth");
static_assert(sizeof(AKuroCSGenericCloth) == 0x000480, "Wrong size on AKuroCSGenericCloth");
static_assert(offsetof(AKuroCSGenericCloth, Root) == 0x0003A8, "Member 'AKuroCSGenericCloth::Root' has a wrong offset!");
static_assert(offsetof(AKuroCSGenericCloth, useExternalRT) == 0x0003B0, "Member 'AKuroCSGenericCloth::useExternalRT' has a wrong offset!");
static_assert(offsetof(AKuroCSGenericCloth, RenderTarget) == 0x0003B8, "Member 'AKuroCSGenericCloth::RenderTarget' has a wrong offset!");
static_assert(offsetof(AKuroCSGenericCloth, RenderTarget_N) == 0x0003C0, "Member 'AKuroCSGenericCloth::RenderTarget_N' has a wrong offset!");
static_assert(offsetof(AKuroCSGenericCloth, DebugArr) == 0x0003C8, "Member 'AKuroCSGenericCloth::DebugArr' has a wrong offset!");
static_assert(offsetof(AKuroCSGenericCloth, DisStiffness) == 0x0003D8, "Member 'AKuroCSGenericCloth::DisStiffness' has a wrong offset!");
static_assert(offsetof(AKuroCSGenericCloth, revertOrNot) == 0x0003DC, "Member 'AKuroCSGenericCloth::revertOrNot' has a wrong offset!");
static_assert(offsetof(AKuroCSGenericCloth, playerPos) == 0x0003E0, "Member 'AKuroCSGenericCloth::playerPos' has a wrong offset!");
static_assert(offsetof(AKuroCSGenericCloth, collisionR) == 0x0003EC, "Member 'AKuroCSGenericCloth::collisionR' has a wrong offset!");
static_assert(offsetof(AKuroCSGenericCloth, ParticleCount) == 0x0003F0, "Member 'AKuroCSGenericCloth::ParticleCount' has a wrong offset!");
static_assert(offsetof(AKuroCSGenericCloth, linkDis) == 0x0003F4, "Member 'AKuroCSGenericCloth::linkDis' has a wrong offset!");
static_assert(offsetof(AKuroCSGenericCloth, moveableDis) == 0x0003F8, "Member 'AKuroCSGenericCloth::moveableDis' has a wrong offset!");
static_assert(offsetof(AKuroCSGenericCloth, substepCount) == 0x0003FC, "Member 'AKuroCSGenericCloth::substepCount' has a wrong offset!");
static_assert(offsetof(AKuroCSGenericCloth, accel_ext) == 0x000400, "Member 'AKuroCSGenericCloth::accel_ext' has a wrong offset!");
static_assert(offsetof(AKuroCSGenericCloth, actorPos) == 0x00040C, "Member 'AKuroCSGenericCloth::actorPos' has a wrong offset!");
static_assert(offsetof(AKuroCSGenericCloth, actorRotator) == 0x000418, "Member 'AKuroCSGenericCloth::actorRotator' has a wrong offset!");
static_assert(offsetof(AKuroCSGenericCloth, bEnableCPURead) == 0x000424, "Member 'AKuroCSGenericCloth::bEnableCPURead' has a wrong offset!");
static_assert(offsetof(AKuroCSGenericCloth, XCount) == 0x000428, "Member 'AKuroCSGenericCloth::XCount' has a wrong offset!");
static_assert(offsetof(AKuroCSGenericCloth, springK) == 0x00042C, "Member 'AKuroCSGenericCloth::springK' has a wrong offset!");
static_assert(offsetof(AKuroCSGenericCloth, springC) == 0x000430, "Member 'AKuroCSGenericCloth::springC' has a wrong offset!");
static_assert(offsetof(AKuroCSGenericCloth, pushStrength) == 0x000434, "Member 'AKuroCSGenericCloth::pushStrength' has a wrong offset!");
static_assert(offsetof(AKuroCSGenericCloth, RT2DOrNot) == 0x000438, "Member 'AKuroCSGenericCloth::RT2DOrNot' has a wrong offset!");
static_assert(offsetof(AKuroCSGenericCloth, lockXYZ) == 0x00043C, "Member 'AKuroCSGenericCloth::lockXYZ' has a wrong offset!");
static_assert(offsetof(AKuroCSGenericCloth, deltaTime) == 0x000440, "Member 'AKuroCSGenericCloth::deltaTime' has a wrong offset!");
static_assert(offsetof(AKuroCSGenericCloth, attackOrNot) == 0x000444, "Member 'AKuroCSGenericCloth::attackOrNot' has a wrong offset!");
static_assert(offsetof(AKuroCSGenericCloth, overlapOrNot) == 0x000448, "Member 'AKuroCSGenericCloth::overlapOrNot' has a wrong offset!");
static_assert(offsetof(AKuroCSGenericCloth, ParticlesArr) == 0x000450, "Member 'AKuroCSGenericCloth::ParticlesArr' has a wrong offset!");
static_assert(offsetof(AKuroCSGenericCloth, Colliders) == 0x000460, "Member 'AKuroCSGenericCloth::Colliders' has a wrong offset!");
static_assert(offsetof(AKuroCSGenericCloth, useStaticCol) == 0x000470, "Member 'AKuroCSGenericCloth::useStaticCol' has a wrong offset!");

// Class KuroComputeShader.KuroCSPlantAnim
// 0x00A8 (0x0358 - 0x02B0)
class AKuroCSPlantAnim final : public AActor
{
public:
	class USceneComponent*                        Root;                                              // 0x02B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextureRenderTarget2D*                 RenderTarget;                                      // 0x02B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ParticleCount;                                     // 0x02C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PlayerPos;                                         // 0x02C4(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CollisionR;                                        // 0x02D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PushStrength;                                      // 0x02D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LeafPointCount;                                    // 0x02D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimFPS;                                           // 0x02DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AnimFrameCount;                                    // 0x02E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ParentRotWeight;                                   // 0x02E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BranchStiffness;                                   // 0x02E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EC[0x4];                                      // 0x02EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             AniTex;                                            // 0x02F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             NormTex;                                           // 0x02F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        PosArray;                                          // 0x0300(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        NormArray;                                         // 0x0310(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        DirArray;                                          // 0x0320(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bEnableCPURead;                                    // 0x0330(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_331[0x7];                                      // 0x0331(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FKuroCSParticle_PlantAnim>      DebugArr;                                          // 0x0338(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_348[0x10];                                     // 0x0348(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AfterBeginPlay();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroCSPlantAnim">();
	}
	static class AKuroCSPlantAnim* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKuroCSPlantAnim>();
	}
};
static_assert(alignof(AKuroCSPlantAnim) == 0x000008, "Wrong alignment on AKuroCSPlantAnim");
static_assert(sizeof(AKuroCSPlantAnim) == 0x000358, "Wrong size on AKuroCSPlantAnim");
static_assert(offsetof(AKuroCSPlantAnim, Root) == 0x0002B0, "Member 'AKuroCSPlantAnim::Root' has a wrong offset!");
static_assert(offsetof(AKuroCSPlantAnim, RenderTarget) == 0x0002B8, "Member 'AKuroCSPlantAnim::RenderTarget' has a wrong offset!");
static_assert(offsetof(AKuroCSPlantAnim, ParticleCount) == 0x0002C0, "Member 'AKuroCSPlantAnim::ParticleCount' has a wrong offset!");
static_assert(offsetof(AKuroCSPlantAnim, PlayerPos) == 0x0002C4, "Member 'AKuroCSPlantAnim::PlayerPos' has a wrong offset!");
static_assert(offsetof(AKuroCSPlantAnim, CollisionR) == 0x0002D0, "Member 'AKuroCSPlantAnim::CollisionR' has a wrong offset!");
static_assert(offsetof(AKuroCSPlantAnim, PushStrength) == 0x0002D4, "Member 'AKuroCSPlantAnim::PushStrength' has a wrong offset!");
static_assert(offsetof(AKuroCSPlantAnim, LeafPointCount) == 0x0002D8, "Member 'AKuroCSPlantAnim::LeafPointCount' has a wrong offset!");
static_assert(offsetof(AKuroCSPlantAnim, AnimFPS) == 0x0002DC, "Member 'AKuroCSPlantAnim::AnimFPS' has a wrong offset!");
static_assert(offsetof(AKuroCSPlantAnim, AnimFrameCount) == 0x0002E0, "Member 'AKuroCSPlantAnim::AnimFrameCount' has a wrong offset!");
static_assert(offsetof(AKuroCSPlantAnim, ParentRotWeight) == 0x0002E4, "Member 'AKuroCSPlantAnim::ParentRotWeight' has a wrong offset!");
static_assert(offsetof(AKuroCSPlantAnim, BranchStiffness) == 0x0002E8, "Member 'AKuroCSPlantAnim::BranchStiffness' has a wrong offset!");
static_assert(offsetof(AKuroCSPlantAnim, AniTex) == 0x0002F0, "Member 'AKuroCSPlantAnim::AniTex' has a wrong offset!");
static_assert(offsetof(AKuroCSPlantAnim, NormTex) == 0x0002F8, "Member 'AKuroCSPlantAnim::NormTex' has a wrong offset!");
static_assert(offsetof(AKuroCSPlantAnim, PosArray) == 0x000300, "Member 'AKuroCSPlantAnim::PosArray' has a wrong offset!");
static_assert(offsetof(AKuroCSPlantAnim, NormArray) == 0x000310, "Member 'AKuroCSPlantAnim::NormArray' has a wrong offset!");
static_assert(offsetof(AKuroCSPlantAnim, DirArray) == 0x000320, "Member 'AKuroCSPlantAnim::DirArray' has a wrong offset!");
static_assert(offsetof(AKuroCSPlantAnim, bEnableCPURead) == 0x000330, "Member 'AKuroCSPlantAnim::bEnableCPURead' has a wrong offset!");
static_assert(offsetof(AKuroCSPlantAnim, DebugArr) == 0x000338, "Member 'AKuroCSPlantAnim::DebugArr' has a wrong offset!");

// Class KuroComputeShader.KuroCSReadback
// 0x0028 (0x02D8 - 0x02B0)
class AKuroCSReadback final : public AActor
{
public:
	class USceneComponent*                        Root;                                              // 0x02B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextureRenderTarget2D*                 ReadbackTexture;                                   // 0x02B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReadbackX;                                         // 0x02C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReadbackY;                                         // 0x02C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReadbackValue;                                     // 0x02C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CC[0xC];                                      // 0x02CC(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitShaderManager();
	void ReleaseShaderManager();
	void StartSimulation();
	void StopSimulation();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroCSReadback">();
	}
	static class AKuroCSReadback* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKuroCSReadback>();
	}
};
static_assert(alignof(AKuroCSReadback) == 0x000008, "Wrong alignment on AKuroCSReadback");
static_assert(sizeof(AKuroCSReadback) == 0x0002D8, "Wrong size on AKuroCSReadback");
static_assert(offsetof(AKuroCSReadback, Root) == 0x0002B0, "Member 'AKuroCSReadback::Root' has a wrong offset!");
static_assert(offsetof(AKuroCSReadback, ReadbackTexture) == 0x0002B8, "Member 'AKuroCSReadback::ReadbackTexture' has a wrong offset!");
static_assert(offsetof(AKuroCSReadback, ReadbackX) == 0x0002C0, "Member 'AKuroCSReadback::ReadbackX' has a wrong offset!");
static_assert(offsetof(AKuroCSReadback, ReadbackY) == 0x0002C4, "Member 'AKuroCSReadback::ReadbackY' has a wrong offset!");
static_assert(offsetof(AKuroCSReadback, ReadbackValue) == 0x0002C8, "Member 'AKuroCSReadback::ReadbackValue' has a wrong offset!");

// Class KuroComputeShader.KuroCSRpbd
// 0x00B8 (0x0460 - 0x03A8)
class AKuroCSRpbd final : public AKuroBPActor
{
public:
	class USceneComponent*                        Root;                                              // 0x03A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          useExternalRT;                                     // 0x03B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B1[0x7];                                      // 0x03B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextureRenderTarget2D*                 RenderTarget;                                      // 0x03B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FKuroCSParticle_rpbd>           DebugArr;                                          // 0x03C0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         DisStiffness;                                      // 0x03D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         revertOrNot;                                       // 0x03D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                playerPos;                                         // 0x03D8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         collisionR;                                        // 0x03E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ParticleCount;                                     // 0x03E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         linkDis;                                           // 0x03EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         moveableDis;                                       // 0x03F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         substepCount;                                      // 0x03F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                accel_ext;                                         // 0x03F8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                actorPos;                                          // 0x0404(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                actorRotator;                                      // 0x0410(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableCPURead;                                    // 0x041C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41D[0x3];                                      // 0x041D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         XCount;                                            // 0x0420(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         springK;                                           // 0x0424(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         springC;                                           // 0x0428(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         pushStrength;                                      // 0x042C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RT2DOrNot;                                         // 0x0430(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         lockXYZ;                                           // 0x0434(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         deltaTime;                                         // 0x0438(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         attackOrNot;                                       // 0x043C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         overlapOrNot;                                      // 0x0440(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_444[0x4];                                      // 0x0444(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FKuroCSParticle_rpbd>           ParticlesArr;                                      // 0x0448(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_458[0x8];                                      // 0x0458(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitShaderManager();
	void ReleaseShaderManager();
	void StartSimulation();
	void StopSimulation();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroCSRpbd">();
	}
	static class AKuroCSRpbd* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKuroCSRpbd>();
	}
};
static_assert(alignof(AKuroCSRpbd) == 0x000008, "Wrong alignment on AKuroCSRpbd");
static_assert(sizeof(AKuroCSRpbd) == 0x000460, "Wrong size on AKuroCSRpbd");
static_assert(offsetof(AKuroCSRpbd, Root) == 0x0003A8, "Member 'AKuroCSRpbd::Root' has a wrong offset!");
static_assert(offsetof(AKuroCSRpbd, useExternalRT) == 0x0003B0, "Member 'AKuroCSRpbd::useExternalRT' has a wrong offset!");
static_assert(offsetof(AKuroCSRpbd, RenderTarget) == 0x0003B8, "Member 'AKuroCSRpbd::RenderTarget' has a wrong offset!");
static_assert(offsetof(AKuroCSRpbd, DebugArr) == 0x0003C0, "Member 'AKuroCSRpbd::DebugArr' has a wrong offset!");
static_assert(offsetof(AKuroCSRpbd, DisStiffness) == 0x0003D0, "Member 'AKuroCSRpbd::DisStiffness' has a wrong offset!");
static_assert(offsetof(AKuroCSRpbd, revertOrNot) == 0x0003D4, "Member 'AKuroCSRpbd::revertOrNot' has a wrong offset!");
static_assert(offsetof(AKuroCSRpbd, playerPos) == 0x0003D8, "Member 'AKuroCSRpbd::playerPos' has a wrong offset!");
static_assert(offsetof(AKuroCSRpbd, collisionR) == 0x0003E4, "Member 'AKuroCSRpbd::collisionR' has a wrong offset!");
static_assert(offsetof(AKuroCSRpbd, ParticleCount) == 0x0003E8, "Member 'AKuroCSRpbd::ParticleCount' has a wrong offset!");
static_assert(offsetof(AKuroCSRpbd, linkDis) == 0x0003EC, "Member 'AKuroCSRpbd::linkDis' has a wrong offset!");
static_assert(offsetof(AKuroCSRpbd, moveableDis) == 0x0003F0, "Member 'AKuroCSRpbd::moveableDis' has a wrong offset!");
static_assert(offsetof(AKuroCSRpbd, substepCount) == 0x0003F4, "Member 'AKuroCSRpbd::substepCount' has a wrong offset!");
static_assert(offsetof(AKuroCSRpbd, accel_ext) == 0x0003F8, "Member 'AKuroCSRpbd::accel_ext' has a wrong offset!");
static_assert(offsetof(AKuroCSRpbd, actorPos) == 0x000404, "Member 'AKuroCSRpbd::actorPos' has a wrong offset!");
static_assert(offsetof(AKuroCSRpbd, actorRotator) == 0x000410, "Member 'AKuroCSRpbd::actorRotator' has a wrong offset!");
static_assert(offsetof(AKuroCSRpbd, bEnableCPURead) == 0x00041C, "Member 'AKuroCSRpbd::bEnableCPURead' has a wrong offset!");
static_assert(offsetof(AKuroCSRpbd, XCount) == 0x000420, "Member 'AKuroCSRpbd::XCount' has a wrong offset!");
static_assert(offsetof(AKuroCSRpbd, springK) == 0x000424, "Member 'AKuroCSRpbd::springK' has a wrong offset!");
static_assert(offsetof(AKuroCSRpbd, springC) == 0x000428, "Member 'AKuroCSRpbd::springC' has a wrong offset!");
static_assert(offsetof(AKuroCSRpbd, pushStrength) == 0x00042C, "Member 'AKuroCSRpbd::pushStrength' has a wrong offset!");
static_assert(offsetof(AKuroCSRpbd, RT2DOrNot) == 0x000430, "Member 'AKuroCSRpbd::RT2DOrNot' has a wrong offset!");
static_assert(offsetof(AKuroCSRpbd, lockXYZ) == 0x000434, "Member 'AKuroCSRpbd::lockXYZ' has a wrong offset!");
static_assert(offsetof(AKuroCSRpbd, deltaTime) == 0x000438, "Member 'AKuroCSRpbd::deltaTime' has a wrong offset!");
static_assert(offsetof(AKuroCSRpbd, attackOrNot) == 0x00043C, "Member 'AKuroCSRpbd::attackOrNot' has a wrong offset!");
static_assert(offsetof(AKuroCSRpbd, overlapOrNot) == 0x000440, "Member 'AKuroCSRpbd::overlapOrNot' has a wrong offset!");
static_assert(offsetof(AKuroCSRpbd, ParticlesArr) == 0x000448, "Member 'AKuroCSRpbd::ParticlesArr' has a wrong offset!");

// Class KuroComputeShader.KuroCSSkeltalPlant
// 0x00B0 (0x0360 - 0x02B0)
class AKuroCSSkeltalPlant final : public AActor
{
public:
	class USceneComponent*                        Root;                                              // 0x02B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B8[0x8];                                      // 0x02B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ParticleCount;                                     // 0x02C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C4[0x4];                                      // 0x02C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 ParentIDList;                                      // 0x02C8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 ChildIDList;                                       // 0x02D8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        PosList;                                           // 0x02E8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FQuat>                          QuatList;                                          // 0x02F8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 BoneMaskList;                                      // 0x0308(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         TickTime;                                          // 0x0318(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                playerPos;                                         // 0x031C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         collisionR;                                        // 0x0328(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         pushStrength;                                      // 0x032C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AffectChildStrength;                               // 0x0330(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_334[0x4];                                      // 0x0334(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextureRenderTarget2D*                 RenderTarget;                                      // 0x0338(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AllowDebugDraw;                                    // 0x0340(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_341[0x7];                                      // 0x0341(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FKuroCSParticle_skelPlant>      DebugArr;                                          // 0x0348(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_358[0x8];                                      // 0x0358(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void afterBeginPlay();
	void BeginRenderShader();
	void BuildParticleData();
	void EndRenderShader();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroCSSkeltalPlant">();
	}
	static class AKuroCSSkeltalPlant* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKuroCSSkeltalPlant>();
	}
};
static_assert(alignof(AKuroCSSkeltalPlant) == 0x000008, "Wrong alignment on AKuroCSSkeltalPlant");
static_assert(sizeof(AKuroCSSkeltalPlant) == 0x000360, "Wrong size on AKuroCSSkeltalPlant");
static_assert(offsetof(AKuroCSSkeltalPlant, Root) == 0x0002B0, "Member 'AKuroCSSkeltalPlant::Root' has a wrong offset!");
static_assert(offsetof(AKuroCSSkeltalPlant, ParticleCount) == 0x0002C0, "Member 'AKuroCSSkeltalPlant::ParticleCount' has a wrong offset!");
static_assert(offsetof(AKuroCSSkeltalPlant, ParentIDList) == 0x0002C8, "Member 'AKuroCSSkeltalPlant::ParentIDList' has a wrong offset!");
static_assert(offsetof(AKuroCSSkeltalPlant, ChildIDList) == 0x0002D8, "Member 'AKuroCSSkeltalPlant::ChildIDList' has a wrong offset!");
static_assert(offsetof(AKuroCSSkeltalPlant, PosList) == 0x0002E8, "Member 'AKuroCSSkeltalPlant::PosList' has a wrong offset!");
static_assert(offsetof(AKuroCSSkeltalPlant, QuatList) == 0x0002F8, "Member 'AKuroCSSkeltalPlant::QuatList' has a wrong offset!");
static_assert(offsetof(AKuroCSSkeltalPlant, BoneMaskList) == 0x000308, "Member 'AKuroCSSkeltalPlant::BoneMaskList' has a wrong offset!");
static_assert(offsetof(AKuroCSSkeltalPlant, TickTime) == 0x000318, "Member 'AKuroCSSkeltalPlant::TickTime' has a wrong offset!");
static_assert(offsetof(AKuroCSSkeltalPlant, playerPos) == 0x00031C, "Member 'AKuroCSSkeltalPlant::playerPos' has a wrong offset!");
static_assert(offsetof(AKuroCSSkeltalPlant, collisionR) == 0x000328, "Member 'AKuroCSSkeltalPlant::collisionR' has a wrong offset!");
static_assert(offsetof(AKuroCSSkeltalPlant, pushStrength) == 0x00032C, "Member 'AKuroCSSkeltalPlant::pushStrength' has a wrong offset!");
static_assert(offsetof(AKuroCSSkeltalPlant, AffectChildStrength) == 0x000330, "Member 'AKuroCSSkeltalPlant::AffectChildStrength' has a wrong offset!");
static_assert(offsetof(AKuroCSSkeltalPlant, RenderTarget) == 0x000338, "Member 'AKuroCSSkeltalPlant::RenderTarget' has a wrong offset!");
static_assert(offsetof(AKuroCSSkeltalPlant, AllowDebugDraw) == 0x000340, "Member 'AKuroCSSkeltalPlant::AllowDebugDraw' has a wrong offset!");
static_assert(offsetof(AKuroCSSkeltalPlant, DebugArr) == 0x000348, "Member 'AKuroCSSkeltalPlant::DebugArr' has a wrong offset!");

// Class KuroComputeShader.KuroCSWindbell
// 0x00A0 (0x0350 - 0x02B0)
class AKuroCSWindbell final : public AActor
{
public:
	class USceneComponent*                        Root;                                              // 0x02B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          useExternalRT;                                     // 0x02B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B9[0x7];                                      // 0x02B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextureRenderTarget2D*                 RenderTarget;                                      // 0x02C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextureRenderTarget2D*                 RenderTarget_N;                                    // 0x02C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FKuroCSParticle_windbell>       DebugArr;                                          // 0x02D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         DisStiffness;                                      // 0x02E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         bendStiffness;                                     // 0x02E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                playerPos;                                         // 0x02E8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         collisionR;                                        // 0x02F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ParticleCount;                                     // 0x02F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         linkDis;                                           // 0x02FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         substepCount;                                      // 0x0300(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                accel_ext;                                         // 0x0304(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                actorPos;                                          // 0x0310(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableCPURead;                                    // 0x031C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31D[0x3];                                      // 0x031D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                startPos;                                          // 0x0320(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                endPos;                                            // 0x032C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                dynamicGravity;                                    // 0x0338(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_344[0xC];                                      // 0x0344(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void StartSimulation();
	void StopSimulation();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroCSWindbell">();
	}
	static class AKuroCSWindbell* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKuroCSWindbell>();
	}
};
static_assert(alignof(AKuroCSWindbell) == 0x000008, "Wrong alignment on AKuroCSWindbell");
static_assert(sizeof(AKuroCSWindbell) == 0x000350, "Wrong size on AKuroCSWindbell");
static_assert(offsetof(AKuroCSWindbell, Root) == 0x0002B0, "Member 'AKuroCSWindbell::Root' has a wrong offset!");
static_assert(offsetof(AKuroCSWindbell, useExternalRT) == 0x0002B8, "Member 'AKuroCSWindbell::useExternalRT' has a wrong offset!");
static_assert(offsetof(AKuroCSWindbell, RenderTarget) == 0x0002C0, "Member 'AKuroCSWindbell::RenderTarget' has a wrong offset!");
static_assert(offsetof(AKuroCSWindbell, RenderTarget_N) == 0x0002C8, "Member 'AKuroCSWindbell::RenderTarget_N' has a wrong offset!");
static_assert(offsetof(AKuroCSWindbell, DebugArr) == 0x0002D0, "Member 'AKuroCSWindbell::DebugArr' has a wrong offset!");
static_assert(offsetof(AKuroCSWindbell, DisStiffness) == 0x0002E0, "Member 'AKuroCSWindbell::DisStiffness' has a wrong offset!");
static_assert(offsetof(AKuroCSWindbell, bendStiffness) == 0x0002E4, "Member 'AKuroCSWindbell::bendStiffness' has a wrong offset!");
static_assert(offsetof(AKuroCSWindbell, playerPos) == 0x0002E8, "Member 'AKuroCSWindbell::playerPos' has a wrong offset!");
static_assert(offsetof(AKuroCSWindbell, collisionR) == 0x0002F4, "Member 'AKuroCSWindbell::collisionR' has a wrong offset!");
static_assert(offsetof(AKuroCSWindbell, ParticleCount) == 0x0002F8, "Member 'AKuroCSWindbell::ParticleCount' has a wrong offset!");
static_assert(offsetof(AKuroCSWindbell, linkDis) == 0x0002FC, "Member 'AKuroCSWindbell::linkDis' has a wrong offset!");
static_assert(offsetof(AKuroCSWindbell, substepCount) == 0x000300, "Member 'AKuroCSWindbell::substepCount' has a wrong offset!");
static_assert(offsetof(AKuroCSWindbell, accel_ext) == 0x000304, "Member 'AKuroCSWindbell::accel_ext' has a wrong offset!");
static_assert(offsetof(AKuroCSWindbell, actorPos) == 0x000310, "Member 'AKuroCSWindbell::actorPos' has a wrong offset!");
static_assert(offsetof(AKuroCSWindbell, bEnableCPURead) == 0x00031C, "Member 'AKuroCSWindbell::bEnableCPURead' has a wrong offset!");
static_assert(offsetof(AKuroCSWindbell, startPos) == 0x000320, "Member 'AKuroCSWindbell::startPos' has a wrong offset!");
static_assert(offsetof(AKuroCSWindbell, endPos) == 0x00032C, "Member 'AKuroCSWindbell::endPos' has a wrong offset!");
static_assert(offsetof(AKuroCSWindbell, dynamicGravity) == 0x000338, "Member 'AKuroCSWindbell::dynamicGravity' has a wrong offset!");

// Class KuroComputeShader.KuroCSWindbell_set
// 0x00B0 (0x0458 - 0x03A8)
class AKuroCSWindbell_set final : public AKuroBPActor
{
public:
	class USceneComponent*                        Root;                                              // 0x03A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          useExternalRT;                                     // 0x03B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B1[0x7];                                      // 0x03B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextureRenderTarget2D*                 RenderTarget;                                      // 0x03B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextureRenderTarget2D*                 RenderTarget_N;                                    // 0x03C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FKuroCSParticle_windbell_set>   DebugArr;                                          // 0x03C8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         DisStiffness;                                      // 0x03D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         bendStiffness;                                     // 0x03DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                playerPos;                                         // 0x03E0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         collisionR;                                        // 0x03EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ParticleCount;                                     // 0x03F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         linkDis;                                           // 0x03F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         substepCount;                                      // 0x03F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                accel_ext;                                         // 0x03FC(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                actorPos;                                          // 0x0408(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableCPURead;                                    // 0x0414(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_415[0x3];                                      // 0x0415(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FKuroCSParticle_windbell_set>   ParticlesArr;                                      // 0x0418(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FVector                                startPos;                                          // 0x0428(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                endPos;                                            // 0x0434(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                dynamicGravity;                                    // 0x0440(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44C[0xC];                                      // 0x044C(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitShaderManager();
	void ReleaseShaderManager();
	void StartSimulation();
	void StopSimulation();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroCSWindbell_set">();
	}
	static class AKuroCSWindbell_set* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKuroCSWindbell_set>();
	}
};
static_assert(alignof(AKuroCSWindbell_set) == 0x000008, "Wrong alignment on AKuroCSWindbell_set");
static_assert(sizeof(AKuroCSWindbell_set) == 0x000458, "Wrong size on AKuroCSWindbell_set");
static_assert(offsetof(AKuroCSWindbell_set, Root) == 0x0003A8, "Member 'AKuroCSWindbell_set::Root' has a wrong offset!");
static_assert(offsetof(AKuroCSWindbell_set, useExternalRT) == 0x0003B0, "Member 'AKuroCSWindbell_set::useExternalRT' has a wrong offset!");
static_assert(offsetof(AKuroCSWindbell_set, RenderTarget) == 0x0003B8, "Member 'AKuroCSWindbell_set::RenderTarget' has a wrong offset!");
static_assert(offsetof(AKuroCSWindbell_set, RenderTarget_N) == 0x0003C0, "Member 'AKuroCSWindbell_set::RenderTarget_N' has a wrong offset!");
static_assert(offsetof(AKuroCSWindbell_set, DebugArr) == 0x0003C8, "Member 'AKuroCSWindbell_set::DebugArr' has a wrong offset!");
static_assert(offsetof(AKuroCSWindbell_set, DisStiffness) == 0x0003D8, "Member 'AKuroCSWindbell_set::DisStiffness' has a wrong offset!");
static_assert(offsetof(AKuroCSWindbell_set, bendStiffness) == 0x0003DC, "Member 'AKuroCSWindbell_set::bendStiffness' has a wrong offset!");
static_assert(offsetof(AKuroCSWindbell_set, playerPos) == 0x0003E0, "Member 'AKuroCSWindbell_set::playerPos' has a wrong offset!");
static_assert(offsetof(AKuroCSWindbell_set, collisionR) == 0x0003EC, "Member 'AKuroCSWindbell_set::collisionR' has a wrong offset!");
static_assert(offsetof(AKuroCSWindbell_set, ParticleCount) == 0x0003F0, "Member 'AKuroCSWindbell_set::ParticleCount' has a wrong offset!");
static_assert(offsetof(AKuroCSWindbell_set, linkDis) == 0x0003F4, "Member 'AKuroCSWindbell_set::linkDis' has a wrong offset!");
static_assert(offsetof(AKuroCSWindbell_set, substepCount) == 0x0003F8, "Member 'AKuroCSWindbell_set::substepCount' has a wrong offset!");
static_assert(offsetof(AKuroCSWindbell_set, accel_ext) == 0x0003FC, "Member 'AKuroCSWindbell_set::accel_ext' has a wrong offset!");
static_assert(offsetof(AKuroCSWindbell_set, actorPos) == 0x000408, "Member 'AKuroCSWindbell_set::actorPos' has a wrong offset!");
static_assert(offsetof(AKuroCSWindbell_set, bEnableCPURead) == 0x000414, "Member 'AKuroCSWindbell_set::bEnableCPURead' has a wrong offset!");
static_assert(offsetof(AKuroCSWindbell_set, ParticlesArr) == 0x000418, "Member 'AKuroCSWindbell_set::ParticlesArr' has a wrong offset!");
static_assert(offsetof(AKuroCSWindbell_set, startPos) == 0x000428, "Member 'AKuroCSWindbell_set::startPos' has a wrong offset!");
static_assert(offsetof(AKuroCSWindbell_set, endPos) == 0x000434, "Member 'AKuroCSWindbell_set::endPos' has a wrong offset!");
static_assert(offsetof(AKuroCSWindbell_set, dynamicGravity) == 0x000440, "Member 'AKuroCSWindbell_set::dynamicGravity' has a wrong offset!");

}


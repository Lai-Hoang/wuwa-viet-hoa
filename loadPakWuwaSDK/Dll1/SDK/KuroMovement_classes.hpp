#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: KuroMovement

#include "Basic.hpp"

#include "CoreUObject_classes.hpp"
#include "KuroMovement_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "KuroGameplay_structs.hpp"


namespace SDK
{

// Class KuroMovement.KuroClimbObject
// 0x01F0 (0x0220 - 0x0030)
class UKuroClimbObject final : public UObject
{
public:
	uint8                                         Pad_30[0x1F0];                                     // 0x0030(0x01F0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool ClimbBlock();
	void ConfirmMove();
	struct FVectorDouble D_GetSafetyLocation();
	bool D_ProcessClimbing(const struct FVectorDouble& MoveSpeed, float DeltaTime, bool IsTryMove, float DebugDrawDuration, struct FTransformDouble* OutTrans);
	EClimbingArriveType D_TryClimbingArrives(const struct FVectorDouble& InputDirect, float DebugDrawDuration, struct FTransformDouble* OutTrans, bool NeedTryBlockUp);
	ESprintVaultType D_TrySprintVault(float DebugDrawDuration, struct FTransformDouble* OutTrans, float* OutLongOffset);
	bool D_TryStartClimb(const struct FTransformDouble& Trans, float DebugDrawDuration, struct FTransformDouble* OutTrans);
	EClimbingArriveType D_TryUpArrives(const struct FVectorDouble& InputDirect, float DebugDrawDuration, struct FTransformDouble* OutTrans);
	void ExitClimb();
	struct FVector GetSafetyLocation();
	struct FVector GetSecondMoveOffset();
	void InitBase(class UShapeComponent* InShapeComp, ECollisionChannel InClimbChannel, const TArray<struct FVector>& BaseLocations, float InSphereRadius, float InActorToWallDist, float InDetectLength, float InSafetyHalfHeight, float InSafetyRadius);
	void InitBlockUps(const struct FVector& InBlockUpOffset, float InBlockUpDetectRadius, float InBlockUpDetectDistance, float InBlockUpBackDistance, float InBlockUpBackMin, const struct FVector& InBlockUpFinalMove, float BlockUpVerticalRangeMin, float BlockUpVerticalRangeMax);
	void InitClimbSafety(float InRadius, float InHalfHeight, float InMaxOffset);
	void InitSprintVault(float InForwardBlockHeight, float InForwardBlockRadius, float InForwardBlockDistanceMin, float InForwardBlockDistanceMax, const struct FVector& InSprintVaultMoveOffset, float InHeightMin, float InHeightMax, float InSprintVaultLongNeedDistance, float InSprintVaultLongHeight, ETraceTypeQuery InBlockChannel, float SprintVaultLongMin, float SprintVaultLongMax, float SprintVaultBlockMaxAngle);
	void InitUpArrives(const TArray<struct FVector>& InUpArriveMoveOffsets, const TArray<float>& InHeightMins, const TArray<float>& InHeightMaxs);
	bool NeedFollowHangOnStartingClimb();
	bool ProcessClimbing(const struct FVector& MoveSpeed, float DeltaTime, bool IsTryMove, float DebugDrawDuration, struct FTransform* OutTrans);
	void SyncFromOther(class UKuroClimbObject* Other);
	EClimbingArriveType TryClimbingArrives(const struct FVector& InputDirect, float DebugDrawDuration, struct FTransform* OutTrans, bool NeedTryBlockUp);
	ESprintVaultType TrySprintVault(float DebugDrawDuration, struct FTransform* OutTrans, float* OutLongOffset);
	bool TryStartClimb(const struct FTransform& Trans, float DebugDrawDuration, struct FTransform* OutTrans);
	EClimbingArriveType TryUpArrives(const struct FVector& InputDirect, float DebugDrawDuration, struct FTransform* OutTrans);

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("KuroClimbObject")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"KuroClimbObject")
	}
	static class UKuroClimbObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroClimbObject>();
	}
};
DUMPER7_ASSERTS_UKuroClimbObject;

// Class KuroMovement.KuroDebugMovementComponent
// 0x01A0 (0x06D0 - 0x0530)
class UKuroDebugMovementComponent final : public UPrimitiveComponent
{
public:
	int32                                         DrawDebugCount;                                    // 0x0528(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bShowLog : 1;                                      // 0x052C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	EKDMDrawDebugType                             bDrawDebug;                                        // 0x052D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_52E[0x1A2];                                    // 0x052E(0x01A2)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class FString KuroDebugMovementBaseRecordToString(const struct FBaseRecord& Record);

	int32 GetCurrentFrameIndex();
	class FString GetFrameCountInfo();
	int32 GetMaxRecordFrameCount();
	const struct FSingleFrameDebugInfo GetPreviousRecord(int32 preNum);
	const TArray<struct FSingleFrameDebugInfo> GetRecentRecords();
	int32 GetRecordFrames();
	void RecordModifyInfo(const class FString& Context, const struct FVector& CustomVector, EKDMRecordType Type);
	void Resigter();
	void SetDebug(bool bDebug, bool bDetial);
	void UnResigter();

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("KuroDebugMovementComponent")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"KuroDebugMovementComponent")
	}
	static class UKuroDebugMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroDebugMovementComponent>();
	}
};
DUMPER7_ASSERTS_UKuroDebugMovementComponent;

// Class KuroMovement.KuroMoveTrigger
// 0x0008 (0x02B8 - 0x02B0)
class AKuroMoveTrigger : public AActor
{
public:
	ETriggerAreaType                              AreaType;                                          // 0x02B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B1[0x7];                                      // 0x02B1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void OnEnterOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("KuroMoveTrigger")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"KuroMoveTrigger")
	}
	static class AKuroMoveTrigger* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKuroMoveTrigger>();
	}
};
DUMPER7_ASSERTS_AKuroMoveTrigger;

// Class KuroMovement.KuroMoveBoxTrigger
// 0x0008 (0x02C0 - 0x02B8)
class AKuroMoveBoxTrigger final : public AKuroMoveTrigger
{
public:
	class UBoxComponent*                          BoxCollision;                                      // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("KuroMoveBoxTrigger")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"KuroMoveBoxTrigger")
	}
	static class AKuroMoveBoxTrigger* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKuroMoveBoxTrigger>();
	}
};
DUMPER7_ASSERTS_AKuroMoveBoxTrigger;

// Class KuroMovement.KuroMoveBrushTrigger
// 0x0010 (0x02C8 - 0x02B8)
class AKuroMoveBrushTrigger final : public AKuroMoveTrigger
{
public:
	class ABrush*                                 Volume;                                            // 0x02B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        Root;                                              // 0x02C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("KuroMoveBrushTrigger")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"KuroMoveBrushTrigger")
	}
	static class AKuroMoveBrushTrigger* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKuroMoveBrushTrigger>();
	}
};
DUMPER7_ASSERTS_AKuroMoveBrushTrigger;

// Class KuroMovement.KuroMovementBPLibrary
// 0x0000 (0x0030 - 0x0030)
class UKuroMovementBPLibrary final : public UBlueprintFunctionLibrary
{
public:
	static float KuroBinarySearchCurve(class UCurveFloat* Curve, float Y, float From, float To, float tolerance);
	static int32 KuroEaseSpeedTo(class UPawnMovementComponent* PawnMoveComp, const float TargetSpeed, const EKuroEasingFuncType EaseType, const float TransitionTime, const float Exponent, const class FString& CurvePath);
	static bool KuroKite(float DeltaSeconds, class UCharacterMovementComponent* CharMoveComp, const struct FVector& TargetPrevPos, const struct FVector& TargetNextPos, float MinDist, float MaxDist, float MinAccel, float MaxAccel, float Friction, struct FVector* InOutTargetForward, float FacingLerpSpeed, float FacingLerpRate);
	static bool KuroRoll(float DeltaSeconds, class UCharacterMovementComponent* CharMoveComp, float TargetSpeed, float Friction, float AccelOnGround, struct FVector* FloorNormal, float Gravity, float StepUpHeight, float MaxSpeed);
	static int32 KuroSki(float DeltaTime, class UCharacterMovementComponent* CharMoveComp, const struct FVector& PrevBlockNormal, const struct FVector& Direction, const struct FVector& SpeedParams, float IgnoreStepHeight, class UCurveFloat* SpeedReduceCurve);
	static EMoveHitType KuroSoar(float DeltaSeconds, class UCharacterMovementComponent* CharMoveComp, float AirFriction, float Aerodynamics, const struct FVector& Gravity, const struct FVector& SoarPlaneNormal, float MaxSpeed);

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("KuroMovementBPLibrary")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"KuroMovementBPLibrary")
	}
	static class UKuroMovementBPLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroMovementBPLibrary>();
	}
};
DUMPER7_ASSERTS_UKuroMovementBPLibrary;

// Class KuroMovement.KuroMoveTriggerController
// 0x0020 (0x02D0 - 0x02B0)
class AKuroMoveTriggerController final : public AInfo
{
public:
	TMulticastInlineDelegate<void(const TArray<struct FOverlapActorRecord>& Records)> Callback;      // 0x02B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<struct FOverlapActorRecord>            Records;                                           // 0x02C0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static void RegisterController(class AKuroMoveTriggerController* ControllerPtr);
	static void UnRegisterController();

	void InitAllTriggers();

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("KuroMoveTriggerController")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"KuroMoveTriggerController")
	}
	static class AKuroMoveTriggerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKuroMoveTriggerController>();
	}
};
DUMPER7_ASSERTS_AKuroMoveTriggerController;

}

